{"version":3,"sources":["../src/atomWithFn.ts","../src/createAtomProvider.tsx","../src/useHydrateStore.ts","../src/createAtomStore.ts"],"sourcesContent":["import { atom } from 'jotai';\n\nimport type { WritableAtom } from 'jotai/vanilla';\n\ntype WrapFn<T> = T extends (...args: infer _A) => infer _R ? { __fn: T } : T;\n\nconst wrapFn = <T>(fnOrValue: T): WrapFn<T> =>\n  (typeof fnOrValue === 'function' ? { __fn: fnOrValue } : fnOrValue) as any;\n\ntype UnwrapFn<T> = T extends { __fn: infer U } ? U : T;\n\nconst unwrapFn = <T>(wrappedFnOrValue: T): UnwrapFn<T> =>\n  (wrappedFnOrValue &&\n  typeof wrappedFnOrValue === 'object' &&\n  '__fn' in wrappedFnOrValue\n    ? wrappedFnOrValue.__fn\n    : wrappedFnOrValue) as any;\n\n/**\n * Jotai atoms don't allow functions as values by default. This function is a\n * drop-in replacement for `atom` that wraps functions in an object while\n * leaving non-functions unchanged. The wrapper object should be completely\n * invisible to consumers of the atom.\n */\nexport const atomWithFn = <T>(initialValue: T): WritableAtom<T, [T], void> => {\n  const baseAtom = atom(wrapFn(initialValue));\n\n  return atom(\n    (get) => unwrapFn(get(baseAtom)) as T,\n    (_get, set, value) => set(baseAtom, wrapFn(value))\n  );\n};\n","'use client';\n\nimport React, { PropsWithChildren } from 'react';\nimport { createStore } from 'jotai/vanilla';\n\nimport { JotaiStore, SimpleWritableAtomRecord } from './createAtomStore';\nimport { useHydrateStore, useSyncStore } from './useHydrateStore';\n\nconst getFullyQualifiedScope = (storeName: string, scope: string) => {\n  return `${storeName}:${scope}`;\n};\n\n/**\n * Context mapping store name and scope to store. The 'provider' scope is used\n * to reference any provider belonging to the store, regardless of scope.\n */\nconst PROVIDER_SCOPE = 'provider';\nconst AtomStoreContext = React.createContext<Map<string, JotaiStore>>(\n  new Map()\n);\n\n/**\n * Tries to find a store in each of the following places, in order:\n * 1. The store context, matching the store name and scope\n * 2. The store context, matching the store name and 'provider' scope\n * 3. Otherwise, return undefined\n */\nexport const useAtomStore = (\n  storeName: string,\n  scope: string = PROVIDER_SCOPE,\n  warnIfUndefined: boolean = true\n): JotaiStore | undefined => {\n  const storeContext = React.useContext(AtomStoreContext);\n  const store =\n    storeContext.get(getFullyQualifiedScope(storeName, scope)) ??\n    storeContext.get(getFullyQualifiedScope(storeName, PROVIDER_SCOPE));\n\n  if (!store && warnIfUndefined) {\n    console.warn(\n      `Tried to access jotai store '${storeName}' outside of a matching provider.`\n    );\n  }\n\n  return store;\n};\n\nexport type ProviderProps<T extends object> = Partial<T> &\n  PropsWithChildren<{\n    store?: JotaiStore;\n    scope?: string;\n    initialValues?: Partial<T>;\n    resetKey?: any;\n  }>;\n\nexport const HydrateAtoms = <T extends object>({\n  initialValues,\n  children,\n  store,\n  atoms,\n  ...props\n}: Omit<ProviderProps<T>, 'scope'> & {\n  atoms: SimpleWritableAtomRecord<T>;\n}) => {\n  useHydrateStore(atoms, { ...initialValues, ...props } as any, {\n    store,\n  });\n  useSyncStore(atoms, props as any, {\n    store,\n  });\n\n  return <>{children}</>;\n};\n\n/**\n * Creates a generic provider for a jotai store.\n * - `initialValues`: Initial values for the store.\n * - `props`: Dynamic values for the store.\n */\nexport const createAtomProvider = <T extends object, N extends string = ''>(\n  storeScope: N,\n  atoms: SimpleWritableAtomRecord<T>,\n  options: { effect?: React.FC } = {}\n) => {\n  const Effect = options.effect;\n\n  // eslint-disable-next-line react/display-name\n  return ({ store, scope, children, resetKey, ...props }: ProviderProps<T>) => {\n    const [storeState, setStoreState] =\n      React.useState<JotaiStore>(createStore());\n\n    React.useEffect(() => {\n      if (resetKey) {\n        setStoreState(createStore());\n      }\n    }, [resetKey]);\n\n    const previousStoreContext = React.useContext(AtomStoreContext);\n\n    const storeContext = React.useMemo(() => {\n      const newStoreContext = new Map(previousStoreContext);\n\n      if (scope) {\n        // Make the store findable by its fully qualified scope\n        newStoreContext.set(\n          getFullyQualifiedScope(storeScope, scope),\n          storeState\n        );\n      }\n\n      // Make the store findable by its store name alone\n      newStoreContext.set(\n        getFullyQualifiedScope(storeScope, PROVIDER_SCOPE),\n        storeState\n      );\n\n      return newStoreContext;\n    }, [previousStoreContext, scope, storeState]);\n\n    return (\n      <AtomStoreContext.Provider value={storeContext}>\n        <HydrateAtoms store={storeState} atoms={atoms} {...(props as any)}>\n          {!!Effect && <Effect />}\n\n          {children}\n        </HydrateAtoms>\n      </AtomStoreContext.Provider>\n    );\n  };\n};\n","import React from 'react';\nimport { useSetAtom } from 'jotai';\nimport { useHydrateAtoms } from 'jotai/utils';\n\nimport {\n  SimpleWritableAtomRecord,\n  UseHydrateAtoms,\n  UseSyncAtoms,\n} from './createAtomStore';\n\n/**\n * Hydrate atoms with initial values for SSR.\n */\nexport const useHydrateStore = (\n  atoms: SimpleWritableAtomRecord<any>,\n  initialValues: Parameters<UseHydrateAtoms<any>>[0],\n  options: Parameters<UseHydrateAtoms<any>>[1] = {}\n) => {\n  const values: any[] = [];\n\n  for (const key of Object.keys(atoms)) {\n    const initialValue = initialValues[key];\n\n    if (initialValue !== undefined) {\n      values.push([atoms[key], initialValue]);\n    }\n  }\n\n  useHydrateAtoms(values, options);\n};\n\n/**\n * Update atoms with new values on changes.\n */\nexport const useSyncStore = (\n  atoms: SimpleWritableAtomRecord<any>,\n  values: any,\n  { store }: Parameters<UseSyncAtoms<any>>[1] = {}\n) => {\n  for (const key of Object.keys(atoms)) {\n    const value = values[key];\n    const atom = atoms[key];\n\n    // eslint-disable-next-line react-compiler/react-compiler\n    const set = useSetAtom(atom, { store });\n\n    // eslint-disable-next-line react-compiler/react-compiler\n    React.useEffect(() => {\n      if (value !== undefined && value !== null) {\n        set(value);\n      }\n    }, [set, value]);\n  }\n};\n","import React, { useMemo } from 'react';\nimport { getDefaultStore, useAtom, useAtomValue, useSetAtom } from 'jotai';\nimport { selectAtom, useHydrateAtoms } from 'jotai/utils';\n\nimport { atomWithFn } from './atomWithFn';\nimport { createAtomProvider, useAtomStore } from './createAtomProvider';\n\nimport type { ProviderProps } from './createAtomProvider';\nimport type { Atom, createStore, WritableAtom } from 'jotai/vanilla';\n\nexport type JotaiStore = ReturnType<typeof createStore>;\n\nexport type UseAtomOptions = {\n  scope?: string;\n  store?: JotaiStore;\n  delay?: number;\n  warnIfNoStore?: boolean;\n};\n\ntype UseAtomOptionsOrScope = UseAtomOptions | string;\n\ntype UseValueRecord<O> = {\n  [K in keyof O]: O[K] extends Atom<infer V> ? () => V : never;\n};\n\ntype GetRecord<O> = UseValueRecord<O>;\n\ntype UseSetRecord<O> = {\n  [K in keyof O]: O[K] extends WritableAtom<infer _V, infer A, infer R>\n    ? () => (...args: A) => R\n    : never;\n};\n\ntype SetRecord<O> = {\n  [K in keyof O]: O[K] extends WritableAtom<infer _V, infer A, infer R>\n    ? (...args: A) => R\n    : never;\n};\n\ntype UseStateRecord<O> = {\n  [K in keyof O]: O[K] extends WritableAtom<infer V, infer A, infer R>\n    ? () => [V, (...args: A) => R]\n    : never;\n};\n\ntype SubscribeRecord<O> = {\n  [K in keyof O]: O[K] extends Atom<infer V>\n    ? (callback: (newValue: V) => void) => () => void\n    : never;\n};\n\ntype StoreAtomsWithoutExtend<T> = {\n  [K in keyof T]: T[K] extends Atom<any> ? T[K] : SimpleWritableAtom<T[K]>;\n};\n\ntype ValueTypesForAtoms<T> = {\n  [K in keyof T]: T[K] extends Atom<infer V> ? V : never;\n};\n\ntype StoreInitialValues<T> = ValueTypesForAtoms<StoreAtomsWithoutExtend<T>>;\n\ntype StoreAtoms<T, E> = StoreAtomsWithoutExtend<T> & E;\n\ntype FilterWritableAtoms<T> = {\n  [K in keyof T]-?: T[K] extends WritableAtom<any, any, any> ? T[K] : never;\n};\n\ntype WritableStoreAtoms<T, E> = FilterWritableAtoms<StoreAtoms<T, E>>;\n\nexport type SimpleWritableAtom<T> = WritableAtom<T, [T], void>;\n\nexport type SimpleWritableAtomRecord<T> = {\n  [K in keyof T]: SimpleWritableAtom<T[K]>;\n};\n\nexport type AtomRecord<O> = {\n  [K in keyof O]: Atom<O[K]>;\n};\n\ntype UseNameStore<N extends string = ''> = `use${Capitalize<N>}Store`;\ntype NameStore<N extends string = ''> = N extends '' ? 'store' : `${N}Store`;\ntype NameProvider<N extends string = ''> = `${Capitalize<N>}Provider`;\n\ntype UseKeyValue<K extends string = ''> = `use${Capitalize<K>}Value`;\ntype GetKey<K extends string = ''> = `get${Capitalize<K>}`;\ntype UseSetKey<K extends string = ''> = `useSet${Capitalize<K>}`;\ntype SetKey<K extends string = ''> = `set${Capitalize<K>}`;\ntype UseKeyState<K extends string = ''> = `use${Capitalize<K>}State`;\ntype SubscribeKey<K extends string = ''> = `subscribe${Capitalize<K>}`;\n\nexport type UseHydrateAtoms<T> = (\n  initialValues: Partial<Record<keyof T, any>>,\n  options?: Parameters<typeof useHydrateAtoms>[1]\n) => void;\nexport type UseSyncAtoms<T> = (\n  values: Partial<Record<keyof T, any>>,\n  options?: {\n    store?: JotaiStore;\n  }\n) => void;\n\nexport type StoreApi<\n  T extends object,\n  E extends AtomRecord<object>,\n  N extends string = '',\n> = {\n  atom: StoreAtoms<T, E>;\n  name: N;\n};\n\ntype GetAtomFn = <V>(\n  atom: Atom<V>,\n  store?: JotaiStore,\n  options?: UseAtomOptionsOrScope\n) => V;\n\ntype UseAtomValueFn = <V, S = V>(\n  atom: Atom<V>,\n  store?: JotaiStore,\n  options?: UseAtomOptionsOrScope,\n  selector?: (v: V, prevSelectorOutput?: S) => S,\n  equalityFnOrDeps?:\n    | ((prevSelectorOutput: S, selectorOutput: S) => boolean)\n    | unknown[],\n  deps?: unknown[]\n) => S;\n\ntype SetAtomFn = <V, A extends unknown[], R>(\n  atom: WritableAtom<V, A, R>,\n  store?: JotaiStore,\n  options?: UseAtomOptionsOrScope\n) => (...args: A) => R;\n\ntype UseSetAtomFn = SetAtomFn;\n\ntype UseAtomFn = <V, A extends unknown[], R>(\n  atom: WritableAtom<V, A, R>,\n  store?: JotaiStore,\n  options?: UseAtomOptionsOrScope\n) => [V, (...args: A) => R];\n\ntype SubscribeAtomFn = <V>(\n  atom: Atom<V>,\n  store?: JotaiStore,\n  options?: UseAtomOptionsOrScope\n) => (callback: (newValue: V) => void) => () => void;\n\ntype UseValueOptions<V, S> = {\n  selector?: (v: V, prevSelectorOutput?: S) => S;\n  equalityFn?: (prev: S, next: S) => boolean;\n} & UseAtomOptions;\n\n// store.use<Key>Value()\nexport type UseKeyValueApis<O> = {\n  [K in keyof O as UseKeyValue<K & string>]: {\n    (): O[K] extends Atom<infer V> ? V : never;\n    <S>(\n      selector: O[K] extends Atom<infer V>\n        ? (v: V, prevSelectorOutput?: S) => S\n        : never,\n      deps?: unknown[]\n    ): S;\n    <S>(\n      selector:\n        | (O[K] extends Atom<infer V>\n            ? (v: V, prevSelectorOutput?: S) => S\n            : never)\n        | undefined,\n      equalityFn: (prevSelectorOutput: S, selectorOutput: S) => boolean,\n      deps?: unknown[]\n    ): S;\n  };\n};\n\n// store.get<Key>()\nexport type GetKeyApis<O> = {\n  [K in keyof O as GetKey<K & string>]: O[K] extends Atom<infer V>\n    ? () => V\n    : never;\n};\n\n// store.useSet<Key>()\nexport type UseSetKeyApis<O> = {\n  [K in keyof O as UseSetKey<K & string>]: O[K] extends WritableAtom<\n    infer _V,\n    infer A,\n    infer R\n  >\n    ? () => (...args: A) => R\n    : never;\n};\n\n// store.set<Key>(...args)\nexport type SetKeyApis<O> = {\n  [K in keyof O as SetKey<K & string>]: O[K] extends WritableAtom<\n    infer _V,\n    infer A,\n    infer R\n  >\n    ? (...args: A) => R\n    : never;\n};\n\n// store.use<Key>State()\nexport type UseKeyStateApis<O> = {\n  [K in keyof O as UseKeyState<K & string>]: O[K] extends WritableAtom<\n    infer V,\n    infer A,\n    infer R\n  >\n    ? () => [V, (...args: A) => R]\n    : never;\n};\n\n// store.subscribe<Key>(callback)\nexport type SubscribeKeyApis<O> = {\n  [K in keyof O as SubscribeKey<K & string>]: O[K] extends Atom<infer V>\n    ? (callback: (newValue: V) => void) => () => void\n    : never;\n};\n\n// store.useValue('key')\nexport type UseParamKeyValueApi<O> = {\n  // abc\n  <K extends keyof O>(key: K): O[K] extends Atom<infer V> ? V : never;\n  <K extends keyof O, S>(\n    key: K,\n    selector: O[K] extends Atom<infer V>\n      ? (v: V, prevSelectorOutput?: S) => S\n      : never,\n    deps?: unknown[]\n  ): S;\n  <K extends keyof O, S>(\n    key: K,\n    selector:\n      | (O[K] extends Atom<infer V>\n          ? (v: V, prevSelectorOutput?: S) => S\n          : never)\n      | undefined,\n    equalityFn: (prevSelectorOutput: S, selectorOutput: S) => boolean,\n    deps?: unknown[]\n  ): S;\n};\n\n// store.get('key')\nexport type GetParamKeyApi<O> = <K extends keyof O>(\n  key: K\n) => O[K] extends Atom<infer V> ? V : never;\n\n// store.useSet('key')\nexport type UseSetParamKeyApi<O> = <K extends keyof O>(\n  key: K\n) => O[K] extends WritableAtom<infer _V, infer A, infer R>\n  ? (...args: A) => R\n  : never;\n// store.set('key', ...args)\nexport type SetParamKeyApi<O> = <K extends keyof O, A extends unknown[]>(\n  key: K,\n  ...args: A\n) => O[K] extends WritableAtom<infer _V, A, infer R> ? R : never;\n\n// store.useState('key')\nexport type UseParamKeyStateApi<O> = <K extends keyof O>(\n  key: K\n) => O[K] extends WritableAtom<infer V, infer A, infer R>\n  ? [V, (...args: A) => R]\n  : never;\n\n// store.subscribe('key', callback)\nexport type SubscribeParamKeyApi<O> = <K extends keyof O, V>(\n  key: K,\n  callback: (newValue: V) => void\n) => O[K] extends Atom<V> ? () => void : never;\n\nexport type UseAtomParamValueApi = {\n  <V>(atom: Atom<V>): V;\n  <V, S = V>(\n    atom: Atom<V>,\n    selector: (v: V, prevSelectorOutput?: S) => S,\n    deps?: unknown[]\n  ): S;\n  <V, S = V>(\n    atom: Atom<V>,\n    selector: ((v: V, prevSelectorOutput?: S) => S) | undefined,\n    equalityFn: (prevSelectorOutput: S, selectorOutput: S) => boolean,\n    deps?: unknown[]\n  ): S;\n};\nexport type GetAtomParamApi = <V>(atom: Atom<V>) => V;\nexport type UseSetAtomParamApi = <V, A extends unknown[], R>(\n  atom: WritableAtom<V, A, R>\n) => (...args: A) => R;\nexport type SetAtomParamApi = <V, A extends unknown[], R>(\n  atom: WritableAtom<V, A, R>\n) => (...args: A) => R;\nexport type UseAtomParamStateApi = <V, A extends unknown[], R>(\n  atom: WritableAtom<V, A, R>\n) => [V, (...args: A) => R];\nexport type SubscribeAtomParamApi = <V>(\n  atom: Atom<V>\n) => (callback: (newValue: V) => void) => () => void;\n\nexport type ReturnOfUseStoreApi<T, E> = UseKeyValueApis<StoreAtoms<T, E>> &\n  GetKeyApis<StoreAtoms<T, E>> &\n  UseSetKeyApis<StoreAtoms<T, E>> &\n  SetKeyApis<StoreAtoms<T, E>> &\n  UseKeyStateApis<StoreAtoms<T, E>> &\n  SubscribeKeyApis<StoreAtoms<T, E>> & {\n    /**\n     * When providing `selector`, the atom value will be transformed using the selector function.\n     * The selector and equalityFn MUST be memoized.\n     *\n     * @see https://jotai.org/docs/utilities/select#selectatom\n     *\n     * @example\n     *   const store = useStore()\n     *   // only rerenders when the first element of the array changes\n     *   const arrayFirst = store.useValue('array', array => array[0], [])\n     *   // only rerenders when the first element of the array changes, but returns the whole array\n     *   const array = store.useValue('array', undefined, (prev, next) => prev[0] === next[0], [])\n     *   // without dependency array, then you need to memoize the selector and equalityFn yourself\n     *   const cb = useCallback((array) => array[n], [n])\n     *   const arrayNth = store.useValue('array', cb)\n     *\n     * @param key The key of the atom\n     * @param selector A function that takes the atom value and returns the value to be used. Defaults to identity function that returns the atom value.\n     * @param equalityFnOrDeps Dependency array or a function that compares the previous selector output and the new selector output. Defaults to comparing outputs of the selector function.\n     * @param deps Dependency array for the selector and equalityFn\n     */\n    useValue: UseParamKeyValueApi<StoreAtoms<T, E>>;\n    get: GetParamKeyApi<StoreAtoms<T, E>>;\n    useSet: UseSetParamKeyApi<StoreAtoms<T, E>>;\n    set: SetParamKeyApi<StoreAtoms<T, E>>;\n    useState: UseParamKeyStateApi<StoreAtoms<T, E>>;\n    subscribe: SubscribeParamKeyApi<StoreAtoms<T, E>>;\n    /**\n     * When providing `selector`, the atom value will be transformed using the selector function.\n     * The selector and equalityFn MUST be memoized.\n     *\n     * @see https://jotai.org/docs/utilities/select#selectatom\n     *\n     * @example\n     *   const store = useStore()\n     *   // only rerenders when the first element of the array changes\n     *   const arrayFirst = store.useAtomValue(arrayAtom, array => array[0])\n     *   // only rerenders when the first element of the array changes, but returns the whole array\n     *   const array = store.useAtomValue(arrayAtom, undefined, (prev, next) => prev[0] === next[0])\n     *   // without dependency array, then you need to memoize the selector and equalityFn yourself\n     *  const cb = useCallback((array) => array[n], [n])\n     * const arrayNth = store.useAtomValue(arrayAtom, cb)\n     *\n     * @param atom The atom to use\n     * @param selector A function that takes the atom value and returns the value to be used. Defaults to identity function that returns the atom value.\n     * @param equalityFn Dependency array or a function that compares the previous selector output and the new selector output. Defaults to comparing outputs of the selector function.\n     * @param deps Dependency array for the selector and equalityFn\n     */\n    useAtomValue: UseAtomParamValueApi;\n    getAtom: GetAtomParamApi;\n    useSetAtom: UseSetAtomParamApi;\n    setAtom: SetAtomParamApi;\n    useAtomState: UseAtomParamStateApi;\n    subscribeAtom: SubscribeAtomParamApi;\n    store: JotaiStore | undefined;\n  };\n\ntype UseKeyStateUtil<T, E> = <K extends keyof StoreAtoms<T, E>>(\n  key: K,\n  options?: UseAtomOptionsOrScope\n) => StoreAtoms<T, E>[K] extends WritableAtom<infer V, infer A, infer R>\n  ? [V, (...args: A) => R]\n  : never;\n\ntype UseKeyValueUtil<T, E> = <\n  K extends keyof StoreAtoms<T, E>,\n  S = StoreAtoms<T, E>[K] extends Atom<infer V> ? V : never,\n>(\n  key: K,\n  options?: UseValueOptions<\n    StoreAtoms<T, E>[K] extends Atom<infer V> ? V : never,\n    S\n  >,\n  deps?: unknown[]\n) => S;\n\ntype UseKeySetUtil<T, E> = <K extends keyof StoreAtoms<T, E>>(\n  key: K,\n  options?: UseAtomOptionsOrScope\n) => StoreAtoms<T, E>[K] extends WritableAtom<infer _V, infer A, infer R>\n  ? (...args: A) => R\n  : never;\n\nexport type AtomStoreApi<\n  T extends object,\n  E extends AtomRecord<object>,\n  N extends string = '',\n> = {\n  name: N;\n} & {\n  [key in keyof Record<NameProvider<N>, object>]: React.FC<\n    ProviderProps<StoreInitialValues<T>>\n  >;\n} & {\n  [key in keyof Record<NameStore<N>, object>]: StoreApi<T, E, N>;\n} & {\n  [key in keyof Record<UseNameStore<N>, object>]: UseStoreApi<T, E>;\n} & {\n  [key in keyof Record<`use${Capitalize<N>}State`, object>]: UseKeyStateUtil<\n    T,\n    E\n  >;\n} & {\n  [key in keyof Record<`use${Capitalize<N>}Value`, object>]: UseKeyValueUtil<\n    T,\n    E\n  >;\n} & {\n  [key in keyof Record<`use${Capitalize<N>}Set`, object>]: UseKeySetUtil<T, E>;\n};\n\nexport type UseStoreApi<T, E> = (\n  options?: UseAtomOptionsOrScope\n) => ReturnOfUseStoreApi<T, E>;\n\nconst capitalizeFirstLetter = (str = '') =>\n  str.length > 0 ? str[0].toUpperCase() + str.slice(1) : '';\nconst getProviderIndex = (name = '') =>\n  `${capitalizeFirstLetter(name)}Provider`;\nconst getStoreIndex = (name = '') =>\n  name.length > 0 ? `${name}Store` : 'store';\nconst getUseStoreIndex = (name = '') =>\n  `use${capitalizeFirstLetter(name)}Store`;\n\nconst getUseValueIndex = (key = '') => `use${capitalizeFirstLetter(key)}Value`;\nconst getGetIndex = (key = '') => `get${capitalizeFirstLetter(key)}`;\nconst getUseSetIndex = (key = '') => `useSet${capitalizeFirstLetter(key)}`;\nconst getSetIndex = (key = '') => `set${capitalizeFirstLetter(key)}`;\nconst getUseStateIndex = (key = '') => `use${capitalizeFirstLetter(key)}State`;\nconst getSubscribeIndex = (key = '') =>\n  `subscribe${capitalizeFirstLetter(key)}`;\n\nconst isAtom = (possibleAtom: unknown): boolean =>\n  !!possibleAtom &&\n  typeof possibleAtom === 'object' &&\n  'read' in possibleAtom &&\n  typeof possibleAtom.read === 'function';\n\nconst withStoreAndOptions = <T extends object>(\n  fnRecord: T,\n  getIndex: (name?: string) => string,\n  store: JotaiStore | undefined,\n  options: UseAtomOptions\n): any =>\n  Object.fromEntries(\n    Object.entries(fnRecord).map(([key, fn]) => [\n      getIndex(key),\n      (...args: any[]) => (fn as any)(store, options, ...args),\n    ])\n  );\n\nconst withKeyAndStoreAndOptions =\n  <T extends object>(\n    fnRecord: T,\n    store: JotaiStore | undefined,\n    options: UseAtomOptions\n  ): any =>\n  (key: keyof T, ...args: any[]) =>\n    (fnRecord[key] as any)(store, options, ...args);\n\nconst convertScopeShorthand = (\n  optionsOrScope: UseAtomOptionsOrScope = {}\n): UseAtomOptions =>\n  typeof optionsOrScope === 'string'\n    ? { scope: optionsOrScope }\n    : optionsOrScope;\n\nconst useConvertScopeShorthand: typeof convertScopeShorthand = (\n  optionsOrScope\n) => {\n  const convertedOptions = convertScopeShorthand(optionsOrScope);\n  // Works because all values are primitives\n  // eslint-disable-next-line react-compiler/react-compiler\n  return useMemo(() => convertedOptions, Object.values(convertedOptions));\n};\n\nconst identity = (x: any) => x;\n\nexport interface CreateAtomStoreOptions<\n  T extends object,\n  E extends AtomRecord<object>,\n  N extends string,\n> {\n  name: N;\n  delay?: UseAtomOptions['delay'];\n  effect?: React.FC;\n  extend?: (atomsWithoutExtend: StoreAtomsWithoutExtend<T>) => E;\n  infiniteRenderDetectionLimit?: number;\n  suppressWarnings?: boolean;\n}\n\n/**\n * Create an atom store from an initial value.\n * Each property will have a getter and setter.\n *\n * @example\n * const { exampleStore, useExampleStore, useExampleValue, useExampleState, useExampleSet } = createAtomStore({ count: 1, say: 'hello' }, { name: 'example' as const })\n * const [count, setCount] = useExampleState()\n * const say = useExampleValue('say')\n * const setSay = useExampleSet('say')\n * setSay('world')\n * const countAtom = exampleStore.atom.count\n */\nexport const createAtomStore = <\n  T extends object,\n  E extends AtomRecord<object>,\n  N extends string = '',\n>(\n  initialState: T,\n  {\n    name,\n    delay: delayRoot,\n    effect,\n    extend,\n    infiniteRenderDetectionLimit = 100_000,\n    suppressWarnings,\n  }: CreateAtomStoreOptions<T, E, N>\n): AtomStoreApi<T, E, N> => {\n  type MyStoreAtoms = StoreAtoms<T, E>;\n  type MyWritableStoreAtoms = WritableStoreAtoms<T, E>;\n  type MyStoreAtomsWithoutExtend = StoreAtomsWithoutExtend<T>;\n  type MyWritableStoreAtomsWithoutExtend =\n    FilterWritableAtoms<MyStoreAtomsWithoutExtend>;\n  type MyStoreInitialValues = StoreInitialValues<T>;\n\n  const providerIndex = getProviderIndex(name) as NameProvider<N>;\n  const useStoreIndex = getUseStoreIndex(name) as UseNameStore<N>;\n  const storeIndex = getStoreIndex(name) as NameStore<N>;\n\n  const atomsWithoutExtend = {} as MyStoreAtomsWithoutExtend;\n  const writableAtomsWithoutExtend = {} as MyWritableStoreAtomsWithoutExtend;\n  const atomIsWritable = {} as Record<keyof MyStoreAtoms, boolean>;\n\n  for (const [key, atomOrValue] of Object.entries(initialState)) {\n    const atomConfig: Atom<unknown> = isAtom(atomOrValue)\n      ? atomOrValue\n      : atomWithFn(atomOrValue);\n    atomsWithoutExtend[key as keyof MyStoreAtomsWithoutExtend] =\n      atomConfig as any;\n\n    const writable = 'write' in atomConfig;\n    atomIsWritable[key as keyof MyStoreAtoms] = writable;\n\n    if (writable) {\n      writableAtomsWithoutExtend[\n        key as keyof MyWritableStoreAtomsWithoutExtend\n      ] = atomConfig as any;\n    }\n  }\n\n  const atoms = { ...atomsWithoutExtend } as MyStoreAtoms;\n\n  if (extend) {\n    const extendedAtoms = extend(atomsWithoutExtend);\n\n    for (const [key, atomConfig] of Object.entries(extendedAtoms)) {\n      atoms[key as keyof MyStoreAtoms] = atomConfig;\n      atomIsWritable[key as keyof MyStoreAtoms] = 'write' in atomConfig;\n    }\n  }\n\n  const atomsOfUseValue = {} as UseValueRecord<MyStoreAtoms>;\n  const atomsOfGet = {} as GetRecord<MyStoreAtoms>;\n  const atomsOfUseSet = {} as UseSetRecord<MyWritableStoreAtoms>;\n  const atomsOfSet = {} as SetRecord<MyWritableStoreAtoms>;\n  const atomsOfUseState = {} as UseStateRecord<MyWritableStoreAtoms>;\n  const atomsOfSubscribe = {} as SubscribeRecord<MyStoreAtoms>;\n\n  const useStore = (optionsOrScope: UseAtomOptionsOrScope = {}) => {\n    const {\n      scope,\n      store,\n      warnIfNoStore = !suppressWarnings,\n    } = convertScopeShorthand(optionsOrScope);\n    const contextStore = useAtomStore(name, scope, !store && warnIfNoStore);\n    return store ?? contextStore;\n  };\n\n  let renderCount = 0;\n\n  const useAtomValueWithStore: UseAtomValueFn = (\n    atomConfig,\n    store,\n    optionsOrScope,\n    selector,\n    equalityFnOrDeps,\n    deps\n  ) => {\n    // If selector/equalityFn are not memoized, infinite loop will occur.\n    if (process.env.NODE_ENV !== 'production' && infiniteRenderDetectionLimit) {\n      renderCount += 1;\n      if (renderCount > infiniteRenderDetectionLimit) {\n        throw new Error(\n          `\nuse<Key>Value/useValue/use<StoreName>Value has rendered ${infiniteRenderDetectionLimit} times in the same render.\nIt is very likely to have fallen into an infinite loop.\nThat is because you do not memoize the selector/equalityFn function param.\nPlease wrap them with useCallback or configure the deps array correctly.`\n        );\n      }\n      // We need to use setTimeout instead of useEffect here, because when infinite loop happens,\n      // the effect (fired in the next micro task) will execute before the rerender.\n      setTimeout(() => {\n        renderCount = 0;\n      });\n    }\n\n    const options = convertScopeShorthand(optionsOrScope);\n    selector ??= identity;\n    const equalityFn =\n      typeof equalityFnOrDeps === 'function' ? equalityFnOrDeps : undefined;\n    deps = (typeof equalityFnOrDeps === 'function'\n      ? deps\n      : equalityFnOrDeps) ?? [selector, equalityFn];\n\n    const [memoizedSelector, memoizedEqualityFn] = React.useMemo(\n      () => [selector, equalityFn],\n      deps\n    );\n\n    const selectorAtom = selectAtom(\n      atomConfig,\n      memoizedSelector,\n      memoizedEqualityFn\n    ) as Atom<any>;\n    return useAtomValue(selectorAtom, {\n      store,\n      delay: options.delay ?? delayRoot,\n    });\n  };\n\n  const getAtomWithStore: GetAtomFn = (atomConfig, store, _optionsOrScope) => {\n    return (store ?? getDefaultStore()).get(atomConfig);\n  };\n\n  const useSetAtomWithStore: SetAtomFn = (\n    atomConfig,\n    store,\n    _optionsOrScope\n  ) => {\n    return useSetAtom(atomConfig, { store });\n  };\n\n  const setAtomWithStore: UseSetAtomFn = (\n    atomConfig,\n    store,\n    _optionsOrScope\n  ) => {\n    return (...args) =>\n      (store ?? (getDefaultStore() as NonNullable<typeof store>)).set(\n        atomConfig,\n        ...args\n      );\n  };\n\n  const useAtomStateWithStore: UseAtomFn = (\n    atomConfig,\n    store,\n    optionsOrScope\n  ) => {\n    const { delay = delayRoot } = convertScopeShorthand(optionsOrScope);\n    return useAtom(atomConfig, { store, delay });\n  };\n\n  const subscribeAtomWithStore: SubscribeAtomFn = (\n    atomConfig,\n    store,\n    _optionsOrScope\n  ) => {\n    return (callback) => {\n      store ??= getDefaultStore();\n      const unsubscribe = store.sub(atomConfig, () => {\n        callback(store!.get(atomConfig));\n      });\n      return () => unsubscribe();\n    };\n  };\n\n  for (const key of Object.keys(atoms)) {\n    const atomConfig = atoms[key as keyof MyStoreAtoms];\n    const isWritable: boolean = atomIsWritable[key as keyof MyStoreAtoms];\n\n    (atomsOfUseValue as any)[key] = (\n      store: JotaiStore | undefined,\n      optionsOrScope: UseAtomOptionsOrScope = {},\n      selector?: (v: any, prevSelectorOutput?: any) => any,\n      equalityFnOrDeps?:\n        | ((prevSelectorOutput: any, selectorOutput: any) => boolean)\n        | unknown[],\n      deps?: unknown[]\n    ) =>\n      useAtomValueWithStore(\n        atomConfig,\n        store,\n        optionsOrScope,\n        selector,\n        equalityFnOrDeps,\n        deps\n      );\n\n    (atomsOfGet as any)[key] = (\n      store: JotaiStore | undefined,\n      optionsOrScope: UseAtomOptionsOrScope = {}\n    ) => getAtomWithStore(atomConfig, store, optionsOrScope);\n\n    (atomsOfSubscribe as any)[key] = (\n      store: JotaiStore | undefined,\n      optionsOrScope: UseAtomOptionsOrScope = {},\n      callback: (newValue: any) => void\n    ) => subscribeAtomWithStore(atomConfig, store, optionsOrScope)(callback);\n\n    if (isWritable) {\n      (atomsOfUseSet as any)[key] = (\n        store: JotaiStore | undefined,\n        optionsOrScope: UseAtomOptionsOrScope = {}\n      ) =>\n        useSetAtomWithStore(\n          atomConfig as WritableAtom<any, any, any>,\n          store,\n          optionsOrScope\n        );\n\n      (atomsOfSet as any)[key] = (\n        store: JotaiStore | undefined,\n        optionsOrScope: UseAtomOptionsOrScope = {},\n        ...args: any[]\n      ) =>\n        setAtomWithStore(\n          atomConfig as WritableAtom<any, any, any>,\n          store,\n          optionsOrScope\n        )(...args);\n\n      (atomsOfUseState as any)[key] = (\n        store: JotaiStore | undefined,\n        optionsOrScope: UseAtomOptionsOrScope = {}\n      ) =>\n        useAtomStateWithStore(\n          atomConfig as WritableAtom<any, any, any>,\n          store,\n          optionsOrScope\n        );\n    }\n  }\n\n  const Provider: React.FC<ProviderProps<MyStoreInitialValues>> =\n    createAtomProvider<MyStoreInitialValues, N>(\n      name,\n      writableAtomsWithoutExtend,\n      { effect }\n    );\n\n  const storeApi: StoreApi<T, E, N> = {\n    atom: atoms,\n    name,\n  };\n\n  const useStoreApi: UseStoreApi<T, E> = (options = {}) => {\n    const convertedOptions = useConvertScopeShorthand(options);\n    const store = useStore(convertedOptions);\n\n    return useMemo(\n      () => ({\n        // store.use<Key>Value()\n        ...(withStoreAndOptions(\n          atomsOfUseValue,\n          getUseValueIndex,\n          store,\n          convertedOptions\n        ) as UseKeyValueApis<MyStoreAtoms>),\n        // store.get<Key>()\n        ...(withStoreAndOptions(\n          atomsOfGet,\n          getGetIndex,\n          store,\n          convertedOptions\n        ) as GetKeyApis<MyStoreAtoms>),\n        // store.useSet<Key>()\n        ...(withStoreAndOptions(\n          atomsOfUseSet,\n          getUseSetIndex,\n          store,\n          convertedOptions\n        ) as UseSetKeyApis<MyStoreAtoms>),\n        // store.set<Key>(...args)\n        ...(withStoreAndOptions(\n          atomsOfSet,\n          getSetIndex,\n          store,\n          convertedOptions\n        ) as SetKeyApis<MyStoreAtoms>),\n        // store.use<Key>State()\n        ...(withStoreAndOptions(\n          atomsOfUseState,\n          getUseStateIndex,\n          store,\n          convertedOptions\n        ) as UseKeyStateApis<MyStoreAtoms>),\n        // store.subscribe<Key>(callback)\n        ...(withStoreAndOptions(\n          atomsOfSubscribe,\n          getSubscribeIndex,\n          store,\n          convertedOptions\n        ) as SubscribeKeyApis<MyStoreAtoms>),\n        // store.useValue('key')\n        useValue: withKeyAndStoreAndOptions(\n          atomsOfUseValue,\n          store,\n          convertedOptions\n        ) as UseParamKeyValueApi<MyStoreAtoms>,\n        // store.get('key')\n        get: withKeyAndStoreAndOptions(\n          atomsOfGet,\n          store,\n          convertedOptions\n        ) as GetParamKeyApi<MyStoreAtoms>,\n        // store.useSet('key')\n        useSet: withKeyAndStoreAndOptions(\n          atomsOfUseSet,\n          store,\n          convertedOptions\n        ) as UseSetParamKeyApi<MyStoreAtoms>,\n        // store.set('key', ...args)\n        set: withKeyAndStoreAndOptions(\n          atomsOfSet,\n          store,\n          convertedOptions\n        ) as SetParamKeyApi<MyStoreAtoms>,\n        // store.useState('key')\n        useState: withKeyAndStoreAndOptions(\n          atomsOfUseState,\n          store,\n          convertedOptions\n        ) as UseParamKeyStateApi<MyStoreAtoms>,\n        // store.subscribe('key', callback)\n        subscribe: withKeyAndStoreAndOptions(\n          atomsOfSubscribe,\n          store,\n          convertedOptions\n        ) as SubscribeParamKeyApi<MyStoreAtoms>,\n        // store.useAtomValue(atomConfig)\n        useAtomValue: ((atomConfig, selector, equalityFnOrDeps, deps) =>\n          // eslint-disable-next-line react-compiler/react-compiler\n          useAtomValueWithStore(\n            atomConfig,\n            store,\n            convertedOptions,\n            selector,\n            equalityFnOrDeps,\n            deps\n          )) as UseAtomParamValueApi,\n        // store.getAtom(atomConfig)\n        getAtom: (atomConfig) =>\n          getAtomWithStore(atomConfig, store, convertedOptions),\n        // store.useSetAtom(atomConfig)\n        useSetAtom: (atomConfig) =>\n          // eslint-disable-next-line react-compiler/react-compiler\n          useSetAtomWithStore(atomConfig, store, convertedOptions),\n        // store.setAtom(atomConfig, ...args)\n        setAtom: (atomConfig) =>\n          setAtomWithStore(atomConfig, store, convertedOptions),\n        // store.useAtomState(atomConfig)\n        useAtomState: (atomConfig) =>\n          // eslint-disable-next-line react-compiler/react-compiler\n          useAtomStateWithStore(atomConfig, store, convertedOptions),\n        // store.subscribeAtom(atomConfig, callback)\n        subscribeAtom: (atomConfig) =>\n          subscribeAtomWithStore(atomConfig, store, convertedOptions),\n        store,\n      }),\n      [store, convertedOptions]\n    );\n  };\n\n  const useNameState = <K extends keyof StoreAtoms<T, E>>(\n    key: K,\n    options?: UseAtomOptionsOrScope\n  ) => {\n    const store = useStore(options) ?? getDefaultStore();\n    return useAtomStateWithStore(atoms[key] as any, store, options);\n  };\n\n  const useNameValue = <\n    K extends keyof StoreAtoms<T, E>,\n    S = StoreAtoms<T, E>[K] extends Atom<infer V> ? V : never,\n  >(\n    key: K,\n    {\n      equalityFn,\n      selector,\n      ...options\n    }: UseValueOptions<\n      StoreAtoms<T, E>[K] extends Atom<infer V> ? V : never,\n      S\n    > = {},\n    deps?: unknown[]\n  ) => {\n    const store = useStore(options) ?? getDefaultStore();\n    return useAtomValueWithStore(\n      atoms[key],\n      store,\n      options,\n      selector as any,\n      equalityFn ?? deps,\n      equalityFn && deps\n    );\n  };\n\n  const useNameSet = <K extends keyof StoreAtoms<T, E>>(\n    key: K,\n    options?: UseAtomOptionsOrScope\n  ) => {\n    const store = useStore(options) ?? getDefaultStore();\n    return useSetAtomWithStore(atoms[key] as any, store, options);\n  };\n\n  return {\n    [providerIndex]: Provider,\n    [useStoreIndex]: useStoreApi,\n    [storeIndex]: storeApi,\n    [`use${capitalizeFirstLetter(name)}State`]: useNameState,\n    [`use${capitalizeFirstLetter(name)}Value`]: useNameValue,\n    [`use${capitalizeFirstLetter(name)}Set`]: useNameSet,\n    name,\n  } as any;\n};\n\nexport function useAtomStoreValue<T, E, K extends keyof StoreAtoms<T, E>>(\n  store: ReturnOfUseStoreApi<T, E>,\n  key: K\n): StoreAtoms<T, E>[K] extends Atom<infer V> ? V : never;\nexport function useAtomStoreValue<T, E, K extends keyof StoreAtoms<T, E>, S>(\n  store: ReturnOfUseStoreApi<T, E>,\n  key: K,\n  selector: StoreAtoms<T, E>[K] extends Atom<infer V>\n    ? (v: V, prevSelectorOutput?: S) => S\n    : never,\n  deps?: unknown[]\n): S;\nexport function useAtomStoreValue<T, E, K extends keyof StoreAtoms<T, E>, S>(\n  store: ReturnOfUseStoreApi<T, E>,\n  key: K,\n  selector: StoreAtoms<T, E>[K] extends Atom<infer V>\n    ? ((v: V, prevSelectorOutput?: S) => S) | undefined\n    : never,\n  equalityFn: (prevSelectorOutput: S, selectorOutput: S) => boolean,\n  deps?: unknown[]\n): S;\nexport function useAtomStoreValue<T, E, K extends keyof StoreAtoms<T, E>, S>(\n  store: ReturnOfUseStoreApi<T, E>,\n  key: K,\n  selector?: StoreAtoms<T, E>[K] extends Atom<infer V>\n    ? (v: V, prevSelectorOutput?: S) => S\n    : never,\n  equalityFnOrDeps?: any,\n  deps?: unknown[]\n) {\n  return store.useValue(key, selector, equalityFnOrDeps, deps);\n}\n\nexport function useAtomStoreSet<T, E, K extends keyof StoreAtoms<T, E>>(\n  store: ReturnOfUseStoreApi<T, E>,\n  key: K\n) {\n  return store.useSet(key);\n}\n\nexport function useAtomStoreState<T, E, K extends keyof StoreAtoms<T, E>>(\n  store: ReturnOfUseStoreApi<T, E>,\n  key: K\n) {\n  return store.useState(key);\n}\n\nexport function useStoreAtomValue<T, E, V>(\n  store: ReturnOfUseStoreApi<T, E>,\n  atom: Atom<V>\n): V;\nexport function useStoreAtomValue<T, E, V, S>(\n  store: ReturnOfUseStoreApi<T, E>,\n  atom: Atom<V>,\n  selector: (v: V, prevSelectorOutput?: S) => S,\n  deps?: unknown[]\n): S;\nexport function useStoreAtomValue<T, E, V, S>(\n  store: ReturnOfUseStoreApi<T, E>,\n  atom: Atom<V>,\n  selector: ((v: V, prevSelectorOutput?: S) => S) | undefined,\n  equalityFn: (prevSelectorOutput: S, selectorOutput: S) => boolean,\n  deps?: unknown[]\n): S;\nexport function useStoreAtomValue<T, E, V, S>(\n  store: ReturnOfUseStoreApi<T, E>,\n  atom: Atom<V>,\n  selector?: (v: V, prevSelectorOutput?: S) => S,\n  equalityFnOrDeps?: any,\n  deps?: unknown[]\n) {\n  return store.useAtomValue(atom, selector, equalityFnOrDeps, deps);\n}\n\nexport function useStoreSetAtom<T, E, V, A extends unknown[], R>(\n  store: ReturnOfUseStoreApi<T, E>,\n  atom: WritableAtom<V, A, R>\n) {\n  return store.useSetAtom(atom);\n}\n\nexport function useStoreAtomState<T, E, V, A extends unknown[], R>(\n  store: ReturnOfUseStoreApi<T, E>,\n  atom: WritableAtom<V, A, R>\n) {\n  return store.useAtomState(atom);\n}\n"],"mappings":"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","names":["React","atom","React","React","useSetAtom","React","useSetAtom","_a","atom"]}