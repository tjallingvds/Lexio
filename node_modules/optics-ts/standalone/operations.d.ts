import type { Optic, Try, Try2 } from './optic.js';
import type { InvalidModifyFn } from './errors.js';
import type { Apply, Apply2, HKT, HKT2 } from '../hkt.js';
import type { Eq, Simplify } from '../utils.js';
export declare function get<C extends 'Equivalence' | 'Iso' | 'Lens' | 'Getter', A extends HKT, S>(optic: Optic<C, A, any, any>, source: S): Apply<A, S>;
export declare function get<C extends 'Equivalence' | 'Iso' | 'Lens' | 'Getter', A extends HKT>(optic: Optic<C, A, any, any>): <S>(source: S) => Apply<A, S>;
type Preview<A extends HKT, S> = Apply<A, S> extends infer AU ? Try<AU, AU | undefined> : never;
export declare function preview<C extends 'Prism' | 'Traversal' | 'AffineFold' | 'Fold', A extends HKT, S>(optic: Optic<C, A, any, any>, source: S): Preview<A, S>;
export declare function preview<C extends 'Prism' | 'Traversal' | 'AffineFold' | 'Fold', A extends HKT>(optic: Optic<C, A, any, any>): <S>(source: S) => Preview<A, S>;
type Collect<A extends HKT, S> = Apply<A, S> extends infer AU ? Try<AU, AU[]> : never;
export declare function collect<C extends 'Prism' | 'Traversal' | 'Fold', A extends HKT, S>(optic: Optic<C, A, any, any>, source: S): Collect<A, S>;
export declare function collect<C extends 'Prism' | 'Traversal' | 'Fold', A extends HKT>(optic: Optic<C, A, any, any>): <S>(source: S) => Collect<A, S>;
type Modify<A extends HKT, B, S, T extends HKT2> = Apply<A, S> extends infer AU ? Apply2<T, S, B> extends infer TU ? Try2<AU, TU, Simplify<S, TU>> : never : never;
type ModifyPartial<A extends HKT, A2, B, S, T extends HKT2> = Apply<A, S> extends infer AU ? Apply2<T, S, B> extends infer TU ? Try2<AU, TU, Eq<AU, A2> extends true ? Simplify<S, TU> : InvalidModifyFn<AU, A2>> : never : never;
export declare function modify<C extends 'Equivalence' | 'Iso' | 'Lens' | 'Prism' | 'Traversal', A extends HKT, B, S, T extends HKT2>(optic: Optic<C, A, T, any>, f: (a: Apply<A, S>) => B, source: S): Modify<A, B, S, T>;
export declare function modify<C extends 'Equivalence' | 'Iso' | 'Lens' | 'Prism' | 'Traversal', A extends HKT, B, T extends HKT2, Ac>(optic: Optic<C, A, T, any>, f: (a: Ac) => B): <S>(source: S) => ModifyPartial<A, Ac, B, S, T>;
export declare function modify<C extends 'Equivalence' | 'Iso' | 'Lens' | 'Prism' | 'Traversal', A extends HKT, T extends HKT2>(optic: Optic<C, A, T, any>): <Ac, B>(f: (a: Ac) => B) => <S>(source: S) => ModifyPartial<A, Ac, B, S, T>;
type Set<B, S, T extends HKT2> = Apply2<T, S, B> extends infer TU ? Try<TU, Simplify<S, TU>> : never;
export declare function set<C extends 'Equivalence' | 'Iso' | 'Lens' | 'Prism' | 'Traversal' | 'Setter', T extends HKT2, B, S>(optic: Optic<C, any, T, any>, value: B, source: S): Set<B, S, T>;
export declare function set<C extends 'Equivalence' | 'Iso' | 'Lens' | 'Prism' | 'Traversal' | 'Setter', T extends HKT2, B>(optic: Optic<C, any, T, any>, value: B): <S>(source: S) => Set<B, S, T>;
export declare function set<C extends 'Equivalence' | 'Iso' | 'Lens' | 'Prism' | 'Traversal' | 'Setter', T extends HKT2>(optic: Optic<C, any, T, any>): <B>(value: B) => <S>(source: S) => Set<B, S, T>;
export declare function remove<C extends 'Prism' | 'Traversal', S>(optic: Optic<C, any, any, true>, source: S): S;
export declare function remove<C extends 'Prism' | 'Traversal'>(optic: Optic<C, any, any, true>): <S>(source: S) => S;
export {};
