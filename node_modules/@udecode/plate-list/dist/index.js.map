{"version":3,"sources":["../src/index.ts","../src/lib/BaseListPlugin.ts","../src/lib/transforms/moveListItems.ts","../src/lib/queries/isListNested.ts","../src/lib/transforms/moveListItemDown.ts","../src/lib/queries/getHighestEmptyList.ts","../src/lib/queries/getListTypes.ts","../src/lib/queries/getListItemEntry.ts","../src/lib/queries/getListRoot.ts","../src/lib/queries/getTodoListItemEntry.ts","../src/lib/BaseTodoListPlugin.ts","../src/lib/withTodoList.ts","../src/lib/queries/hasListChild.ts","../src/lib/queries/isAcrossListItems.ts","../src/lib/queries/isListRoot.ts","../src/lib/queries/someList.ts","../src/lib/transforms/moveListItemUp.ts","../src/lib/transforms/moveListItemsToList.ts","../src/lib/transforms/unwrapList.ts","../src/lib/transforms/removeFirstListItem.ts","../src/lib/transforms/indentListItems.ts","../src/lib/transforms/insertListItem.ts","../src/lib/transforms/insertTodoListItem.ts","../src/lib/transforms/moveListItemSublistItemsToListItemSublist.ts","../src/lib/transforms/moveListSiblingsAfterCursor.ts","../src/lib/transforms/removeListItem.ts","../src/lib/transforms/toggleList.ts","../src/lib/transforms/unindentListItems.ts","../src/lib/withDeleteForwardList.ts","../src/lib/withDeleteFragmentList.ts","../src/lib/withInsertFragmentList.ts","../src/lib/withNormalizeList.ts","../src/lib/normalizers/normalizeListItem.ts","../src/lib/normalizers/normalizeNestedList.ts"],"sourcesContent":["/**\n * @file Automatically generated by barrelsby.\n */\n\nexport * from './lib/index';\n","import {\n  type OmitFirst,\n  type PluginConfig,\n  bindFirst,\n  createSlatePlugin,\n  createTSlatePlugin,\n  HtmlPlugin,\n} from '@udecode/plate';\n\nimport {\n  toggleBulletedList,\n  toggleList,\n  toggleNumberedList,\n} from './transforms';\n\nexport type ListConfig = PluginConfig<\n  'list',\n  {\n    enableResetOnShiftTab?: boolean;\n    /** Valid children types for list items, in addition to p and ul types. */\n    validLiChildrenTypes?: string[];\n  },\n  {},\n  {\n    toggle: {\n      bulletedList: OmitFirst<typeof toggleBulletedList>;\n      list: OmitFirst<typeof toggleList>;\n      numberedList: OmitFirst<typeof toggleNumberedList>;\n    };\n  }\n>;\n\nexport const BaseBulletedListPlugin = createSlatePlugin({\n  key: 'ul',\n  node: { isElement: true },\n  parsers: {\n    html: {\n      deserializer: {\n        rules: [\n          {\n            validNodeName: 'UL',\n          },\n        ],\n      },\n    },\n  },\n});\n\nexport const BaseNumberedListPlugin = createSlatePlugin({\n  key: 'ol',\n  node: { isElement: true },\n  parsers: { html: { deserializer: { rules: [{ validNodeName: 'OL' }] } } },\n});\n\nexport const BaseListItemPlugin = createSlatePlugin({\n  key: 'li',\n  inject: {\n    plugins: {\n      [HtmlPlugin.key]: {\n        parser: {\n          preInsert: ({ editor, type }) => {\n            return editor.api.some({ match: { type } });\n          },\n        },\n      },\n    },\n  },\n  node: { isElement: true },\n  parsers: { html: { deserializer: { rules: [{ validNodeName: 'LI' }] } } },\n});\n\nexport const BaseListItemContentPlugin = createSlatePlugin({\n  key: 'lic',\n  node: { isElement: true },\n});\n\n/** Enables support for bulleted, numbered and to-do lists. */\nexport const BaseListPlugin = createTSlatePlugin<ListConfig>({\n  key: 'list',\n  // TODO react\n  // extendEditor: withList,\n  plugins: [\n    BaseBulletedListPlugin,\n    BaseNumberedListPlugin,\n    BaseListItemPlugin,\n    BaseListItemContentPlugin,\n  ],\n}).extendEditorTransforms(({ editor }) => ({\n  toggle: {\n    bulletedList: bindFirst(toggleBulletedList, editor),\n    list: bindFirst(toggleList, editor),\n    numberedList: bindFirst(toggleNumberedList, editor),\n  },\n}));\n","import {\n  type EditorNodesOptions,\n  type Path,\n  type PathRef,\n  type SlateEditor,\n  PathApi,\n} from '@udecode/plate';\n\nimport { BaseListItemContentPlugin } from '../BaseListPlugin';\nimport { isListNested } from '../queries/isListNested';\nimport { moveListItemDown } from './moveListItemDown';\nimport { moveListItemUp } from './moveListItemUp';\nimport { removeFirstListItem } from './removeFirstListItem';\n\nexport type MoveListItemsOptions = {\n  at?: EditorNodesOptions['at'];\n  enableResetOnShiftTab?: boolean;\n  increase?: boolean;\n};\n\nexport const moveListItems = (\n  editor: SlateEditor,\n  {\n    at = editor.selection ?? undefined,\n    enableResetOnShiftTab,\n    increase = true,\n  }: MoveListItemsOptions = {}\n) => {\n  const _nodes = editor.api.nodes({\n    at,\n    match: {\n      type: editor.getType(BaseListItemContentPlugin),\n    },\n  });\n\n  // Get the selected lic\n  const lics = Array.from(_nodes);\n\n  if (lics.length === 0) return;\n\n  const highestLicPaths: Path[] = [];\n  const highestLicPathRefs: PathRef[] = [];\n\n  // Filter out the nested lic, we just need to move the highest ones\n  lics.forEach((lic) => {\n    const licPath = lic[1];\n    const liPath = PathApi.parent(licPath);\n\n    const isAncestor = highestLicPaths.some((path) => {\n      const highestLiPath = PathApi.parent(path);\n\n      return PathApi.isAncestor(highestLiPath, liPath);\n    });\n\n    if (!isAncestor) {\n      highestLicPaths.push(licPath);\n      highestLicPathRefs.push(editor.api.pathRef(licPath));\n    }\n  });\n\n  const licPathRefsToMove = increase\n    ? highestLicPathRefs\n    : highestLicPathRefs.reverse();\n\n  return editor.tf.withoutNormalizing(() => {\n    let moved = false;\n\n    licPathRefsToMove.forEach((licPathRef) => {\n      const licPath = licPathRef.unref();\n\n      if (!licPath) return;\n\n      const listItem = editor.api.parent(licPath);\n\n      if (!listItem) return;\n\n      const parentList = editor.api.parent(listItem[1]);\n\n      if (!parentList) return;\n\n      let _moved: any;\n\n      if (increase) {\n        _moved = moveListItemDown(editor, {\n          list: parentList as any,\n          listItem: listItem as any,\n        });\n      } else if (isListNested(editor, parentList[1])) {\n        // un-indent a sub-list item\n        _moved = moveListItemUp(editor, {\n          list: parentList as any,\n          listItem: listItem as any,\n        });\n      } else if (enableResetOnShiftTab) {\n        // unindenting a top level list item, effectively breaking apart the list.\n        _moved = removeFirstListItem(editor, {\n          list: parentList as any,\n          listItem: listItem as any,\n        });\n      }\n\n      moved = _moved || moved;\n    });\n\n    return moved;\n  });\n};\n","import type { Path, SlateEditor, TElement } from '@udecode/plate';\n\nimport { BaseListItemPlugin } from '../BaseListPlugin';\n\n/** Is the list nested, i.e. its parent is a list item. */\nexport const isListNested = (editor: SlateEditor, listPath: Path) => {\n  const listParentNode = editor.api.parent<TElement>(listPath)?.[0];\n\n  return listParentNode?.type === editor.getType(BaseListItemPlugin);\n};\n","import {\n  type ElementEntry,\n  type SlateEditor,\n  type TElement,\n  match,\n  PathApi,\n} from '@udecode/plate';\n\nimport { getListTypes } from '../queries/index';\n\nexport interface MoveListItemDownOptions {\n  list: ElementEntry;\n  listItem: ElementEntry;\n}\n\nexport const moveListItemDown = (\n  editor: SlateEditor,\n  { list, listItem }: MoveListItemDownOptions\n) => {\n  let moved = false;\n\n  const [listNode] = list;\n  const [, listItemPath] = listItem;\n\n  const previousListItemPath = PathApi.previous(listItemPath);\n\n  if (!previousListItemPath) {\n    return;\n  }\n\n  // Previous sibling is the new parent\n  const previousSiblingItem = editor.api.node(previousListItemPath);\n\n  if (previousSiblingItem) {\n    const [previousNode, previousPath] = previousSiblingItem;\n\n    const sublist = (previousNode.children as TElement[]).find((n) =>\n      match(n, [], { type: getListTypes(editor) })\n    );\n    const newPath = previousPath.concat(\n      sublist ? [1, sublist.children.length] : [1]\n    );\n\n    editor.tf.withoutNormalizing(() => {\n      if (!sublist) {\n        // Create new sublist\n        editor.tf.wrapNodes<TElement>(\n          { children: [], type: listNode.type },\n          { at: listItemPath }\n        );\n      }\n\n      // Move the current item to the sublist\n      editor.tf.moveNodes({\n        at: listItemPath,\n        to: newPath,\n      });\n\n      moved = true;\n    });\n  }\n\n  return moved;\n};\n","import { type Path, type SlateEditor, PathApi } from '@udecode/plate';\n\nimport { BaseListItemPlugin } from '../BaseListPlugin';\nimport { getListTypes } from './getListTypes';\n\n/**\n * Find the highest end list that can be deleted. Its path should be different\n * to diffListPath. If the highest end list 2+ items, return liPath. Get the\n * parent list until:\n *\n * - The list has less than 2 items.\n * - Its path is not equals to diffListPath.\n */\nexport const getHighestEmptyList = (\n  editor: SlateEditor,\n  {\n    diffListPath,\n    liPath,\n  }: {\n    liPath: Path;\n    diffListPath?: Path;\n  }\n): Path | undefined => {\n  const list = editor.api.above({\n    at: liPath,\n    match: { type: getListTypes(editor) },\n  });\n\n  if (!list) return;\n\n  const [listNode, listPath] = list;\n\n  if (!diffListPath || !PathApi.equals(listPath, diffListPath)) {\n    if (listNode.children.length < 2) {\n      const liParent = editor.api.above({\n        at: listPath,\n        match: { type: editor.getType(BaseListItemPlugin) },\n      });\n\n      if (liParent) {\n        return (\n          getHighestEmptyList(editor, { diffListPath, liPath: liParent[1] }) ||\n          listPath\n        );\n      }\n    }\n\n    return liPath;\n  }\n};\n","import type { SlateEditor } from '@udecode/plate';\n\nimport {\n  BaseBulletedListPlugin,\n  BaseNumberedListPlugin,\n} from '../BaseListPlugin';\n\nexport const getListTypes = (editor: SlateEditor) => {\n  return [\n    editor.getType(BaseNumberedListPlugin),\n    editor.getType(BaseBulletedListPlugin),\n  ];\n};\n","import {\n  type ElementEntry,\n  type Path,\n  type SlateEditor,\n  type TElement,\n  type TLocation,\n  NodeApi,\n  RangeApi,\n} from '@udecode/plate';\n\nimport { BaseListItemPlugin } from '../BaseListPlugin';\n\n/**\n * Returns the nearest li and ul / ol wrapping node entries for a given path\n * (default = selection)\n */\nexport const getListItemEntry = (\n  editor: SlateEditor,\n  { at = editor.selection }: { at?: TLocation | null } = {}\n): { list: ElementEntry; listItem: ElementEntry } | undefined => {\n  const liType = editor.getType(BaseListItemPlugin);\n\n  let _at: Path;\n\n  if (RangeApi.isRange(at) && !RangeApi.isCollapsed(at)) {\n    _at = at.focus.path;\n  } else if (RangeApi.isRange(at)) {\n    _at = at.anchor.path;\n  } else {\n    _at = at as Path;\n  }\n  if (_at) {\n    const node = NodeApi.get<TElement>(editor, _at);\n\n    if (node) {\n      const listItem = editor.api.above<TElement>({\n        at: _at,\n        match: { type: liType },\n      });\n\n      if (listItem) {\n        const list = editor.api.parent<TElement>(listItem[1])!;\n\n        return { list, listItem };\n      }\n    }\n  }\n};\n","import type {\n  ElementEntry,\n  Path,\n  Point,\n  SlateEditor,\n  TElement,\n  TRange,\n} from '@udecode/plate';\n\nimport {\n  BaseBulletedListPlugin,\n  BaseNumberedListPlugin,\n} from '../BaseListPlugin';\n\n/** Searches upward for the root list element */\nexport const getListRoot = (\n  editor: SlateEditor,\n  at: Path | Point | TRange | null = editor.selection\n): ElementEntry | undefined => {\n  if (!at) return;\n\n  const parentList = editor.api.above<TElement>({\n    at,\n    match: {\n      type: [\n        editor.getType(BaseBulletedListPlugin),\n        editor.getType(BaseNumberedListPlugin),\n      ],\n    },\n  });\n\n  if (parentList) {\n    const [, parentListPath] = parentList;\n\n    return getListRoot(editor, parentListPath) ?? parentList;\n  }\n};\n","import {\n  type ElementEntry,\n  type Path,\n  type SlateEditor,\n  type TElement,\n  type TLocation,\n  NodeApi,\n  RangeApi,\n} from '@udecode/plate';\n\nimport { BaseTodoListPlugin } from '../BaseTodoListPlugin';\n\n/**\n * Returns the nearest li and ul / ol wrapping node entries for a given path\n * (default = selection)\n */\nexport const getTodoListItemEntry = (\n  editor: SlateEditor,\n  { at = editor.selection }: { at?: TLocation | null } = {}\n): { list: ElementEntry; listItem: ElementEntry } | undefined => {\n  const todoType = editor.getType(BaseTodoListPlugin);\n\n  let _at: Path;\n\n  if (RangeApi.isRange(at) && !RangeApi.isCollapsed(at)) {\n    _at = at.focus.path;\n  } else if (RangeApi.isRange(at)) {\n    _at = at.anchor.path;\n  } else {\n    _at = at as Path;\n  }\n  if (_at) {\n    const node = NodeApi.get<TElement>(editor, _at);\n\n    if (node) {\n      const listItem = editor.api.above<TElement>({\n        at: _at,\n        match: { type: todoType },\n      });\n\n      if (listItem) {\n        const list = editor.api.parent<TElement>(listItem[1])!;\n\n        return { list, listItem };\n      }\n    }\n  }\n};\n","import {\n  type PluginConfig,\n  type TElement,\n  createTSlatePlugin,\n} from '@udecode/plate';\n\nimport { withTodoList } from './withTodoList';\n\nexport type TodoListConfig = PluginConfig<\n  'action_item',\n  {\n    inheritCheckStateOnLineEndBreak?: boolean;\n    inheritCheckStateOnLineStartBreak?: boolean;\n  }\n>;\n\nexport interface TTodoListItemElement extends TElement {\n  checked?: boolean;\n}\n\nexport const BaseTodoListPlugin = createTSlatePlugin<TodoListConfig>({\n  key: 'action_item',\n  node: { isElement: true },\n}).overrideEditor(withTodoList);\n","import type { OverrideEditor } from '@udecode/plate';\n\nimport type { TodoListConfig } from './BaseTodoListPlugin';\n\nimport { getTodoListItemEntry } from './queries';\nimport { insertTodoListItem } from './transforms';\n\nexport const withTodoList: OverrideEditor<TodoListConfig> = ({\n  editor,\n  getOptions,\n  tf: { insertBreak },\n}) => ({\n  transforms: {\n    insertBreak() {\n      const insertBreakTodoList = () => {\n        if (!editor.selection) return;\n\n        const res = getTodoListItemEntry(editor);\n\n        // If selection is in a todo li\n        if (res) {\n          const inserted = insertTodoListItem(editor, getOptions());\n\n          if (inserted) return true;\n        }\n      };\n\n      if (insertBreakTodoList()) return;\n\n      insertBreak();\n    },\n  },\n});\n","import { type Ancestor, type SlateEditor, match } from '@udecode/plate';\n\nimport { getListTypes } from './getListTypes';\n\n/** Is there a list child in the node. */\nexport const hasListChild = (editor: SlateEditor, node: Ancestor) =>\n  node.children.some((n) => match(n, [], { type: getListTypes(editor) }));\n","import { type SlateEditor, type TRange, RangeApi } from '@udecode/plate';\n\nimport { BaseListItemPlugin } from '../BaseListPlugin';\n\n/** Is selection across blocks with list items */\nexport const isAcrossListItems = (\n  editor: SlateEditor,\n  at: TRange | null = editor.selection\n) => {\n  if (!at || RangeApi.isCollapsed(at)) {\n    return false;\n  }\n\n  const isAcrossBlocks = editor.api.isAt({ at, blocks: true });\n\n  if (!isAcrossBlocks) return false;\n\n  return editor.api.some({\n    at,\n    match: { type: editor.getType(BaseListItemPlugin) },\n  });\n};\n","import { type Descendant, type SlateEditor, ElementApi } from '@udecode/plate';\n\nimport { getListTypes } from './getListTypes';\n\nexport const isListRoot = (editor: SlateEditor, node: Descendant): boolean =>\n  ElementApi.isElement(node) && getListTypes(editor).includes(node.type);\n","import type { SlateEditor } from '@udecode/plate';\n\nimport { getListItemEntry } from '../index';\n\nexport const someList = (editor: SlateEditor, type: string) => {\n  return getListItemEntry(editor)?.list?.[0].type === type;\n};\n","import {\n  type ElementEntry,\n  type SlateEditor,\n  type TElement,\n  NodeApi,\n  PathApi,\n} from '@udecode/plate';\n\nimport { BaseListItemPlugin } from '../BaseListPlugin';\nimport { hasListChild } from '../queries/hasListChild';\nimport { moveListItemsToList } from './moveListItemsToList';\nimport { unwrapList } from './unwrapList';\n\nexport interface MoveListItemUpOptions {\n  list: ElementEntry;\n  listItem: ElementEntry;\n}\n\n/** Move a list item up. */\nexport const moveListItemUp = (\n  editor: SlateEditor,\n  { list, listItem }: MoveListItemUpOptions\n) => {\n  const move = () => {\n    const [listNode, listPath] = list;\n    const [liNode, liPath] = listItem;\n\n    const liParent = editor.api.above<TElement>({\n      at: listPath,\n      match: { type: editor.getType(BaseListItemPlugin) },\n    });\n\n    if (!liParent) {\n      let toListPath;\n\n      try {\n        toListPath = PathApi.next(listPath);\n      } catch (error) {\n        return;\n      }\n\n      const condA = hasListChild(editor, liNode);\n      const condB = !NodeApi.isLastChild(editor, liPath);\n\n      if (condA || condB) {\n        // Insert a new list next to `list`\n        editor.tf.insertNodes(\n          {\n            children: [],\n            type: listNode.type,\n          },\n          { at: toListPath }\n        );\n      }\n      if (condA) {\n        const toListNode = NodeApi.get<TElement>(editor, toListPath);\n\n        if (!toListNode) return;\n\n        // Move li sub-lis to the new list\n        moveListItemsToList(editor, {\n          fromListItem: listItem,\n          toList: [toListNode, toListPath],\n        });\n      }\n      // If there is siblings li, move them to the new list\n      if (condB) {\n        const toListNode = NodeApi.get<TElement>(editor, toListPath);\n\n        if (!toListNode) return;\n\n        // Move next lis to the new list\n        moveListItemsToList(editor, {\n          deleteFromList: false,\n          fromList: list,\n          fromStartIndex: liPath.at(-1)! + 1,\n          toList: [toListNode, toListPath],\n        });\n      }\n\n      // Finally, unwrap the list\n      unwrapList(editor, { at: liPath.concat(0) });\n\n      return true;\n    }\n\n    const [, liParentPath] = liParent;\n\n    const toListPath = liPath.concat([1]);\n\n    // If li has next siblings, we need to move them.\n    if (!NodeApi.isLastChild(editor, liPath)) {\n      // If li has no sublist, insert one.\n      if (!hasListChild(editor, liNode)) {\n        editor.tf.insertNodes(\n          {\n            children: [],\n            type: listNode.type,\n          },\n          { at: toListPath }\n        );\n      }\n\n      const toListNode = NodeApi.get<TElement>(editor, toListPath);\n\n      if (!toListNode) return;\n\n      // Move next siblings to li sublist.\n      moveListItemsToList(editor, {\n        deleteFromList: false,\n        fromListItem: liParent,\n        fromStartIndex: liPath.at(-1)! + 1,\n        toList: [toListNode, toListPath],\n      });\n    }\n\n    const movedUpLiPath = PathApi.next(liParentPath);\n\n    // Move li one level up: next to the li parent.\n    editor.tf.moveNodes({\n      at: liPath,\n      to: movedUpLiPath,\n    });\n\n    return true;\n  };\n\n  let moved: boolean | undefined = false;\n\n  editor.tf.withoutNormalizing(() => {\n    moved = move();\n  });\n\n  return moved;\n};\n","import {\n  type ElementEntry,\n  type Path,\n  type SlateEditor,\n  NodeApi,\n  PathApi,\n} from '@udecode/plate';\n\nimport { getListTypes } from '../queries/getListTypes';\n\nexport interface MergeListItemIntoListOptions {\n  /**\n   * Delete `fromListItem` sublist if true.\n   *\n   * @default true\n   */\n  deleteFromList?: boolean;\n\n  /** List items of the list will be moved. */\n  fromList?: ElementEntry;\n\n  /** List items of the sublist of this node will be moved. */\n  fromListItem?: ElementEntry;\n\n  fromStartIndex?: number;\n\n  to?: Path;\n\n  /** List items will be moved in this list. */\n  toList?: ElementEntry;\n\n  /** List position where to move the list items. */\n  toListIndex?: number | null;\n}\n\n/**\n * Move the list items of the sublist of `fromListItem` to `toList` (if\n * `fromListItem` is defined). Move the list items of `fromList` to `toList` (if\n * `fromList` is defined).\n */\nexport const moveListItemsToList = (\n  editor: SlateEditor,\n  {\n    deleteFromList = true,\n    fromList,\n    fromListItem,\n    fromStartIndex,\n    to: _to,\n    toList,\n    toListIndex = null,\n  }: MergeListItemIntoListOptions\n) => {\n  let fromListPath: Path | undefined;\n  let moved: boolean | void = false;\n\n  editor.tf.withoutNormalizing(() => {\n    if (fromListItem) {\n      const fromListItemSublist = editor.api.descendant({\n        at: fromListItem[1],\n        match: {\n          type: getListTypes(editor),\n        },\n      });\n\n      if (!fromListItemSublist) return;\n\n      fromListPath = fromListItemSublist?.[1];\n    } else if (fromList) {\n      fromListPath = fromList[1];\n    } else {\n      return;\n    }\n\n    let to: Path | null = null;\n\n    if (_to) to = _to;\n    if (toList) {\n      if (toListIndex === null) {\n        const lastChildPath = NodeApi.lastChild(editor, toList[1])?.[1];\n        to = lastChildPath\n          ? PathApi.next(lastChildPath)\n          : toList[1].concat([0]);\n      } else {\n        to = toList[1].concat([toListIndex]);\n      }\n    }\n    if (!to) return;\n\n    moved = editor.tf.moveNodes({\n      at: fromListPath,\n      children: true,\n      fromIndex: fromStartIndex,\n      to,\n    });\n\n    // Remove the empty list\n    if (deleteFromList) {\n      editor.tf.delete({ at: fromListPath });\n    }\n  });\n\n  return moved;\n};\n","import {\n  type Path,\n  type SlateEditor,\n  ElementApi,\n  NodeApi,\n} from '@udecode/plate';\n\nimport {\n  BaseBulletedListPlugin,\n  BaseListItemPlugin,\n  BaseNumberedListPlugin,\n} from '../BaseListPlugin';\nimport { getListTypes } from '../queries/index';\n\nexport const unwrapList = (editor: SlateEditor, { at }: { at?: Path } = {}) => {\n  const ancestorListTypeCheck = () => {\n    if (editor.api.above({ at, match: { type: getListTypes(editor) } })) {\n      return true;\n    }\n    // The selection's common node might be a list type\n    if (!at && editor.selection) {\n      const commonNode = NodeApi.common(\n        editor,\n        editor.selection.anchor.path,\n        editor.selection.focus.path\n      )!;\n\n      if (\n        ElementApi.isElement(commonNode[0]) &&\n        getListTypes(editor).includes(commonNode[0].type)\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  editor.tf.withoutNormalizing(() => {\n    do {\n      // const licEntry = editor.api.block({\n      //   at,\n      //   match: { type: editor.getType(BaseListItemContentPlugin) },\n      // });\n\n      // Allow other LIC types\n      // if (licEntry) {\n      //   editor.tf.setNodes(\n      //     { type: editor.getType(BaseParagraphPlugin) },\n      //     { at }\n      //   );\n      // }\n\n      editor.tf.unwrapNodes({\n        at,\n        match: { type: editor.getType(BaseListItemPlugin) },\n        split: true,\n      });\n\n      editor.tf.unwrapNodes({\n        at,\n        match: {\n          type: [\n            editor.getType(BaseBulletedListPlugin),\n            editor.getType(BaseNumberedListPlugin),\n          ],\n        },\n        split: true,\n      });\n    } while (ancestorListTypeCheck());\n  });\n};\n","import type { ElementEntry, SlateEditor } from '@udecode/plate';\n\nimport { isListNested } from '../queries/isListNested';\nimport { moveListItemUp } from './moveListItemUp';\n\n/** If list is not nested and if li is not the first child, move li up. */\nexport const removeFirstListItem = (\n  editor: SlateEditor,\n  {\n    list,\n    listItem,\n  }: {\n    list: ElementEntry;\n    listItem: ElementEntry;\n  }\n) => {\n  const [, listPath] = list;\n\n  if (!isListNested(editor, listPath)) {\n    moveListItemUp(editor, { list, listItem });\n\n    return true;\n  }\n\n  return false;\n};\n","import type { SlateEditor } from '@udecode/plate';\n\nimport { moveListItems } from './moveListItems';\n\nexport const indentListItems = (editor: SlateEditor) => {\n  moveListItems(editor, { increase: true });\n};\n","import { type SlateEditor, type TElement, PathApi } from '@udecode/plate';\n\nimport {\n  BaseListItemContentPlugin,\n  BaseListItemPlugin,\n} from '../BaseListPlugin';\n\n/** Insert list item if selection in li>p. TODO: test */\nexport const insertListItem = (editor: SlateEditor): boolean => {\n  const liType = editor.getType(BaseListItemPlugin);\n  const licType = editor.getType(BaseListItemContentPlugin);\n\n  if (!editor.selection) {\n    return false;\n  }\n\n  const licEntry = editor.api.above({ match: { type: licType } });\n\n  if (!licEntry) return false;\n\n  const [, paragraphPath] = licEntry;\n\n  const listItemEntry = editor.api.parent(paragraphPath);\n\n  if (!listItemEntry) return false;\n\n  const [listItemNode, listItemPath] = listItemEntry;\n\n  if (listItemNode.type !== liType) return false;\n\n  let success = false;\n\n  editor.tf.withoutNormalizing(() => {\n    if (!editor.api.isCollapsed()) {\n      editor.tf.delete();\n    }\n\n    const isStart = editor.api.isStart(editor.selection!.focus, paragraphPath);\n    const isEnd = editor.api.isEmpty(editor.selection, { after: true });\n\n    const nextParagraphPath = PathApi.next(paragraphPath);\n    const nextListItemPath = PathApi.next(listItemPath);\n\n    /** If start, insert a list item before */\n    if (isStart) {\n      editor.tf.insertNodes(\n        {\n          children: [{ children: [{ text: '' }], type: licType }],\n          type: liType,\n        },\n        { at: listItemPath }\n      );\n\n      success = true;\n\n      return;\n    }\n    /**\n     * If not end, split nodes, wrap a list item on the new paragraph and move\n     * it to the next list item\n     */\n    if (isEnd) {\n      /** If end, insert a list item after and select it */\n      const marks = editor.api.marks() || {};\n      editor.tf.insertNodes(\n        {\n          children: [{ children: [{ text: '', ...marks }], type: licType }],\n          type: liType,\n        },\n        { at: nextListItemPath }\n      );\n      editor.tf.select(nextListItemPath);\n    } else {\n      editor.tf.withoutNormalizing(() => {\n        editor.tf.splitNodes();\n        editor.tf.wrapNodes<TElement>(\n          {\n            children: [],\n            type: liType,\n          },\n          { at: nextParagraphPath }\n        );\n        editor.tf.moveNodes({\n          at: nextParagraphPath,\n          to: nextListItemPath,\n        });\n        editor.tf.select(nextListItemPath);\n        editor.tf.collapse({\n          edge: 'start',\n        });\n      });\n    }\n    /** If there is a list in the list item, move it to the next list item */\n    if (listItemNode.children.length > 1) {\n      editor.tf.moveNodes({\n        at: nextParagraphPath,\n        to: nextListItemPath.concat(1),\n      });\n    }\n\n    success = true;\n  });\n\n  return success;\n};\n","import { type SlateEditor, PathApi } from '@udecode/plate';\n\nimport { type TodoListConfig, BaseTodoListPlugin } from '../BaseTodoListPlugin';\n\n/** Insert todo list item if selection in li>p. TODO: test */\nexport const insertTodoListItem = (\n  editor: SlateEditor,\n  {\n    inheritCheckStateOnLineEndBreak = false,\n    inheritCheckStateOnLineStartBreak = false,\n  }: TodoListConfig['options']\n): boolean => {\n  const todoType = editor.getType(BaseTodoListPlugin);\n\n  if (!editor.selection) {\n    return false;\n  }\n\n  const todoEntry = editor.api.above({ match: { type: todoType } });\n\n  if (!todoEntry) return false;\n\n  const [todo, paragraphPath] = todoEntry;\n\n  let success = false;\n\n  editor.tf.withoutNormalizing(() => {\n    if (!editor.api.isCollapsed()) {\n      editor.tf.delete();\n    }\n\n    const isStart = editor.api.isStart(editor.selection!.focus, paragraphPath);\n    const isEnd = editor.api.isEmpty(editor.selection, { after: true });\n\n    const nextParagraphPath = PathApi.next(paragraphPath);\n\n    /** If start, insert a list item before */\n    if (isStart) {\n      editor.tf.insertNodes(\n        {\n          checked: inheritCheckStateOnLineStartBreak ? todo.checked : false,\n          children: [{ text: '' }],\n          type: todoType,\n        },\n        { at: paragraphPath }\n      );\n\n      success = true;\n\n      return;\n    }\n    /** If not end, split the nodes */\n    if (isEnd) {\n      /** If end, insert a list item after and select it */\n      const marks = editor.api.marks() || {};\n      editor.tf.insertNodes(\n        {\n          checked: inheritCheckStateOnLineEndBreak ? todo.checked : false,\n          children: [{ text: '', ...marks }],\n          type: todoType,\n        },\n        { at: nextParagraphPath }\n      );\n      editor.tf.select(nextParagraphPath);\n    } else {\n      editor.tf.withoutNormalizing(() => {\n        editor.tf.splitNodes();\n      });\n    }\n\n    success = true;\n  });\n\n  return success;\n};\n","import {\n  type ElementEntry,\n  type Path,\n  type SlateEditor,\n  type TElement,\n  NodeApi,\n  PathApi,\n} from '@udecode/plate';\n\nimport { getListTypes } from '../queries/getListTypes';\n\nexport interface MoveListItemSublistItemsToListItemSublistOptions {\n  /** The list item to merge. */\n  fromListItem: ElementEntry;\n\n  /** The list item where to merge. */\n  toListItem: ElementEntry;\n\n  /** Move to the start of the list instead of the end. */\n  start?: boolean;\n}\n\n/**\n * Move fromListItem sublist list items to the end of `toListItem` sublist. If\n * there is no `toListItem` sublist, insert one.\n */\nexport const moveListItemSublistItemsToListItemSublist = (\n  editor: SlateEditor,\n  {\n    fromListItem,\n    start,\n    toListItem,\n  }: MoveListItemSublistItemsToListItemSublistOptions\n) => {\n  const [, fromListItemPath] = fromListItem;\n  const [, toListItemPath] = toListItem;\n  let moved: boolean | void = false;\n\n  editor.tf.withoutNormalizing(() => {\n    const fromListItemSublist = editor.api.descendant<TElement>({\n      at: fromListItemPath,\n      match: {\n        type: getListTypes(editor),\n      },\n    });\n\n    if (!fromListItemSublist) return;\n\n    const [, fromListItemSublistPath] = fromListItemSublist;\n\n    const toListItemSublist = editor.api.descendant<TElement>({\n      at: toListItemPath,\n      match: {\n        type: getListTypes(editor),\n      },\n    });\n\n    let to: Path;\n\n    if (!toListItemSublist) {\n      const fromList = editor.api.parent(fromListItemPath);\n\n      if (!fromList) return;\n\n      const [fromListNode] = fromList;\n\n      const fromListType = fromListNode.type;\n\n      const toListItemSublistPath = toListItemPath.concat([1]);\n\n      editor.tf.insertNodes(\n        { children: [], type: fromListType as string },\n        { at: toListItemSublistPath }\n      );\n\n      to = toListItemSublistPath.concat([0]);\n    } else if (start) {\n      const [, toListItemSublistPath] = toListItemSublist;\n      to = toListItemSublistPath.concat([0]);\n    } else {\n      to = PathApi.next(NodeApi.lastChild(editor, toListItemSublist[1])![1]);\n    }\n\n    moved = editor.tf.moveNodes({\n      at: fromListItemSublistPath,\n      children: true,\n      to,\n    });\n\n    // Remove the empty list\n    editor.tf.delete({ at: fromListItemSublistPath });\n  });\n\n  return moved;\n};\n","import {\n  type ElementEntry,\n  type Path,\n  type SlateEditor,\n  type TElement,\n  match,\n  NodeApi,\n  PathApi,\n} from '@udecode/plate';\n\nimport { getListTypes } from '../queries/getListTypes';\n\nexport const moveListSiblingsAfterCursor = (\n  editor: SlateEditor,\n  {\n    at,\n    to,\n  }: {\n    at: Path;\n    to: Path;\n  }\n) => {\n  const offset = at.at(-1)!;\n  at = PathApi.parent(at);\n  const listNode = NodeApi.get<TElement>(editor, at)!;\n  const listEntry: ElementEntry = [listNode, at];\n\n  if (\n    !match(listNode, [], { type: getListTypes(editor) }) ||\n    PathApi.isParent(at, to) // avoid moving nodes within its own list\n  ) {\n    return false;\n  }\n\n  return editor.tf.moveNodes({\n    at: listEntry[1],\n    children: true,\n    fromIndex: offset + 1,\n    to,\n  });\n};\n","import {\n  type ElementEntry,\n  type SlateEditor,\n  type TElement,\n  deleteMerge,\n  PathApi,\n} from '@udecode/plate';\n\nimport {\n  BaseListItemContentPlugin,\n  BaseListItemPlugin,\n} from '../BaseListPlugin';\nimport { hasListChild } from '../queries/hasListChild';\nimport { moveListItemsToList } from './moveListItemsToList';\nimport { moveListItemSublistItemsToListItemSublist } from './moveListItemSublistItemsToListItemSublist';\n\nexport interface RemoveListItemOptions {\n  list: ElementEntry;\n  listItem: ElementEntry;\n  reverse?: boolean;\n}\n\n/** Remove list item and move its sublist to list if any. */\nexport const removeListItem = (\n  editor: SlateEditor,\n  { list, listItem, reverse = true }: RemoveListItemOptions\n) => {\n  const [liNode, liPath] = listItem;\n\n  // Stop if the list item has no sublist\n  if (editor.api.isExpanded() || !hasListChild(editor, liNode)) {\n    return false;\n  }\n\n  const previousLiPath = PathApi.previous(liPath);\n\n  let success = false;\n\n  editor.tf.withoutNormalizing(() => {\n    /**\n     * If there is a previous li, we need to move sub-lis to the previous li. As\n     * we need to delete first, we will:\n     *\n     * 1. Insert a temporary li: tempLi\n     * 2. Move sub-lis to tempLi\n     * 3. Delete\n     * 4. Move sub-lis from tempLi to the previous li.\n     * 5. Remove tempLi\n     */\n    if (previousLiPath) {\n      const previousLi = editor.api.node<TElement>(previousLiPath);\n\n      if (!previousLi) return;\n\n      // 1\n      let tempLiPath = PathApi.next(liPath);\n      editor.tf.insertNodes(\n        {\n          children: [\n            {\n              children: [{ text: '' }],\n              type: editor.getType(BaseListItemContentPlugin),\n            },\n          ],\n          type: editor.getType(BaseListItemPlugin),\n        },\n        { at: tempLiPath }\n      );\n\n      const tempLi = editor.api.node<TElement>(tempLiPath);\n\n      if (!tempLi) return;\n\n      const tempLiPathRef = editor.api.pathRef(tempLi[1]);\n\n      // 2\n      moveListItemSublistItemsToListItemSublist(editor, {\n        fromListItem: listItem,\n        toListItem: tempLi,\n      });\n\n      // 3\n      deleteMerge(editor, {\n        reverse,\n      });\n\n      tempLiPath = tempLiPathRef.unref()!;\n\n      // 4\n      moveListItemSublistItemsToListItemSublist(editor, {\n        fromListItem: [tempLi[0], tempLiPath],\n        toListItem: previousLi,\n      });\n\n      // 5\n      editor.tf.removeNodes({ at: tempLiPath });\n\n      success = true;\n\n      return;\n    }\n\n    // If it's the first li, move the sublist to the parent list\n    moveListItemsToList(editor, {\n      fromListItem: listItem,\n      toList: list,\n      toListIndex: 1,\n    });\n  });\n\n  return success;\n};\n","import {\n  type SlateEditor,\n  type TElement,\n  BaseParagraphPlugin,\n  ElementApi,\n  NodeApi,\n  RangeApi,\n} from '@udecode/plate';\n\nimport {\n  BaseBulletedListPlugin,\n  BaseListItemContentPlugin,\n  BaseListItemPlugin,\n  BaseListPlugin,\n  BaseNumberedListPlugin,\n} from '../BaseListPlugin';\nimport { getListItemEntry, getListTypes } from '../queries/index';\nimport { unwrapList } from './unwrapList';\n\nexport const toggleList = (editor: SlateEditor, { type }: { type: string }) =>\n  editor.tf.withoutNormalizing(() => {\n    if (!editor.selection) {\n      return;\n    }\n\n    const { validLiChildrenTypes } = editor.getOptions(BaseListPlugin);\n\n    if (editor.api.isCollapsed() || !editor.api.isAt({ blocks: true })) {\n      // selection is collapsed\n      const res = getListItemEntry(editor);\n\n      if (res) {\n        const { list } = res;\n\n        if (list[0].type === type) {\n          unwrapList(editor);\n        } else {\n          editor.tf.setNodes(\n            { type },\n            {\n              at: editor.selection,\n              mode: 'lowest',\n              match: (n) =>\n                ElementApi.isElement(n) &&\n                getListTypes(editor).includes(n.type),\n            }\n          );\n        }\n      } else {\n        const list = { children: [], type };\n        editor.tf.wrapNodes<TElement>(list);\n\n        const _nodes = editor.api.nodes({\n          match: { type: editor.getType(BaseParagraphPlugin) },\n        });\n        const nodes = Array.from(_nodes);\n\n        const blockAbove = editor.api.block({\n          match: { type: validLiChildrenTypes },\n        });\n\n        if (!blockAbove) {\n          editor.tf.setNodes({\n            type: editor.getType(BaseListItemContentPlugin),\n          });\n        }\n\n        const listItem = {\n          children: [],\n          type: editor.getType(BaseListItemPlugin),\n        };\n\n        for (const [, path] of nodes) {\n          editor.tf.wrapNodes<TElement>(listItem, {\n            at: path,\n          });\n        }\n      }\n    } else {\n      // selection is a range\n\n      const [startPoint, endPoint] = RangeApi.edges(editor.selection!);\n      const commonEntry = NodeApi.common<TElement>(\n        editor,\n        startPoint.path,\n        endPoint.path\n      )!;\n\n      if (\n        getListTypes(editor).includes(commonEntry[0].type) ||\n        (commonEntry[0] as TElement).type === editor.getType(BaseListItemPlugin)\n      ) {\n        if ((commonEntry[0] as TElement).type === type) {\n          unwrapList(editor);\n        } else {\n          const startList = editor.api.node({\n            at: RangeApi.start(editor.selection),\n            match: { type: getListTypes(editor) },\n            mode: 'lowest',\n          });\n          const endList = editor.api.node({\n            at: RangeApi.end(editor.selection),\n            match: { type: getListTypes(editor) },\n            mode: 'lowest',\n          });\n          const rangeLength = Math.min(\n            startList![1].length,\n            endList![1].length\n          );\n\n          editor.tf.setNodes(\n            { type },\n            {\n              at: editor.selection,\n              mode: 'all',\n              match: (n, path) =>\n                ElementApi.isElement(n) &&\n                getListTypes(editor).includes(n.type) &&\n                path.length >= rangeLength,\n            }\n          );\n        }\n      } else {\n        const rootPathLength = commonEntry[1].length;\n        const _nodes = editor.api.nodes<TElement>({\n          mode: 'all',\n        });\n        const nodes = Array.from(_nodes).filter(\n          ([, path]) => path.length === rootPathLength + 1\n        );\n\n        nodes.forEach((n) => {\n          if (getListTypes(editor).includes(n[0].type)) {\n            editor.tf.setNodes(\n              { type },\n              {\n                at: n[1],\n                mode: 'all',\n                match: (_n) =>\n                  ElementApi.isElement(_n) &&\n                  getListTypes(editor).includes(_n.type),\n              }\n            );\n          } else {\n            if (!validLiChildrenTypes?.includes(n[0].type)) {\n              editor.tf.setNodes(\n                { type: editor.getType(BaseListItemContentPlugin) },\n                { at: n[1] }\n              );\n            }\n\n            const listItem = {\n              children: [],\n              type: editor.getType(BaseListItemPlugin),\n            };\n            editor.tf.wrapNodes<TElement>(listItem, {\n              at: n[1],\n            });\n\n            const list = { children: [], type };\n            editor.tf.wrapNodes<TElement>(list, { at: n[1] });\n          }\n        });\n      }\n    }\n  });\n\nexport const toggleBulletedList = (editor: SlateEditor) =>\n  toggleList(editor, { type: editor.getType(BaseBulletedListPlugin) });\n\nexport const toggleNumberedList = (editor: SlateEditor) =>\n  toggleList(editor, { type: editor.getType(BaseNumberedListPlugin) });\n","import type { SlateEditor } from '@udecode/plate';\n\nimport { type MoveListItemsOptions, moveListItems } from './moveListItems';\n\nexport type UnindentListItemsOptions = Omit<MoveListItemsOptions, 'increase'>;\n\nexport const unindentListItems = (\n  editor: SlateEditor,\n  options: UnindentListItemsOptions = {}\n) => moveListItems(editor, { ...options, increase: false });\n","import {\n  type EditorTransforms,\n  type ElementEntry,\n  type OverrideEditor,\n  type SlateEditor,\n  type TElement,\n  NodeApi,\n  PathApi,\n} from '@udecode/plate';\n\nimport type { ListConfig } from './BaseListPlugin';\n\nimport {\n  BaseListItemContentPlugin,\n  BaseListItemPlugin,\n} from './BaseListPlugin';\nimport {\n  getListItemEntry,\n  getListRoot,\n  hasListChild,\n  isAcrossListItems,\n} from './queries/index';\nimport {\n  moveListItemsToList,\n  moveListItemUp,\n  removeFirstListItem,\n  removeListItem,\n} from './transforms/index';\n\nconst selectionIsNotInAListHandler = (editor: SlateEditor): boolean => {\n  const pointAfterSelection = editor.api.after(editor.selection!.focus);\n\n  if (pointAfterSelection) {\n    // there is a block after it\n    const nextSiblingListRes = getListItemEntry(editor, {\n      at: pointAfterSelection,\n    });\n\n    if (nextSiblingListRes) {\n      // the next block is a list\n      const { listItem } = nextSiblingListRes;\n      const parentBlockEntity = editor.api.block({\n        at: editor.selection!.anchor,\n      });\n\n      if (!editor.api.string(parentBlockEntity![1])) {\n        // the selected block is empty\n        editor.tf.removeNodes();\n\n        return true;\n      }\n      if (hasListChild(editor, listItem[0])) {\n        // the next block has children, so we have to move the first item up\n        const sublistRes = getListItemEntry(editor, {\n          at: [...listItem[1], 1, 0, 0],\n        });\n\n        moveListItemUp(editor, sublistRes!);\n      }\n    }\n  }\n\n  return false;\n};\n\nconst selectionIsInAListHandler = (\n  editor: SlateEditor,\n  res: { list: ElementEntry; listItem: ElementEntry },\n  defaultDelete: EditorTransforms['deleteBackward'],\n  unit: 'block' | 'character' | 'line' | 'word' = 'character'\n): boolean => {\n  const { listItem } = res;\n\n  // if it has no children\n  if (!hasListChild(editor, listItem[0])) {\n    const liType = editor.getType(BaseListItemPlugin);\n    const _nodes = editor.api.nodes({\n      at: listItem[1],\n      mode: 'lowest',\n      match: (node, path) => {\n        if (path.length === 0) {\n          return false;\n        }\n\n        const isNodeLi = (node as TElement).type === liType;\n        const isSiblingOfNodeLi =\n          NodeApi.get<TElement>(editor, PathApi.next(path))?.type === liType;\n\n        return isNodeLi && isSiblingOfNodeLi;\n      },\n    });\n    const liWithSiblings = Array.from(_nodes, (entry) => entry[1])[0];\n\n    if (!liWithSiblings) {\n      // there are no more list item in the list\n      const pointAfterListItem = editor.api.after(listItem[1]);\n\n      if (pointAfterListItem) {\n        // there is a block after it\n        const nextSiblingListRes = getListItemEntry(editor, {\n          at: pointAfterListItem,\n        });\n\n        if (nextSiblingListRes) {\n          // it is a list so we merge the lists\n          const listRoot = getListRoot(editor, listItem[1]);\n\n          moveListItemsToList(editor, {\n            deleteFromList: true,\n            fromList: nextSiblingListRes.list,\n            toList: listRoot,\n          });\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    const siblingListItem = editor.api.node<TElement>(\n      PathApi.next(liWithSiblings)\n    );\n\n    if (!siblingListItem) return false;\n\n    const siblingList = editor.api.parent<TElement>(siblingListItem[1]);\n\n    if (\n      siblingList &&\n      removeListItem(editor, {\n        list: siblingList,\n        listItem: siblingListItem,\n        reverse: false,\n      })\n    ) {\n      return true;\n    }\n\n    const pointAfterListItem = editor.api.after(editor.selection!.focus);\n\n    if (\n      !pointAfterListItem ||\n      !isAcrossListItems(editor, {\n        anchor: editor.selection!.anchor,\n        focus: pointAfterListItem,\n      })\n    ) {\n      return false;\n    }\n\n    // get closest lic ancestor of next selectable\n    const licType = editor.getType(BaseListItemContentPlugin);\n    const _licNodes = editor.api.nodes<TElement>({\n      at: pointAfterListItem.path,\n      mode: 'lowest',\n      match: (node) => node.type === licType,\n    });\n    const nextSelectableLic = [..._licNodes][0];\n\n    // let slate handle single child cases\n    if (nextSelectableLic[0].children.length < 2) return false;\n\n    // manually run default delete\n    defaultDelete(unit);\n\n    const leftoverListItem = editor.api.node<TElement>(\n      PathApi.parent(nextSelectableLic[1])\n    )!;\n\n    if (leftoverListItem && leftoverListItem[0].children.length === 0) {\n      // remove the leftover empty list item\n      editor.tf.removeNodes({ at: leftoverListItem[1] });\n    }\n\n    return true;\n  }\n\n  // if it has children\n  const nestedList = editor.api.node<TElement>(\n    PathApi.next([...listItem[1], 0])\n  );\n\n  if (!nestedList) return false;\n\n  const nestedListItem = Array.from(\n    NodeApi.children<TElement>(editor, nestedList[1])\n  )[0];\n\n  if (\n    removeFirstListItem(editor, {\n      list: nestedList,\n      listItem: nestedListItem,\n    })\n  ) {\n    return true;\n  }\n  if (\n    removeListItem(editor, {\n      list: nestedList,\n      listItem: nestedListItem,\n    })\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const withDeleteForwardList: OverrideEditor<ListConfig> = ({\n  editor,\n  tf: { deleteForward },\n}) => ({\n  transforms: {\n    deleteForward(unit) {\n      const deleteForwardList = () => {\n        let skipDefaultDelete = false;\n\n        if (!editor?.selection) {\n          return skipDefaultDelete;\n        }\n        if (!editor.api.isAt({ end: true })) {\n          return skipDefaultDelete;\n        }\n\n        editor.tf.withoutNormalizing(() => {\n          const res = getListItemEntry(editor, {});\n\n          if (!res) {\n            skipDefaultDelete = selectionIsNotInAListHandler(editor);\n\n            return;\n          }\n\n          skipDefaultDelete = selectionIsInAListHandler(\n            editor,\n            res,\n            deleteForward,\n            unit\n          );\n        });\n\n        return skipDefaultDelete;\n      };\n\n      if (deleteForwardList()) return;\n\n      deleteForward(unit);\n    },\n  },\n});\n","import {\n  type OverrideEditor,\n  type SlateEditor,\n  type TRange,\n  deleteMerge,\n} from '@udecode/plate';\n\nimport { type ListConfig, BaseListItemPlugin } from './BaseListPlugin';\nimport { getHighestEmptyList } from './queries/getHighestEmptyList';\nimport { hasListChild } from './queries/hasListChild';\nimport { isAcrossListItems } from './queries/isAcrossListItems';\n\nconst getLiStart = (editor: SlateEditor) => {\n  const start = editor.api.start(editor.selection as TRange);\n\n  return editor.api.above({\n    at: start,\n    match: { type: editor.getType(BaseListItemPlugin) },\n  });\n};\n\nexport const withDeleteFragmentList: OverrideEditor<ListConfig> = ({\n  editor,\n  tf: { deleteFragment },\n}) => ({\n  transforms: {\n    deleteFragment(direction) {\n      const deleteFragmentList = () => {\n        let deleted = false;\n\n        editor.tf.withoutNormalizing(() => {\n          // Selection should be across list items\n          if (!isAcrossListItems(editor)) return;\n\n          /**\n           * Check if the end li can be deleted (if it has no sublist). Store\n           * the path ref to delete it after deleteMerge.\n           */\n          const end = editor.api.end(editor.selection as TRange);\n          const liEnd = editor.api.above({\n            at: end,\n            match: { type: editor.getType(BaseListItemPlugin) },\n          });\n          const liEndCanBeDeleted = liEnd && !hasListChild(editor, liEnd[0]);\n          const liEndPathRef = liEndCanBeDeleted\n            ? editor.api.pathRef(liEnd![1])\n            : undefined;\n\n          // use deleteFragment when selection wrapped around list\n          if (!getLiStart(editor) || !liEnd) {\n            deleted = false;\n\n            return;\n          }\n\n          /** Delete fragment and move end block children to start block */\n          deleteMerge(editor);\n\n          const liStart = getLiStart(editor);\n\n          if (liEndPathRef) {\n            const liEndPath = liEndPathRef.unref()!;\n            const listStart = liStart && editor.api.parent(liStart[1]);\n\n            const deletePath = getHighestEmptyList(editor, {\n              diffListPath: listStart?.[1],\n              liPath: liEndPath,\n            });\n\n            if (deletePath) {\n              editor.tf.removeNodes({ at: deletePath });\n            }\n\n            deleted = true;\n          }\n        });\n\n        return deleted;\n      };\n\n      if (deleteFragmentList()) return;\n\n      deleteFragment(direction);\n    },\n  },\n});\n","import {\n  type Ancestor,\n  type AncestorEntry,\n  type Descendant,\n  type DescendantEntry,\n  type ElementEntry,\n  type OverrideEditor,\n  type Path,\n  type TElement,\n  type TText,\n  ElementApi,\n  NodeApi,\n  PathApi,\n} from '@udecode/plate';\n\nimport {\n  type ListConfig,\n  BaseListItemContentPlugin,\n  BaseListItemPlugin,\n} from './BaseListPlugin';\nimport { isListRoot } from './queries';\n\nexport const withInsertFragmentList: OverrideEditor<ListConfig> = ({\n  editor,\n  tf: { insertFragment },\n}) => {\n  const listItemType = editor.getType(BaseListItemPlugin);\n  const listItemContentType = editor.getType(BaseListItemContentPlugin);\n\n  const getFirstAncestorOfType = (\n    root: Descendant,\n    entry: DescendantEntry,\n    type: string\n  ): AncestorEntry => {\n    let ancestor: Path = PathApi.parent(entry[1]);\n\n    while (NodeApi.get<TElement>(root, ancestor)!.type !== type) {\n      ancestor = PathApi.parent(ancestor);\n    }\n\n    return [NodeApi.get<Ancestor>(root, ancestor)!, ancestor];\n  };\n\n  const findListItemsWithContent = (first: Descendant): Descendant[] => {\n    let prev = null;\n    let node = first;\n\n    while (\n      isListRoot(editor, node) ||\n      (node.type === listItemType &&\n        (node.children as TElement[])[0].type !== listItemContentType)\n    ) {\n      prev = node;\n      [node] = node.children as Descendant[];\n    }\n\n    return prev ? (prev.children as Descendant[]) : [node];\n  };\n\n  /**\n   * Removes the \"empty\" leading lis. Empty in this context means lis only with\n   * other lis as children.\n   *\n   * @returns If argument is not a list root, returns it, otherwise returns ul[]\n   *   or li[].\n   */\n  const trimList = (listRoot: Descendant): TElement[] => {\n    if (!isListRoot(editor, listRoot)) {\n      return [listRoot as TElement];\n    }\n\n    const _texts = NodeApi.texts(listRoot);\n    const textEntries = Array.from(_texts);\n\n    const commonAncestorEntry = textEntries.reduce(\n      (commonAncestor, textEntry) =>\n        PathApi.isAncestor(commonAncestor[1], textEntry[1])\n          ? commonAncestor\n          : (NodeApi.common(listRoot, textEntry[1], commonAncestor[1]) as any),\n      // any list item would do, we grab the first one\n      getFirstAncestorOfType(listRoot, textEntries[0], listItemType)\n    );\n\n    const [first, ...rest] = isListRoot(\n      editor,\n      commonAncestorEntry[0] as Descendant\n    )\n      ? (commonAncestorEntry[0] as any).children\n      : [commonAncestorEntry[0]];\n\n    return [...findListItemsWithContent(first), ...rest];\n  };\n\n  const wrapNodeIntoListItem = (node: Descendant): TElement => {\n    return node.type === listItemType\n      ? (node as TElement)\n      : ({\n          children: [node],\n          type: listItemType,\n        } as TElement);\n  };\n\n  /**\n   * Checks if the fragment only consists of a single LIC in which case it is\n   * considered the user's intention was to copy a text, not a list\n   */\n  const isSingleLic = (fragment: Descendant[]) => {\n    const isFragmentOnlyListRoot =\n      fragment.length === 1 && isListRoot(editor, fragment[0]);\n\n    return (\n      isFragmentOnlyListRoot &&\n      [...NodeApi.nodes({ children: fragment } as any)]\n        .filter((entry): entry is ElementEntry =>\n          ElementApi.isElement(entry[0])\n        )\n        .filter(([node]) => node.type === listItemContentType).length === 1\n    );\n  };\n\n  const getTextAndListItemNodes = (\n    fragment: Descendant[],\n    liEntry: ElementEntry,\n    licEntry: ElementEntry\n  ) => {\n    const [, liPath] = liEntry;\n    const [licNode, licPath] = licEntry;\n    const isEmptyNode = !NodeApi.string(licNode);\n    const [first, ...rest] = fragment\n      .flatMap(trimList)\n      .map(wrapNodeIntoListItem);\n    let textNode: TText;\n    let listItemNodes: TElement[];\n\n    if (isListRoot(editor, fragment[0])) {\n      if (isSingleLic(fragment)) {\n        textNode = first as any;\n        listItemNodes = rest as TElement[];\n      } else if (isEmptyNode) {\n        // FIXME: is there a more direct way to set this?\n        const li = NodeApi.get(editor, liPath);\n        const [, ...currentSublists] = li!.children as TElement[];\n        const [newLic, ...newSublists] = first.children as TElement[];\n        editor.tf.insertNodes(newLic, {\n          at: PathApi.next(licPath),\n          select: true,\n        });\n        editor.tf.removeNodes({\n          at: licPath,\n        });\n\n        if (newSublists?.length) {\n          if (currentSublists?.length) {\n            // TODO: any better way to compile the path where the LIs of the newly inserted element will be inserted?\n            const path = [...liPath, 1, 0];\n            editor.tf.insertNodes(newSublists[0].children as TElement[], {\n              at: path,\n              select: true,\n            });\n          } else {\n            editor.tf.insertNodes(newSublists, {\n              at: PathApi.next(licPath),\n              select: true,\n            });\n          }\n        }\n\n        textNode = { text: '' };\n        listItemNodes = rest as TElement[];\n      } else {\n        textNode = { text: '' };\n        listItemNodes = [first as TElement, ...(rest as TElement[])];\n      }\n    } else {\n      textNode = first as any;\n      listItemNodes = rest as TElement[];\n    }\n\n    return { listItemNodes, textNode };\n  };\n\n  return {\n    transforms: {\n      insertFragment(fragment) {\n        let liEntry = editor.api.node<TElement>({\n          match: { type: listItemType },\n          mode: 'lowest',\n        });\n\n        // not inserting into a list item, delegate to other plugins\n        if (!liEntry) {\n          return insertFragment(\n            isListRoot(editor, fragment[0])\n              ? [{ text: '' }, ...fragment]\n              : fragment\n          );\n        }\n\n        // delete selection (if necessary) so that it can check if needs to insert into an empty block\n        insertFragment([{ text: '' }] as any);\n\n        // refetch to find the currently selected LI after the deletion above is performed\n        liEntry = editor.api.node<TElement>({\n          match: { type: listItemType },\n          mode: 'lowest',\n        });\n\n        // Check again if liEntry is undefined after the deletion above.\n        // This prevents unexpected behavior when pasting while a list is highlighted\n        if (!liEntry) {\n          return insertFragment(\n            isListRoot(editor, fragment[0])\n              ? [{ text: '' }, ...fragment]\n              : fragment\n          );\n        }\n\n        const licEntry = editor.api.node<TElement>({\n          match: { type: listItemContentType },\n          mode: 'lowest',\n        });\n\n        if (!licEntry) {\n          return insertFragment(\n            isListRoot(editor, fragment[0])\n              ? [{ text: '' }, ...fragment]\n              : fragment\n          );\n        }\n\n        const { listItemNodes, textNode } = getTextAndListItemNodes(\n          fragment,\n          liEntry!,\n          licEntry\n        );\n\n        insertFragment<TText>([textNode]); // insert text if needed\n\n        const [, liPath] = liEntry!;\n\n        return editor.tf.insertNodes(listItemNodes, {\n          at: PathApi.next(liPath),\n          select: true,\n        });\n      },\n    },\n  };\n};\n","import {\n  type OverrideEditor,\n  type TElement,\n  BaseParagraphPlugin,\n  ElementApi,\n  match,\n  NodeApi,\n  PathApi,\n} from '@udecode/plate';\n\nimport {\n  type ListConfig,\n  BaseListItemContentPlugin,\n  BaseListItemPlugin,\n} from './BaseListPlugin';\nimport { normalizeListItem } from './normalizers/normalizeListItem';\nimport { normalizeNestedList } from './normalizers/normalizeNestedList';\nimport { getListTypes, isListRoot } from './queries';\nimport { moveListItemsToList } from './transforms';\n\n/** Normalize list node to force the ul>li>p+ul structure. */\nexport const withNormalizeList: OverrideEditor<ListConfig> = ({\n  editor,\n  getOptions,\n  tf: { normalizeNode },\n}) => ({\n  transforms: {\n    normalizeNode([node, path]) {\n      const liType = editor.getType(BaseListItemPlugin);\n      const licType = editor.getType(BaseListItemContentPlugin);\n      const defaultType = editor.getType(BaseParagraphPlugin);\n\n      if (!ElementApi.isElement(node)) {\n        return normalizeNode([node, path]);\n      }\n      if (isListRoot(editor, node)) {\n        const nonLiChild = Array.from(NodeApi.children(editor, path)).find(\n          ([child]) => child.type !== liType\n        );\n\n        if (nonLiChild) {\n          return editor.tf.wrapNodes<TElement>(\n            { children: [], type: liType },\n            { at: nonLiChild[1] }\n          );\n        }\n      }\n      // remove empty list\n      if (match(node, [], { type: getListTypes(editor) })) {\n        if (\n          node.children.length === 0 ||\n          !node.children.some((item) => item.type === liType)\n        ) {\n          return editor.tf.removeNodes({ at: path });\n        }\n\n        const nextPath = PathApi.next(path);\n        const nextNode = NodeApi.get<TElement>(editor, nextPath)!;\n\n        // Has a list afterwards with the same type\n        if (nextNode?.type === node.type) {\n          moveListItemsToList(editor, {\n            deleteFromList: true,\n            fromList: [nextNode, nextPath],\n            toList: [node, path],\n          });\n        }\n\n        const prevPath = PathApi.previous(path)!;\n        const prevNode = NodeApi.get<TElement>(editor, prevPath);\n\n        // Has a list before with the same type\n        if (prevNode?.type === node.type) {\n          editor.tf.normalizeNode([prevNode, prevPath]);\n\n          // early return since this node will no longer exists\n          return;\n        }\n        if (normalizeNestedList(editor, { nestedListItem: [node, path] })) {\n          return;\n        }\n      }\n      if (\n        node.type === editor.getType(BaseListItemPlugin) &&\n        normalizeListItem(editor, {\n          listItem: [node, path],\n          validLiChildrenTypes: getOptions().validLiChildrenTypes,\n        })\n      ) {\n        return;\n      }\n      // LIC should have LI parent. If not, set LIC to DEFAULT type.\n      if (\n        node.type === licType &&\n        licType !== defaultType &&\n        editor.api.parent(path)?.[0].type !== liType\n      ) {\n        editor.tf.setNodes({ type: defaultType }, { at: path });\n\n        return;\n      }\n\n      normalizeNode([node, path]);\n    },\n  },\n});\n","import {\n  type Descendant,\n  type ElementEntry,\n  type NodeEntry,\n  type PathRef,\n  type SlateEditor,\n  type TElement,\n  match,\n  NodeApi,\n  PathApi,\n} from '@udecode/plate';\n\nimport {\n  type ListConfig,\n  BaseBulletedListPlugin,\n  BaseListItemContentPlugin,\n  BaseNumberedListPlugin,\n} from '../BaseListPlugin';\nimport { getListTypes } from '../queries/index';\nimport { moveListItemUp } from '../transforms/index';\n\n/**\n * Recursively get all the:\n *\n * - Block children\n * - Inline children except those at excludeDepth\n */\nexport const getDeepInlineChildren = (\n  editor: SlateEditor,\n  {\n    children,\n  }: {\n    children: NodeEntry<Descendant>[];\n  }\n) => {\n  const inlineChildren: NodeEntry<Descendant>[] = [];\n\n  for (const child of children) {\n    if (editor.api.isBlock(child[0])) {\n      inlineChildren.push(\n        ...getDeepInlineChildren(editor, {\n          children: Array.from(NodeApi.children(editor, child[1])),\n        })\n      );\n    } else {\n      inlineChildren.push(child);\n    }\n  }\n\n  return inlineChildren;\n};\n\n/**\n * If the list item has no child: insert an empty list item container. Else:\n * move the children that are not valid to the list item container.\n */\nexport const normalizeListItem = (\n  editor: SlateEditor,\n  {\n    listItem,\n    validLiChildrenTypes = [],\n  }: { listItem: ElementEntry } & ListConfig['options']\n) => {\n  let changed = false;\n\n  const allValidLiChildrenTypes = new Set([\n    editor.getType(BaseBulletedListPlugin),\n    editor.getType(BaseListItemContentPlugin),\n    editor.getType(BaseNumberedListPlugin),\n    ...validLiChildrenTypes,\n  ]);\n\n  const [, liPath] = listItem;\n  const liChildren = Array.from(\n    NodeApi.children<TElement>(editor, listItem[1])\n  );\n\n  // Get invalid (type) li children path refs to be moved\n  const invalidLiChildrenPathRefs = liChildren\n    .filter(([child]) => !allValidLiChildrenTypes.has(child.type))\n    .map(([, childPath]) => editor.api.pathRef(childPath));\n\n  const firstLiChild: ElementEntry | undefined = liChildren[0];\n  const [firstLiChildNode, firstLiChildPath] = firstLiChild ?? [];\n\n  // If li has no child or inline child, insert lic\n  if (!firstLiChild || !editor.api.isBlock(firstLiChildNode)) {\n    editor.tf.insertNodes(\n      editor.api.create.block({\n        type: editor.getType(BaseListItemContentPlugin),\n      }),\n      {\n        at: liPath.concat([0]),\n      }\n    );\n\n    return true;\n  }\n  // If first li child is a block but not lic, set it to lic\n  if (\n    editor.api.isBlock(firstLiChildNode) &&\n    !match(firstLiChildNode, [], {\n      type: editor.getType(BaseListItemContentPlugin),\n    })\n  ) {\n    if (\n      match(firstLiChildNode, [], {\n        type: getListTypes(editor),\n      })\n    ) {\n      // the listItem has no lic so we move the children up a level\n      const parent = editor.api.parent(listItem[1]);\n      const sublist = firstLiChild;\n      const children = Array.from(\n        NodeApi.children<TElement>(editor, firstLiChild[1])\n      ).reverse();\n      children.forEach((c) => {\n        moveListItemUp(editor, {\n          list: sublist,\n          listItem: c,\n        });\n      });\n\n      editor.tf.removeNodes({ at: [...parent![1], 0] });\n\n      return true;\n    }\n    // Allow block elements listed as valid li children types to be a first child instead of LIC\n    if (validLiChildrenTypes.includes(firstLiChildNode.type)) {\n      return true;\n    }\n\n    editor.tf.setNodes(\n      {\n        type: editor.getType(BaseListItemContentPlugin),\n      },\n      {\n        at: firstLiChildPath,\n      }\n    );\n\n    changed = true;\n  }\n\n  const licChildren = Array.from(NodeApi.children(editor, firstLiChild[1]));\n\n  if (licChildren.length > 0) {\n    const blockPathRefs: PathRef[] = [];\n    const inlineChildren: NodeEntry[] = [];\n\n    // Check that lic has no block children\n    for (const licChild of licChildren) {\n      if (!editor.api.isBlock(licChild[0])) {\n        break;\n      }\n\n      blockPathRefs.push(editor.api.pathRef(licChild[1]));\n\n      inlineChildren.push(\n        ...getDeepInlineChildren(editor, {\n          children: Array.from(NodeApi.children(editor, licChild[1])),\n        })\n      );\n    }\n\n    const to = PathApi.next(licChildren.at(-1)![1]);\n\n    // Move lic nested inline children to its children\n    inlineChildren.reverse().forEach(([, path]) => {\n      editor.tf.moveNodes({\n        at: path,\n        to,\n      });\n    });\n\n    // Remove lic block children\n    blockPathRefs.forEach((pathRef) => {\n      const path = pathRef.unref();\n\n      path &&\n        editor.tf.removeNodes({\n          at: path,\n        });\n    });\n\n    if (blockPathRefs.length > 0) {\n      changed = true;\n    }\n  }\n  if (changed) return true;\n\n  // Ensure that any text nodes under the list are inside the list item container\n  invalidLiChildrenPathRefs.reverse().forEach((ref) => {\n    const path = ref.unref();\n\n    path &&\n      editor.tf.moveNodes({\n        at: path,\n        to: firstLiChildPath.concat([0]),\n      });\n  });\n\n  return invalidLiChildrenPathRefs.length > 0;\n};\n","import {\n  type ElementEntry,\n  type SlateEditor,\n  match,\n  PathApi,\n} from '@udecode/plate';\n\nimport { getListTypes } from '../queries/index';\n\n// When pasting from e.g. Google Docs, the structure of nested lists like \"ul -> ul\"\n// should be normalized to \"ul -> li -> lic + ul\".\n// In other words, a nested list as a direct children of a list should be moved into a previous list item sibling\nexport const normalizeNestedList = (\n  editor: SlateEditor,\n  { nestedListItem }: { nestedListItem: ElementEntry }\n) => {\n  const [, path] = nestedListItem;\n\n  const parentNode = editor.api.parent(path);\n  const hasParentList =\n    parentNode && match(parentNode[0], [], { type: getListTypes(editor) });\n\n  if (!hasParentList) {\n    return false;\n  }\n\n  const previousListItemPath = PathApi.previous(path);\n\n  if (!previousListItemPath) {\n    return false;\n  }\n\n  // Previous sibling is the new parent\n  const previousSiblingItem = editor.api.node(previousListItemPath);\n\n  if (previousSiblingItem) {\n    const [, previousPath] = previousSiblingItem;\n    const newPath = previousPath.concat([1]);\n\n    // Move the current item to the sublist\n    editor.tf.moveNodes({\n      at: path,\n      to: newPath,\n    });\n\n    return true;\n  }\n};\n"],"mappings":"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","names":["import_plate","import_plate","import_plate","import_plate","import_plate","import_plate","import_plate","import_plate","import_plate","import_plate","import_plate","import_plate","toListPath","import_plate","import_plate","import_plate","import_plate","import_plate","import_plate","import_plate","pointAfterListItem","import_plate","import_plate","import_plate","import_plate","import_plate"]}