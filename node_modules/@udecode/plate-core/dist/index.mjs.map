{"version":3,"sources":["../src/lib/editor/withSlate.ts","../src/internal/utils/isFunction.ts","../src/internal/utils/mergePlugins.ts","../src/lib/plugin/createSlatePlugin.ts","../src/lib/plugin/getEditorPlugin.ts","../src/internal/plugin/resolvePlugin.ts","../src/lib/plugin/getSlatePlugin.ts","../src/internal/plugin/pipeNormalizeInitialValue.ts","../src/internal/plugin/resolvePlugins.ts","../src/lib/plugins/AstPlugin.ts","../src/lib/plugins/DOMPlugin.ts","../src/lib/plugins/HistoryPlugin.ts","../src/lib/plugins/InlineVoidPlugin.ts","../src/internal/plugin/pipeInsertFragment.ts","../src/internal/plugin/pipeTransformData.ts","../src/internal/plugin/pipeTransformFragment.ts","../src/lib/utils/applyDeepToNodes.ts","../src/lib/utils/defaultsDeepToNodes.ts","../src/lib/utils/getInjectMatch.ts","../src/lib/utils/getKeysByTypes.ts","../src/lib/utils/getInjectedPlugins.ts","../src/lib/utils/getPluginNodeProps.ts","../src/lib/static/pipeRenderElementStatic.tsx","../src/lib/static/components/SlateElement.tsx","../src/lib/static/pluginRenderElementStatic.tsx","../src/lib/static/utils/createStaticString.ts","../src/lib/static/utils/getNodeDataAttributes.ts","../src/lib/static/utils/getRenderNodeStaticProps.ts","../src/internal/plugin/pipeInjectNodeProps.tsx","../src/internal/plugin/pluginInjectNodeProps.ts","../src/lib/static/utils/pipeDecorate.ts","../src/lib/static/utils/stripHtmlClassNames.ts","../src/lib/static/utils/stripSlateDataAttributes.ts","../src/lib/static/pluginRenderLeafStatic.tsx","../src/lib/static/components/SlateLeaf.tsx","../src/lib/static/serializeHtml.tsx","../src/lib/static/components/PlateStatic.tsx","../src/lib/static/deserialize/checkUtils.ts","../src/lib/static/deserialize/htmlStringToEditorDOM.ts","../src/lib/utils/getSlateClass.ts","../src/lib/utils/hotkeys.ts","../src/lib/utils/isType.ts","../src/lib/utils/mergeDeepToNodes.ts","../src/lib/utils/normalizeDescendantsToDocumentFragment.ts","../src/lib/plugins/debug/DebugPlugin.ts","../src/lib/plugins/html/HtmlPlugin.ts","../src/lib/plugins/html/constants.ts","../src/lib/plugins/html/utils/isHtmlElement.ts","../src/lib/plugins/html/utils/traverseHtmlNode.ts","../src/lib/plugins/html/utils/traverseHtmlElements.ts","../src/lib/plugins/html/utils/cleanHtmlBrElements.ts","../src/lib/plugins/html/utils/cleanHtmlCrLf.ts","../src/lib/plugins/html/utils/cleanHtmlEmptyElements.ts","../src/lib/plugins/html/utils/replaceTagName.ts","../src/lib/plugins/html/utils/cleanHtmlFontElements.ts","../src/lib/plugins/html/utils/isHtmlFragmentHref.ts","../src/lib/plugins/html/utils/unwrapHtmlElement.ts","../src/lib/plugins/html/utils/cleanHtmlLinkElements.ts","../src/lib/plugins/html/utils/isHtmlText.ts","../src/lib/plugins/html/utils/traverseHtmlTexts.ts","../src/lib/plugins/html/utils/cleanHtmlTextNodes.ts","../src/lib/plugins/html/utils/inlineTagNames.ts","../src/lib/plugins/html/utils/isHtmlInlineElement.ts","../src/lib/plugins/html/utils/isHtmlBlockElement.ts","../src/lib/plugins/html/utils/isHtmlTable.ts","../src/lib/plugins/html/utils/copyBlockMarksToSpanChild.ts","../src/lib/plugins/html/utils/collapse-white-space/collapseString.ts","../src/lib/plugins/html/utils/collapse-white-space/isLastNonEmptyTextOfInlineFormattingContext.ts","../src/lib/plugins/html/utils/collapse-white-space/stateTransforms.ts","../src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceText.ts","../src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceNode.ts","../src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceChildren.ts","../src/lib/plugins/html/utils/collapse-white-space/inferWhiteSpaceRule.ts","../src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceElement.ts","../src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpace.ts","../src/lib/plugins/html/utils/htmlBodyToFragment.ts","../src/lib/plugins/html/utils/deserializeHtmlNodeChildren.ts","../src/lib/plugins/html/utils/htmlBrToNewLine.ts","../src/lib/plugins/html/utils/htmlElementToElement.ts","../src/lib/plugins/html/utils/pluginDeserializeHtml.ts","../src/lib/plugins/html/utils/getDataNodeProps.ts","../src/lib/plugins/html/utils/pipeDeserializeHtmlElement.ts","../src/lib/plugins/html/utils/htmlElementToLeaf.ts","../src/lib/plugins/html/utils/pipeDeserializeHtmlLeaf.ts","../src/lib/plugins/html/utils/htmlTextNodeToString.ts","../src/lib/plugins/html/utils/deserializeHtmlNode.ts","../src/lib/plugins/html/utils/deserializeHtmlElement.ts","../src/lib/plugins/html/utils/htmlStringToDOMNode.ts","../src/lib/plugins/html/utils/deserializeHtml.ts","../src/lib/plugins/html/utils/findHtmlElement.ts","../src/lib/plugins/html/utils/getHtmlComments.ts","../src/lib/plugins/html/utils/isHtmlComment.ts","../src/lib/plugins/html/utils/isOlSymbol.ts","../src/lib/plugins/html/utils/parseHtmlDocument.ts","../src/lib/plugins/html/utils/parseHtmlElement.ts","../src/lib/plugins/html/utils/postCleanHtml.ts","../src/lib/plugins/html/utils/removeHtmlSurroundings.ts","../src/lib/plugins/html/utils/preCleanHtml.ts","../src/lib/plugins/html/utils/traverseHtmlComments.ts","../src/lib/plugins/html/utils/removeHtmlNodesBetweenComments.ts","../src/lib/plugins/length/LengthPlugin.ts","../src/lib/plugins/paragraph/BaseParagraphPlugin.ts","../src/lib/plugins/slate-extension/SlateExtensionPlugin.ts","../src/lib/utils/omitPluginContext.ts","../src/lib/utils/overridePluginsByKey.ts","../src/lib/utils/pipeInsertDataQuery.ts","../src/lib/utils/resolvePlugins.ts","../src/lib/plugins/ParserPlugin.ts","../src/lib/plugins/getCorePlugins.ts","../src/lib/libs/nanoid.ts","../src/lib/libs/zustand.ts"],"sourcesContent":["import {\n  type Editor,\n  type TSelection,\n  type Value,\n  createEditor,\n} from '@udecode/slate';\nimport { nanoid } from 'nanoid';\n\nimport type { AnyPluginConfig } from '../plugin/BasePlugin';\nimport type { AnySlatePlugin } from '../plugin/SlatePlugin';\nimport type { InferPlugins, SlateEditor, TSlateEditor } from './SlateEditor';\n\nimport { pipeNormalizeInitialValue } from '../../internal/plugin/pipeNormalizeInitialValue';\nimport { resolvePlugins } from '../../internal/plugin/resolvePlugins';\nimport { createSlatePlugin } from '../plugin/createSlatePlugin';\nimport { getPluginType, getSlatePlugin } from '../plugin/getSlatePlugin';\nimport { type CorePlugin, getCorePlugins } from '../plugins/getCorePlugins';\n\nexport type BaseWithSlateOptions<P extends AnyPluginConfig = CorePlugin> = {\n  id?: string;\n  /**\n   * Select the editor after initialization.\n   *\n   * @default false\n   *\n   * - `true` | 'end': Select the end of the editor\n   * - `false`: Do not select anything\n   * - `'start'`: Select the start of the editor\n   */\n  autoSelect?: boolean | 'end' | 'start';\n  /** Specifies the maximum number of characters allowed in the editor. */\n  maxLength?: number;\n  plugins?: P[];\n  selection?: TSelection;\n  /**\n   * When `true`, it will normalize the initial `value` passed to the `editor`.\n   * This is useful when adding normalization rules on already existing\n   * content.\n   *\n   * @default false\n   */\n  shouldNormalizeEditor?: boolean;\n};\n\nexport type WithSlateOptions<\n  V extends Value = Value,\n  P extends AnyPluginConfig = CorePlugin,\n> = BaseWithSlateOptions<P> &\n  Pick<\n    Partial<AnySlatePlugin>,\n    | 'api'\n    | 'decorate'\n    | 'extendEditor'\n    | 'inject'\n    | 'normalizeInitialValue'\n    | 'options'\n    | 'override'\n    | 'transforms'\n  > & {\n    value?: ((editor: SlateEditor) => V) | V | string;\n    /** Function to configure the root plugin */\n    rootPlugin?: (plugin: AnySlatePlugin) => AnySlatePlugin;\n  };\n\n/**\n * Applies Plate enhancements to an editor instance (non-React version).\n *\n * @remarks\n *   This function supports server-side usage as it doesn't include the\n *   ReactPlugin.\n * @see {@link createSlateEditor} for a higher-level non-React editor creation function.\n * @see {@link createPlateEditor} for a higher-level React editor creation function.\n * @see {@link usePlateEditor} for a React memoized version.\n * @see {@link withPlate} for the React-specific enhancement function.\n */\nexport const withSlate = <\n  V extends Value = Value,\n  P extends AnyPluginConfig = CorePlugin,\n>(\n  e: Editor,\n  {\n    id,\n    autoSelect,\n    maxLength,\n    plugins = [],\n    rootPlugin,\n    selection,\n    shouldNormalizeEditor,\n    value,\n    ...pluginConfig\n  }: WithSlateOptions<V, P> = {}\n): TSlateEditor<V, InferPlugins<P[]>> => {\n  const editor = e as SlateEditor;\n\n  editor.id = id ?? editor.id ?? nanoid();\n  editor.key = editor.key ?? nanoid();\n  editor.isFallback = false;\n  editor.prevSelection = null;\n  editor.currentKeyboardEvent = null;\n\n  editor.getApi = () => editor.api as any;\n  editor.getTransforms = () => editor.transforms as any;\n  editor.getPlugin = (plugin) => getSlatePlugin(editor, plugin) as any;\n  editor.getType = (plugin) => getPluginType(editor, plugin);\n  editor.getInjectProps = (plugin) => {\n    return (\n      editor.getPlugin<AnySlatePlugin>(plugin).inject?.nodeProps ?? ({} as any)\n    );\n  };\n  editor.getOptionsStore = (plugin) => {\n    return editor.getPlugin(plugin).optionsStore;\n  };\n  editor.getOptions = (plugin) => {\n    const store = editor.getOptionsStore(plugin);\n\n    if (!store) return editor.getPlugin(plugin).options;\n\n    return editor.getOptionsStore(plugin).get('state');\n  };\n  editor.getOption = (plugin, key, ...args) => {\n    const store = editor.getOptionsStore(plugin);\n\n    if (!store) return editor.getPlugin(plugin).options[key];\n\n    if (!(key in store.get('state')) && !(key in store.selectors)) {\n      editor.api.debug.error(\n        `editor.getOption: ${key as string} option is not defined in plugin ${plugin.key}.`,\n        'OPTION_UNDEFINED'\n      );\n      return;\n    }\n\n    return (store.get as any)(key, ...args);\n  };\n  editor.setOption = (plugin: any, key: any, ...args: any) => {\n    const store = editor.getOptionsStore(plugin);\n\n    if (!store) return;\n\n    if (!(key in store.get('state'))) {\n      editor.api.debug.error(\n        `editor.setOption: ${key} option is not defined in plugin ${plugin.key}.`,\n        'OPTION_UNDEFINED'\n      );\n      return;\n    }\n\n    (store.set as any)(key, ...args);\n  };\n  editor.setOptions = (plugin: any, options: any) => {\n    const store = editor.getOptionsStore(plugin);\n\n    if (!store) return;\n    if (typeof options === 'object') {\n      store.set('state', (draft: any) => {\n        Object.assign(draft, options);\n      });\n    } else if (typeof options === 'function') {\n      store.set('state', options);\n    }\n  };\n\n  // Plugin initialization code\n  const corePlugins = getCorePlugins({\n    maxLength,\n    plugins,\n  });\n\n  let rootPluginInstance = createSlatePlugin({\n    key: 'root',\n    priority: 10_000,\n    ...pluginConfig,\n    plugins: [...corePlugins, ...plugins],\n  });\n\n  // Apply rootPlugin configuration if provided\n  if (rootPlugin) {\n    rootPluginInstance = rootPlugin(rootPluginInstance) as any;\n  }\n\n  resolvePlugins(editor, [rootPluginInstance]);\n\n  if (typeof value === 'string') {\n    editor.children = editor.api.html.deserialize({ element: value }) as Value;\n  } else if (typeof value === 'function') {\n    editor.children = value(editor);\n  } else if (value) {\n    editor.children = value;\n  }\n  if (!editor.children || editor.children?.length === 0) {\n    editor.children = editor.api.create.value();\n  }\n  if (selection) {\n    editor.selection = selection;\n  } else if (autoSelect) {\n    const edge = autoSelect === 'start' ? 'start' : 'end';\n    const target = edge === 'start' ? editor.api.start([]) : editor.api.end([]);\n    editor.tf.select(target!);\n  }\n  if (editor.children.length > 0) {\n    pipeNormalizeInitialValue(editor);\n  }\n  if (shouldNormalizeEditor) {\n    editor.tf.normalize({ force: true });\n  }\n\n  return editor as any;\n};\n\nexport type CreateSlateEditorOptions<\n  V extends Value = Value,\n  P extends AnyPluginConfig = CorePlugin,\n> = WithSlateOptions<V, P> & {\n  /**\n   * Initial editor to be extended with `withPlate`.\n   *\n   * @default createEditor()\n   */\n  editor?: Editor;\n};\n\n/**\n * Creates a Slate editor without React-specific enhancements.\n *\n * @see {@link createPlateEditor} for a React-specific version of editor creation.\n * @see {@link usePlateEditor} for a memoized React version.\n * @see {@link withSlate} for the underlying function that applies Slate enhancements to an editor.\n */\nexport const createSlateEditor = <\n  V extends Value = Value,\n  P extends AnyPluginConfig = CorePlugin,\n>({\n  editor = createEditor(),\n  ...options\n}: CreateSlateEditorOptions<V, P> = {}) => {\n  return withSlate<V, P>(editor, options);\n};\n","export function isFunction(value: any): value is Function {\n  return typeof value === 'function';\n}\n","import mergeWith from 'lodash/mergeWith.js';\n\nimport type { SlatePlugin } from '../../lib';\n\nexport function mergePlugins<T>(basePlugin: T, ...sourcePlugins: any[]): T {\n  return mergeWith(\n    {},\n    basePlugin,\n    ...sourcePlugins,\n    (objValue: unknown, srcValue: unknown, key: keyof SlatePlugin) => {\n      // Overwrite array (including plugins) without cloning\n      if (Array.isArray(srcValue)) {\n        return srcValue;\n      }\n      // Shallow merge options\n      if (key === 'options') {\n        return { ...(objValue as any), ...(srcValue as any) };\n      }\n    }\n  );\n}\n","import type { Modify } from '@udecode/utils';\n\nimport type { SlateEditor } from '../editor/SlateEditor';\nimport type { AnyPluginConfig, PluginConfig } from './BasePlugin';\nimport type {\n  SlatePlugin,\n  SlatePluginMethods,\n  SlatePlugins,\n} from './SlatePlugin';\n\nimport { isFunction } from '../../internal/utils/isFunction';\nimport { mergePlugins } from '../../internal/utils/mergePlugins';\n\ntype SlatePluginConfig<\n  K extends string = any,\n  O = {},\n  A = {},\n  T = {},\n  S = {},\n> = Omit<\n  Partial<\n    Modify<\n      SlatePlugin<PluginConfig<K, O, A, T, S>>,\n      {\n        node?: Partial<SlatePlugin<PluginConfig<K, O, A, T, S>>['node']>;\n      }\n    >\n  >,\n  keyof SlatePluginMethods | 'optionsStore'\n>;\n\ntype TSlatePluginConfig<C extends AnyPluginConfig = PluginConfig> = Omit<\n  Partial<\n    Modify<\n      SlatePlugin<C>,\n      {\n        node?: Partial<SlatePlugin<C>['node']>;\n      }\n    >\n  >,\n  keyof SlatePluginMethods | 'optionsStore'\n>;\n\n/**\n * Creates a new Plate plugin with the given configuration.\n *\n * @remarks\n *   - The plugin's key is required and specified by the K generic.\n *   - The `__extensions` array stores functions to be applied when `resolvePlugin`\n *       is called with an editor.\n *   - The `extend` method adds new extensions to be applied later.\n *   - The `extendPlugin` method extends an existing plugin (including nested\n *       plugins) or adds a new one if not found.\n *\n * @example\n *   const myPlugin = createSlatePlugin<\n *     'myPlugin',\n *     MyOptions,\n *     MyApi,\n *     MyTransforms\n *   >({\n *     key: 'myPlugin',\n *     options: { someOption: true },\n *     transforms: { someTransform: () => {} },\n *   });\n *\n *   const extendedPlugin = myPlugin.extend({\n *     options: { anotherOption: false },\n *   });\n *\n *   const pluginWithNestedExtension = extendedPlugin.extendPlugin(\n *     nestedPlugin,\n *     {\n *       options: { nestedOption: true },\n *     }\n *   );\n *\n * @template K - The literal type of the plugin key.\n * @template O - The type of the plugin options.\n * @template A - The type of the plugin utilities.\n * @template T - The type of the plugin transforms.\n * @template S - The type of the plugin storage.\n * @param {Partial<SlatePlugin<K, O, A, T, S>>} config - The configuration\n *   object for the plugin.\n * @returns {SlatePlugin<K, O, A, T, S>} A new Plate plugin instance with the\n *   following properties and methods:\n *\n *   - All properties from the input config, merged with default values.\n *   - `configure`: A method to create a new plugin instance with updated options.\n *   - `extend`: A method to create a new plugin instance with additional\n *       configuration.\n *   - `extendPlugin`: A method to extend an existing plugin (including nested\n *       plugins) or add a new one if not found.\n */\nexport function createSlatePlugin<\n  K extends string = any,\n  O = {},\n  A = {},\n  T = {},\n  S = {},\n>(\n  config:\n    | ((editor: SlateEditor) => SlatePluginConfig<K, O, A, T, S>)\n    | SlatePluginConfig<K, O, A, T, S> = {}\n): SlatePlugin<PluginConfig<K, O, A, T, S>> {\n  let baseConfig: Partial<SlatePlugin<PluginConfig<K, O, A, T, S>>>;\n  let initialExtension: any;\n\n  if (isFunction(config)) {\n    baseConfig = { key: '' as K };\n    initialExtension = (editor: any) => config(editor);\n  } else {\n    baseConfig = config as any;\n  }\n\n  const key = baseConfig.key ?? '';\n\n  const plugin = mergePlugins(\n    {\n      key,\n      __apiExtensions: [],\n      __configuration: null,\n      __extensions: initialExtension ? [initialExtension] : [],\n      __selectorExtensions: [],\n      api: {},\n      dependencies: [],\n      editor: {},\n      handlers: {},\n      inject: {},\n      node: { type: key },\n      options: {},\n      override: {},\n      parser: {},\n      parsers: {},\n      plugins: [],\n      priority: 100,\n      render: {},\n      shortcuts: {},\n      transforms: {},\n    },\n    config\n  ) as unknown as SlatePlugin<PluginConfig<K, O, A, T, S>>;\n\n  plugin.configure = (config) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__configuration = (ctx) =>\n      isFunction(config) ? config(ctx as any) : config;\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.configurePlugin = (p, config) => {\n    const newPlugin = { ...plugin };\n\n    const configureNestedPlugin = (\n      plugins: SlatePlugins\n    ): { found: boolean; plugins: SlatePlugins } => {\n      let found = false;\n\n      const updatedPlugins = plugins.map((nestedPlugin) => {\n        if (nestedPlugin.key === p.key) {\n          found = true;\n\n          return createSlatePlugin({\n            ...nestedPlugin,\n            __configuration: (ctx: any) =>\n              isFunction(config) ? config(ctx) : config,\n          } as any);\n        }\n        if (nestedPlugin.plugins && nestedPlugin.plugins.length > 0) {\n          const result = configureNestedPlugin(nestedPlugin.plugins);\n\n          if (result.found) {\n            found = true;\n\n            return {\n              ...nestedPlugin,\n              plugins: result.plugins,\n            };\n          }\n        }\n\n        return nestedPlugin;\n      });\n\n      return { found, plugins: updatedPlugins };\n    };\n\n    const result = configureNestedPlugin(newPlugin.plugins as any);\n    newPlugin.plugins = result.plugins as any;\n\n    // We're not adding a new plugin if not found\n\n    return createSlatePlugin(newPlugin);\n  };\n\n  plugin.extendEditorApi = (extension) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__apiExtensions = [\n      ...(newPlugin.__apiExtensions as any),\n      { extension, isPluginSpecific: false },\n    ];\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.extendSelectors = (extension) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__selectorExtensions = [\n      ...(newPlugin.__selectorExtensions as any),\n      extension,\n    ];\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.extendApi = (extension) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__apiExtensions = [\n      ...(newPlugin.__apiExtensions as any),\n      { extension, isPluginSpecific: true },\n    ];\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.extendEditorTransforms = (extension) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__apiExtensions = [\n      ...(newPlugin.__apiExtensions as any),\n      { extension, isPluginSpecific: false, isTransform: true },\n    ];\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.extendTransforms = (extension) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__apiExtensions = [\n      ...(newPlugin.__apiExtensions as any),\n      { extension, isPluginSpecific: true, isTransform: true },\n    ];\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.overrideEditor = (extension) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__apiExtensions = [\n      ...(newPlugin.__apiExtensions as any),\n      {\n        extension,\n        isOverride: true,\n        isPluginSpecific: false,\n        isTransform: true,\n      },\n    ];\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.extend = (extendConfig) => {\n    let newPlugin = { ...plugin };\n\n    if (isFunction(extendConfig)) {\n      newPlugin.__extensions = [\n        ...(newPlugin.__extensions as any),\n        extendConfig,\n      ];\n    } else {\n      newPlugin = mergePlugins(newPlugin, extendConfig as any);\n    }\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.clone = () => mergePlugins(plugin);\n\n  plugin.extendPlugin = (p, extendConfig) => {\n    const newPlugin = { ...plugin };\n\n    const extendNestedPlugin = (\n      plugins: SlatePlugins\n    ): { found: boolean; plugins: SlatePlugins } => {\n      let found = false;\n      const updatedPlugins = plugins.map((nestedPlugin) => {\n        if (nestedPlugin.key === p.key) {\n          found = true;\n\n          return createSlatePlugin({\n            ...nestedPlugin,\n            __extensions: [\n              ...(nestedPlugin.__extensions as any),\n              (ctx: any) =>\n                isFunction(extendConfig) ? extendConfig(ctx) : extendConfig,\n            ],\n          } as any);\n        }\n        if (nestedPlugin.plugins && nestedPlugin.plugins.length > 0) {\n          const result = extendNestedPlugin(nestedPlugin.plugins);\n\n          if (result.found) {\n            found = true;\n\n            return {\n              ...nestedPlugin,\n              plugins: result.plugins,\n            };\n          }\n        }\n\n        return nestedPlugin;\n      });\n\n      return { found, plugins: updatedPlugins };\n    };\n\n    const result = extendNestedPlugin(newPlugin.plugins as any);\n    newPlugin.plugins = result.plugins as any;\n\n    // If the plugin wasn't found at any level, add it at the top level\n    if (!result.found) {\n      newPlugin.plugins.push(\n        createSlatePlugin({\n          key: p.key,\n          __extensions: [\n            (ctx: any) =>\n              isFunction(extendConfig)\n                ? extendConfig(ctx as any)\n                : (extendConfig as any),\n          ],\n        } as any)\n      );\n    }\n\n    return createSlatePlugin(newPlugin);\n  };\n\n  return plugin;\n}\n\n/**\n * Explicitly typed version of `createSlatePlugin`.\n *\n * @remarks\n *   While `createSlatePlugin` uses type inference, this function requires an\n *   explicit type parameter. Use this when you need precise control over the\n *   plugin's type structure or when type inference doesn't provide the desired\n *   result.\n */\nexport function createTSlatePlugin<C extends AnyPluginConfig = PluginConfig>(\n  config:\n    | ((editor: SlateEditor) => TSlatePluginConfig<C>)\n    | TSlatePluginConfig<C> = {}\n): SlatePlugin<C> {\n  return createSlatePlugin(config as any) as any;\n}\n","import type { SlateEditor } from '../editor';\nimport type { AnyPluginConfig, WithRequiredKey } from './BasePlugin';\nimport type {\n  InferConfig,\n  SlatePlugin,\n  SlatePluginContext,\n} from './SlatePlugin';\n\nexport function getEditorPlugin<\n  P extends AnyPluginConfig | SlatePlugin<AnyPluginConfig>,\n>(\n  editor: SlateEditor,\n  p: WithRequiredKey<P>\n): SlatePluginContext<InferConfig<P> extends never ? P : InferConfig<P>> {\n  const plugin = editor.getPlugin(p) as any;\n\n  return {\n    api: editor.api,\n    editor,\n    plugin: plugin as any,\n    setOption: ((keyOrOptions: any, value: any) =>\n      editor.setOption(plugin, keyOrOptions, value)) as any,\n    setOptions: ((options: any) => editor.setOptions(plugin, options)) as any,\n    tf: editor.transforms,\n    type: plugin.node.type,\n    getOption: (key: any, ...args: any) =>\n      (editor.getOption as any)(plugin, key, ...args),\n    getOptions: () => editor.getOptions(plugin),\n  };\n}\n","import merge from 'lodash/merge.js';\n\nimport type { SlateEditor } from '../../lib/editor';\nimport type { PluginConfig } from '../../lib/plugin/BasePlugin';\nimport type { AnySlatePlugin, SlatePlugin } from '../../lib/plugin/SlatePlugin';\n\nimport { getEditorPlugin } from '../../lib/plugin/getEditorPlugin';\nimport { mergePlugins } from '../utils/mergePlugins';\n\n/**\n * Resolves and finalizes a plugin configuration for use in a Plate editor.\n *\n * This function processes a given plugin configuration, applying any extensions\n * and resolving nested plugins. It prepares the plugin for integration into the\n * Plate editor system by:\n *\n * 1. Cloning the plugin to avoid mutating the original\n * 2. Applying all stored extensions to the plugin\n * 3. Clearing the extensions array after application\n *\n * @example\n *   const plugin = createSlatePlugin({ key: 'myPlugin', ...otherOptions }).extend(...);\n *   const resolvedPlugin = resolvePlugin(editor, plugin);\n */\nexport const resolvePlugin = <P extends AnySlatePlugin>(\n  editor: SlateEditor,\n  _plugin: P\n): P => {\n  // Create a deep clone of the plugin\n  let plugin = mergePlugins({}, _plugin) as P;\n\n  plugin.__resolved = true;\n\n  // Apply the stored configuration first\n  if (plugin.__configuration) {\n    const configResult = plugin.__configuration(\n      getEditorPlugin(editor, plugin as any)\n    );\n\n    plugin = mergePlugins(plugin, configResult);\n\n    delete (plugin as any).__configuration;\n  }\n  // Apply all stored extensions\n  if (plugin.__extensions && plugin.__extensions.length > 0) {\n    plugin.__extensions.forEach((extension) => {\n      plugin = mergePlugins(\n        plugin,\n        extension(getEditorPlugin(editor, plugin as any))\n      );\n    });\n    plugin.__extensions = [];\n  }\n\n  const targetPluginToInject = plugin.inject?.targetPluginToInject;\n  const targetPlugins = plugin.inject?.targetPlugins;\n\n  if (targetPluginToInject && targetPlugins && targetPlugins.length > 0) {\n    plugin.inject = plugin.inject || {};\n    plugin.inject.plugins = merge(\n      {},\n      plugin.inject.plugins,\n      Object.fromEntries(\n        targetPlugins.map((targetPlugin) => {\n          const injectedPlugin = targetPluginToInject({\n            ...getEditorPlugin(editor, plugin as any),\n            targetPlugin,\n          });\n\n          return [targetPlugin, injectedPlugin];\n        })\n      )\n    );\n  }\n  // TODO React\n  if ((plugin as any).node?.component) {\n    (plugin as any).render.node = (plugin as any).node.component;\n  }\n  if ((plugin as any).render?.node) {\n    (plugin as any).node.component = (plugin as any).render.node;\n  }\n\n  validatePlugin(editor, plugin);\n\n  return plugin;\n};\n\nexport const validatePlugin = <\n  K extends string = any,\n  O = {},\n  A = {},\n  T = {},\n  S = {},\n>(\n  editor: SlateEditor,\n  plugin: SlatePlugin<PluginConfig<K, O, A, T, S>>\n) => {\n  if (!plugin.__extensions) {\n    editor.api.debug.error(\n      `Invalid plugin '${plugin.key}', you should use createSlatePlugin.`,\n      'USE_CREATE_PLUGIN'\n    );\n  }\n  if (plugin.node.isElement && plugin.node.isLeaf) {\n    editor.api.debug.error(\n      `Plugin ${plugin.key} cannot be both an element and a leaf.`,\n      'PLUGIN_NODE_TYPE'\n    );\n  }\n};\n","import type { SlateEditor } from '../editor';\nimport type {\n  AnyPluginConfig,\n  PluginConfig,\n  WithRequiredKey,\n} from './BasePlugin';\nimport type { AnySlatePlugin, SlatePlugin } from './SlatePlugin';\n\nimport { resolvePlugin } from '../../internal/plugin/resolvePlugin';\nimport { createSlatePlugin } from './createSlatePlugin';\n\n/** Get editor plugin by key or plugin object. */\nexport function getSlatePlugin<C extends AnyPluginConfig = PluginConfig>(\n  editor: SlateEditor,\n  p: WithRequiredKey<C>\n): C extends { node: any } ? C : SlatePlugin<C> {\n  let plugin = p as any;\n\n  const editorPlugin = editor.plugins[p.key] as any;\n\n  if (!editorPlugin) {\n    // When passing only { key }\n    if (!plugin.node) {\n      plugin = createSlatePlugin(plugin);\n    }\n\n    // Resolve is need when passing an external plugin with extensions (e.g. in withLink)\n    return plugin.__resolved ? plugin : resolvePlugin(editor, plugin);\n  }\n\n  return editorPlugin;\n}\n\n/** Get editor plugin type by key or plugin object. */\nexport function getPluginType(\n  editor: SlateEditor,\n  plugin: WithRequiredKey\n): string {\n  const p = editor.getPlugin<AnySlatePlugin>(plugin);\n\n  return p.node.type ?? p.key ?? '';\n}\n\n/** Get editor plugin types by key. */\nexport const getPluginTypes = (\n  editor: SlateEditor,\n  plugins: WithRequiredKey[]\n) => plugins.map((plugin) => editor.getType(plugin));\n","import type { SlateEditor } from '../../lib/editor';\n\nimport { getEditorPlugin } from '../../lib/plugin';\n\n/** Normalize initial value from editor plugins. Set into plate store if diff. */\nexport const pipeNormalizeInitialValue = (editor: SlateEditor) => {\n  editor.pluginList.forEach((p) => {\n    p.normalizeInitialValue?.({\n      ...getEditorPlugin(editor, p),\n      value: editor.children,\n    } as any);\n  });\n};\n","import {\n  assignLegacyApi,\n  assignLegacyTransforms,\n  syncLegacyMethods,\n} from '@udecode/slate';\nimport { isDefined } from '@udecode/utils';\nimport merge from 'lodash/merge.js';\nimport { createZustandStore } from 'zustand-x';\n\nimport type { SlateEditor } from '../../lib/editor';\n\nimport {\n  type SlatePlugin,\n  type SlatePlugins,\n  getEditorPlugin,\n} from '../../lib/plugin';\nimport { mergePlugins } from '../utils/mergePlugins';\nimport { resolvePlugin } from './resolvePlugin';\n\n/**\n * Initialize and configure the editor's plugin system. This function sets up\n * the editor's plugins, resolving core and custom plugins, and applying any\n * overrides specified in the plugins.\n */\nexport const resolvePlugins = (\n  editor: SlateEditor,\n  plugins: SlatePlugins = []\n) => {\n  editor.pluginList = [];\n  editor.plugins = {};\n  editor.shortcuts = {} as any;\n\n  const resolvedPlugins = resolveAndSortPlugins(editor, plugins);\n\n  applyPluginsToEditor(editor, resolvedPlugins);\n\n  resolvePluginOverrides(editor);\n\n  resolvePluginStores(editor);\n\n  // extendEditor\n  editor.pluginList.forEach((plugin) => {\n    if (plugin.extendEditor) {\n      editor = plugin.extendEditor(getEditorPlugin(editor, plugin) as any);\n\n      // Sync any editor methods that were modified by extendEditor\n      syncLegacyMethods(editor);\n    }\n\n    // Sync overridden plugin methods to legacy editor methods\n    resolvePluginMethods(editor, plugin);\n  });\n\n  resolvePluginShortcuts(editor);\n\n  return editor;\n};\n\nconst resolvePluginStores = (editor: SlateEditor) => {\n  // Create zustand stores for each plugin\n  editor.pluginList.forEach((plugin) => {\n    let store = createZustandStore(plugin.options, {\n      mutative: true,\n      name: plugin.key,\n    });\n\n    // Apply option extensions\n    if (\n      (plugin as any).__selectorExtensions &&\n      (plugin as any).__selectorExtensions.length > 0\n    ) {\n      (plugin as any).__selectorExtensions.forEach((extension: any) => {\n        const extendedOptions = extension(getEditorPlugin(editor, plugin));\n\n        store = store.extendSelectors(() => extendedOptions);\n      });\n    }\n\n    plugin.optionsStore = store;\n  });\n};\n\nconst resolvePluginMethods = (editor: SlateEditor, plugin: any) => {\n  // Merge APIs\n  Object.entries(plugin.api).forEach(([apiKey, apiFunction]) => {\n    (editor.api as any)[apiKey] = apiFunction;\n  });\n\n  // Apply API and transform extensions\n  if (plugin.__apiExtensions && plugin.__apiExtensions.length > 0) {\n    plugin.__apiExtensions.forEach(\n      ({ extension, isOverride, isPluginSpecific, isTransform }: any) => {\n        const newExtensions = extension(getEditorPlugin(editor, plugin) as any);\n\n        if (isOverride) {\n          // Handle combined API and transforms override\n          if (newExtensions.api) {\n            merge(editor.api, newExtensions.api);\n            merge(plugin.api, newExtensions.api);\n            assignLegacyApi(editor, editor.api);\n          }\n          if (newExtensions.transforms) {\n            merge(editor.transforms, newExtensions.transforms);\n            merge(plugin.transforms, newExtensions.transforms);\n            assignLegacyTransforms(editor, newExtensions.transforms);\n          }\n        } else if (isTransform) {\n          // Handle transforms\n          if (isPluginSpecific) {\n            // Plugin-specific transform\n            if (!(editor.transforms as any)[plugin.key]) {\n              (editor.transforms as any)[plugin.key] = {};\n            }\n            if (!(plugin.transforms as any)[plugin.key]) {\n              (plugin.transforms as any)[plugin.key] = {};\n            }\n\n            merge((editor.transforms as any)[plugin.key], newExtensions);\n            merge((plugin.transforms as any)[plugin.key], newExtensions);\n          } else {\n            // Editor-wide transform\n            merge(editor.transforms, newExtensions);\n            merge(plugin.transforms, newExtensions);\n            assignLegacyTransforms(editor, newExtensions);\n          }\n        } else {\n          // Handle APIs\n          if (isPluginSpecific) {\n            // Plugin-specific API\n            if (!(editor.api as any)[plugin.key]) {\n              (editor.api as any)[plugin.key] = {};\n            }\n            if (!(plugin.api as any)[plugin.key]) {\n              (plugin.api as any)[plugin.key] = {};\n            }\n\n            merge((editor.api as any)[plugin.key], newExtensions);\n            merge((plugin.api as any)[plugin.key], newExtensions);\n          } else {\n            // Editor-wide API\n            merge(editor.api, newExtensions);\n            merge(plugin.api, newExtensions);\n            assignLegacyApi(editor, editor.api);\n          }\n        }\n      }\n    );\n    delete plugin.__apiExtensions;\n  }\n};\n\nconst resolvePluginShortcuts = (editor: SlateEditor) => {\n  const shortcutsByPriority: any[] = [];\n\n  editor.pluginList.forEach((plugin) => {\n    // Merge shortcuts\n    Object.entries(plugin.shortcuts).forEach(([key, hotkey]) => {\n      if (hotkey === null) {\n        // Remove any existing hotkey with this key\n        const index = shortcutsByPriority.findIndex((item) => item.key === key);\n\n        if (index !== -1) {\n          shortcutsByPriority.splice(index, 1);\n        }\n      } else {\n        const priority = (hotkey as any).priority ?? plugin.priority;\n        const existingIndex = shortcutsByPriority.findIndex(\n          (item) => item.key === key\n        );\n\n        if (\n          existingIndex === -1 ||\n          priority >= shortcutsByPriority[existingIndex].priority\n        ) {\n          if (existingIndex !== -1) {\n            shortcutsByPriority.splice(existingIndex, 1);\n          }\n\n          shortcutsByPriority.push({ key, hotkey, priority });\n        }\n      }\n    });\n  });\n\n  // Sort shortcuts by priority (descending)\n  shortcutsByPriority.sort((a, b) => b.hotkey.priority - a.hotkey.priority);\n\n  // After processing all plugins, set the final shortcuts on the editor\n  editor.shortcuts = Object.fromEntries(\n    shortcutsByPriority.map(({ key, hotkey }) => {\n      const { priority, ...hotkeyWithoutPriority } = hotkey;\n\n      return [key, hotkeyWithoutPriority];\n    })\n  );\n};\n\nconst flattenAndResolvePlugins = (\n  editor: SlateEditor,\n  plugins: SlatePlugins\n): Map<string, SlatePlugin> => {\n  const pluginMap = new Map<string, SlatePlugin>();\n\n  const processPlugin = (plugin: SlatePlugin) => {\n    const resolvedPlugin = resolvePlugin(editor, plugin);\n    const existingPlugin = pluginMap.get(resolvedPlugin.key);\n\n    if (existingPlugin) {\n      pluginMap.set(\n        resolvedPlugin.key,\n        mergePlugins(existingPlugin, resolvedPlugin)\n      );\n    } else {\n      pluginMap.set(resolvedPlugin.key, resolvedPlugin);\n    }\n    if (resolvedPlugin.plugins && resolvedPlugin.plugins.length > 0) {\n      resolvedPlugin.plugins.forEach(processPlugin);\n    }\n  };\n\n  plugins.forEach(processPlugin);\n\n  return pluginMap;\n};\n\nexport const resolveAndSortPlugins = (\n  editor: SlateEditor,\n  plugins: SlatePlugins\n): SlatePlugins => {\n  // Step 1: Resolve, flatten, and merge all plugins\n  const pluginMap = flattenAndResolvePlugins(editor, plugins);\n\n  // Step 2: Filter out disabled plugins\n  const enabledPlugins = Array.from(pluginMap.values()).filter(\n    (plugin) => plugin.enabled !== false\n  );\n\n  // Step 3: Sort plugins by priority\n  enabledPlugins.sort((a, b) => b.priority - a.priority);\n\n  // Step 4: Reorder based on dependencies\n  const orderedPlugins: SlatePlugins = [];\n  const visited = new Set<string>();\n\n  const visit = (plugin: SlatePlugin) => {\n    if (visited.has(plugin.key)) return;\n\n    visited.add(plugin.key);\n\n    plugin.dependencies?.forEach((depKey) => {\n      const depPlugin = pluginMap.get(depKey);\n\n      if (depPlugin) {\n        visit(depPlugin);\n      } else {\n        editor.api.debug.warn(\n          `Plugin \"${plugin.key}\" depends on missing plugin \"${depKey}\"`,\n          'PLUGIN_DEPENDENCY_MISSING'\n        );\n      }\n    });\n\n    orderedPlugins.push(plugin);\n  };\n\n  enabledPlugins.forEach(visit);\n\n  return orderedPlugins;\n};\n\nexport const applyPluginsToEditor = (\n  editor: SlateEditor,\n  plugins: SlatePlugins\n) => {\n  editor.pluginList = plugins;\n  editor.plugins = Object.fromEntries(\n    plugins.map((plugin) => [plugin.key, plugin])\n  );\n};\n\nexport const resolvePluginOverrides = (editor: SlateEditor) => {\n  const applyOverrides = (plugins: SlatePlugin[]): SlatePlugin[] => {\n    let overriddenPlugins = [...plugins];\n\n    const enabledOverrides: Record<string, boolean> = {};\n    const componentOverrides: Record<\n      string,\n      { component: any; priority: number }\n    > = {};\n    const pluginOverrides: Record<string, Partial<SlatePlugin>> = {};\n\n    // Collect all overrides\n    for (const plugin of plugins) {\n      if (plugin.override.enabled) {\n        Object.assign(enabledOverrides, plugin.override.enabled);\n      }\n      // TODO react\n      if ((plugin.override as any).components) {\n        Object.entries((plugin.override as any).components).forEach(\n          ([key, component]) => {\n            if (\n              !componentOverrides[key] ||\n              plugin.priority > componentOverrides[key].priority\n            ) {\n              componentOverrides[key] = {\n                component,\n                priority: plugin.priority,\n              };\n            }\n          }\n        );\n      }\n      if (plugin.override.plugins) {\n        Object.entries(plugin.override.plugins).forEach(([key, value]) => {\n          pluginOverrides[key] = mergePlugins(pluginOverrides[key], value);\n\n          if (value.enabled !== undefined) {\n            enabledOverrides[key] = value.enabled;\n          }\n        });\n      }\n    }\n\n    // Apply overrides\n    overriddenPlugins = overriddenPlugins.map((p) => {\n      let updatedPlugin = { ...p };\n\n      // Apply plugin overrides\n      if (pluginOverrides[p.key]) {\n        updatedPlugin = mergePlugins(updatedPlugin, pluginOverrides[p.key]);\n      }\n      // Apply component overrides\n      // TODO react\n      if (\n        componentOverrides[p.key] &&\n        ((!(p as any).render.node && !(p as any).node.component) ||\n          componentOverrides[p.key].priority > p.priority)\n      ) {\n        (updatedPlugin as any).render.node =\n          componentOverrides[p.key].component;\n        (updatedPlugin as any).node.component =\n          componentOverrides[p.key].component;\n      }\n\n      // Apply enabled overrides\n      const enabled = enabledOverrides[p.key] ?? updatedPlugin.enabled;\n\n      if (isDefined(enabled)) {\n        updatedPlugin.enabled = enabled;\n      }\n\n      return updatedPlugin;\n    });\n\n    return overriddenPlugins\n      .filter((p) => p.enabled !== false)\n      .map((plugin) => ({\n        ...plugin,\n        plugins: applyOverrides(plugin.plugins || []),\n      }));\n  };\n\n  editor.pluginList = applyOverrides(editor.pluginList as any);\n  editor.plugins = Object.fromEntries(\n    editor.pluginList.map((plugin) => [plugin.key, plugin])\n  );\n};\n","import { createSlatePlugin } from '../plugin';\n\n/**\n * Enables support for deserializing inserted content from Slate Ast format to\n * Slate format while apply a small bug fix.\n */\nexport const AstPlugin = createSlatePlugin({\n  key: 'ast',\n  parser: {\n    format: 'application/x-slate-fragment',\n    deserialize: ({ data }) => {\n      const decoded = decodeURIComponent(window.atob(data));\n      let parsed;\n\n      try {\n        parsed = JSON.parse(decoded);\n      } catch {\n        /* empty */\n      }\n\n      return parsed;\n    },\n  },\n});\n","import { createSlatePlugin } from '../plugin';\n\n/**\n * Placeholder plugin for DOM interaction, that could be replaced with\n * ReactPlugin.\n */\nexport const DOMPlugin = createSlatePlugin({\n  key: 'dom',\n});\n","import { withHistory } from '@udecode/slate';\n\nimport type { SlateEditor } from '../editor';\n\nimport { type ExtendEditor, createSlatePlugin } from '../plugin';\n\nexport const withPlateHistory: ExtendEditor = ({ editor }) =>\n  withHistory(editor as any) as any as SlateEditor;\n\n/** @see {@link withHistory} */\nexport const HistoryPlugin = createSlatePlugin({\n  key: 'history',\n  extendEditor: withPlateHistory,\n});\n","import { type OverrideEditor, createSlatePlugin } from '../plugin';\n\n/**\n * Merge and register all the inline types and void types from the plugins and\n * options, using `editor.api.isInline`, `editor.api.markableVoid` and\n * `editor.api.isVoid`\n */\nexport const withInlineVoid: OverrideEditor = ({\n  api: { isInline, isSelectable, isVoid, markableVoid },\n  editor,\n}) => {\n  const voidTypes: string[] = [];\n  const inlineTypes: string[] = [];\n  const markableVoidTypes: string[] = [];\n  const nonSelectableTypes: string[] = [];\n\n  editor.pluginList.forEach((plugin) => {\n    if (plugin.node.isInline) {\n      inlineTypes.push(plugin.node.type);\n    }\n    if (plugin.node.isVoid) {\n      voidTypes.push(plugin.node.type);\n    }\n    if (plugin.node.isMarkableVoid) {\n      markableVoidTypes.push(plugin.node.type);\n    }\n    if (plugin.node.isSelectable === false) {\n      nonSelectableTypes.push(plugin.node.type);\n    }\n  });\n\n  return {\n    api: {\n      isInline(element) {\n        return inlineTypes.includes(element.type as any)\n          ? true\n          : isInline(element);\n      },\n      isSelectable(element) {\n        return nonSelectableTypes.includes(element.type)\n          ? false\n          : isSelectable(element);\n      },\n      isVoid(element) {\n        return voidTypes.includes(element.type as any) ? true : isVoid(element);\n      },\n      markableVoid(element) {\n        return markableVoidTypes.includes(element.type)\n          ? true\n          : markableVoid(element);\n      },\n    },\n  };\n};\n\n/** @see {@link withInlineVoid} */\nexport const InlineVoidPlugin = createSlatePlugin({\n  key: 'inlineVoid',\n}).overrideEditor(withInlineVoid);\n","import type { Descendant } from '@udecode/slate';\n\nimport type { SlateEditor } from '../../lib/editor';\nimport type { ParserOptions } from '../../lib/plugin/BasePlugin';\nimport type { AnyEditorPlugin } from '../../lib/plugin/SlatePlugin';\n\nimport { getEditorPlugin } from '../../lib/plugin';\n\n/** Pipe preInsert then insertFragment. */\nexport const pipeInsertFragment = (\n  editor: SlateEditor,\n  injectedPlugins: Partial<AnyEditorPlugin>[],\n  { fragment, ...options }: ParserOptions & { fragment: Descendant[] }\n) => {\n  editor.tf.withoutNormalizing(() => {\n    injectedPlugins.some((p) => {\n      return (\n        p.parser?.preInsert?.({\n          ...getEditorPlugin(editor, p as any),\n          fragment,\n          ...options,\n        }) === true\n      );\n    });\n\n    editor.tf.insertFragment(fragment);\n  });\n};\n","import type { SlateEditor } from '../../lib/editor';\nimport type { ParserOptions } from '../../lib/plugin/BasePlugin';\nimport type { AnyEditorPlugin } from '../../lib/plugin/SlatePlugin';\n\nimport { getEditorPlugin } from '../../lib/plugin';\n\n/** Pipe editor.tf.insertData.transformData */\nexport const pipeTransformData = (\n  editor: SlateEditor,\n  plugins: Partial<AnyEditorPlugin>[],\n  { data, dataTransfer }: ParserOptions\n) => {\n  plugins.forEach((p) => {\n    const transformData = p.parser?.transformData;\n\n    if (!transformData) return;\n\n    data = transformData({\n      ...getEditorPlugin(editor, p as any),\n      data,\n      dataTransfer,\n    });\n  });\n\n  return data;\n};\n","import type { Descendant } from '@udecode/slate';\n\nimport type { SlateEditor } from '../../lib/editor';\nimport type { ParserOptions } from '../../lib/plugin/BasePlugin';\nimport type { AnyEditorPlugin } from '../../lib/plugin/SlatePlugin';\n\nimport { getEditorPlugin } from '../../lib/plugin';\n\n/** Pipe editor.tf.insertData.transformFragment */\nexport const pipeTransformFragment = (\n  editor: SlateEditor,\n  plugins: Partial<AnyEditorPlugin>[],\n  { fragment, ...options }: ParserOptions & { fragment: Descendant[] }\n) => {\n  plugins.forEach((p) => {\n    const transformFragment = p.parser?.transformFragment;\n\n    if (!transformFragment) return;\n\n    fragment = transformFragment({\n      fragment,\n      ...options,\n      ...getEditorPlugin(editor, p as any),\n    });\n  });\n\n  return fragment;\n};\n","import {\n  type NodeEntry,\n  type NodeOf,\n  type Path,\n  type QueryNodeOptions,\n  type TNode,\n  NodeApi,\n  queryNode,\n} from '@udecode/slate';\n\nexport interface ApplyDeepToNodesOptions<N extends TNode> {\n  // Function to call on each node following the query.\n  apply: (\n    node: NodeOf<N>,\n    source: (() => Record<string, any>) | Record<string, any>\n  ) => void;\n  // The destination node object.\n  node: N;\n  // The source object. Can be a factory.\n  source: (() => Record<string, any>) | Record<string, any>;\n  path?: Path;\n  // Query to filter the nodes.\n  query?: QueryNodeOptions;\n}\n\n/** Recursively apply an operation to children nodes with a query. */\nexport const applyDeepToNodes = <N extends TNode>({\n  apply,\n  node,\n  path = [],\n  query,\n  source,\n}: ApplyDeepToNodesOptions<N>) => {\n  const entry: NodeEntry<N> = [node, path];\n\n  if (queryNode<N>(entry, query)) {\n    if (source instanceof Function) {\n      apply(node, source());\n    } else {\n      apply(node, source);\n    }\n  }\n  if (!NodeApi.isAncestor(node)) return;\n\n  node.children.forEach((child, index) => {\n    applyDeepToNodes({\n      apply,\n      node: child as any,\n      path: path.concat([index]),\n      query,\n      source,\n    });\n  });\n};\n","import type { TNode } from '@udecode/slate';\n\nimport defaults from 'lodash/defaults.js';\n\nimport {\n  type ApplyDeepToNodesOptions,\n  applyDeepToNodes,\n} from './applyDeepToNodes';\n\n/** Recursively merge a source object to children nodes with a query. */\nexport const defaultsDeepToNodes = <N extends TNode>(\n  options: Omit<ApplyDeepToNodesOptions<N>, 'apply'>\n) => {\n  applyDeepToNodes({ ...options, apply: defaults });\n};\n","import { type Path, type TNode, ElementApi } from '@udecode/slate';\n\nimport type { SlateEditor } from '../editor';\nimport type { EditorPlugin } from '../plugin';\n\nimport { getKeyByType, getKeysByTypes } from './getKeysByTypes';\n\nexport const getInjectMatch = <E extends SlateEditor>(\n  editor: E,\n  plugin: EditorPlugin\n) => {\n  return (node: TNode, path: Path) => {\n    const {\n      inject: {\n        excludeBelowPlugins,\n        excludePlugins,\n        isBlock: _isBlock,\n        isElement: _isElement,\n        isLeaf,\n        maxLevel,\n        targetPlugins,\n      },\n    } = plugin;\n\n    const element = ElementApi.isElement(node) ? node : undefined;\n\n    if (_isElement && !element) return false;\n    if (_isBlock && (!element || !editor.api.isBlock(element))) return false;\n    if (isLeaf && element) return false;\n    if (element?.type) {\n      // Exclude plugins\n      if (excludePlugins?.includes(getKeyByType(editor, element.type))) {\n        return false;\n      }\n      // Target plugins\n      if (\n        targetPlugins &&\n        !targetPlugins.includes(getKeyByType(editor, element.type))\n      ) {\n        return false;\n      }\n    }\n    // Exclude below plugins\n    if (excludeBelowPlugins || maxLevel) {\n      if (maxLevel && path.length > maxLevel) {\n        return false;\n      }\n      if (excludeBelowPlugins) {\n        const excludeTypes = getKeysByTypes(editor, excludeBelowPlugins);\n        const isBelow = editor.api.above({\n          at: path,\n          match: (n) =>\n            ElementApi.isElement(n) && excludeTypes.includes(n.type),\n        });\n\n        if (isBelow) return false;\n      }\n    }\n\n    return true;\n  };\n};\n","import type { SlateEditor } from '../editor';\n\n/** Get plugin keys by types */\nexport const getKeysByTypes = (\n  editor: SlateEditor,\n  types: string[]\n): string[] => {\n  return Object.values(editor.plugins)\n    .filter((plugin) => types.includes(plugin.node.type))\n    .map((plugin) => plugin.key);\n};\n\n/** Get plugin key by type */\nexport const getKeyByType = (editor: SlateEditor, type: string): string => {\n  const plugin = Object.values(editor.plugins).find(\n    (plugin) => plugin.node.type === type\n  );\n\n  return plugin?.key ?? type;\n};\n","import type { SlateEditor } from '../editor';\nimport type { AnyEditorPlugin, SlatePlugins } from '../plugin/SlatePlugin';\n\n/**\n * Get all plugins having a defined `inject.plugins[plugin.key]`. It includes\n * `plugin` itself.\n */\nexport const getInjectedPlugins = (\n  editor: SlateEditor,\n  plugin: AnyEditorPlugin\n): Partial<AnyEditorPlugin>[] => {\n  const injectedPlugins: SlatePlugins = [];\n\n  [...editor.pluginList].reverse().forEach((p) => {\n    const injectedPlugin = p.inject.plugins?.[plugin.key];\n\n    if (injectedPlugin) injectedPlugins.push(injectedPlugin as any);\n  });\n\n  return [plugin, ...injectedPlugins];\n};\n","import type { TElement, TText } from '@udecode/slate';\nimport type { AnyObject } from '@udecode/utils';\n\nimport pick from 'lodash/pick.js';\n\nimport type { AnyEditorPlugin } from '../plugin';\n\nimport { type SlateRenderNodeProps, getNodeDataAttributeKeys } from '../static';\n\nexport const getPluginNodeProps = ({\n  attributes,\n  node,\n  plugin,\n  props,\n}: {\n  props: SlateRenderNodeProps;\n  attributes?: AnyObject;\n  node?: TElement | TText;\n  plugin?: AnyEditorPlugin;\n}): any => {\n  let newProps: AnyObject = {};\n\n  if (plugin?.node.props) {\n    newProps =\n      (typeof plugin.node.props === 'function'\n        ? plugin.node.props(props as any)\n        : plugin.node.props) ?? {};\n  }\n  if (!newProps.nodeProps && attributes && plugin) {\n    /**\n     * WARNING: Improper use of `dangerouslyAllowAttributes` WILL make your\n     * application vulnerable to cross-site scripting (XSS) or information\n     * exposure attacks.\n     *\n     * @see {@link BasePluginNode.dangerouslyAllowAttributes}\n     */\n    newProps.nodeProps = pick(attributes, [\n      ...(plugin.node.dangerouslyAllowAttributes ?? []),\n      ...(node ? getNodeDataAttributeKeys(node) : []),\n    ]);\n  } else if (newProps.nodeProps && attributes && plugin) {\n    // Add data attributes to nodeProps if nodeProps is already set\n    newProps.nodeProps = {\n      ...newProps.nodeProps,\n      ...pick(attributes, [...(node ? getNodeDataAttributeKeys(node) : [])]),\n    };\n  }\n\n  props = { ...props, ...newProps };\n\n  if (props.nodeProps) {\n    // remove attributes values that are undefined\n    Object.keys(props.nodeProps).forEach((key) => {\n      if (props.nodeProps?.[key] === undefined) {\n        delete props.nodeProps?.[key];\n      }\n    });\n  }\n\n  return props;\n};\n","import React from 'react';\n\nimport type { SlateEditor } from '../editor';\nimport type { NodeComponents } from '../plugin';\n\nimport { SlateElement } from './components/SlateElement';\nimport {\n  type SlateRenderElement,\n  pluginRenderElementStatic,\n} from './pluginRenderElementStatic';\n\nexport const pipeRenderElementStatic = (\n  editor: SlateEditor,\n  {\n    components,\n    renderElement: renderElementProp,\n  }: {\n    components: NodeComponents;\n    renderElement?: SlateRenderElement;\n  }\n): SlateRenderElement => {\n  const renderElements: SlateRenderElement[] = [];\n\n  editor.pluginList.forEach((plugin) => {\n    if (plugin.node.isElement) {\n      renderElements.push(\n        pluginRenderElementStatic(editor, plugin, components)\n      );\n    }\n  });\n\n  return function render(props) {\n    let element;\n\n    renderElements.some((renderElement) => {\n      element = renderElement(props as any);\n\n      return !!element;\n    });\n\n    if (element) return element;\n    if (renderElementProp) {\n      return renderElementProp(props);\n    }\n\n    return (\n      <SlateElement\n        attributes={props.attributes}\n        element={props.element}\n        {...({} as any)}\n      >\n        {props.children}\n      </SlateElement>\n    );\n  };\n};\n","import React from 'react';\n\nimport type { TElement } from '@udecode/slate';\n\nimport clsx from 'clsx';\n\nimport type { AnySlatePlugin } from '../../plugin';\nimport type { BoxStaticProps, SlateRenderElementProps } from '../types';\n\nimport { omitPluginContext } from '../../utils';\n\nexport type SlateElementProps<\n  N extends TElement = TElement,\n  P extends AnySlatePlugin = AnySlatePlugin,\n> = {\n  /** Get HTML attributes from Slate element. Alternative to `PlatePlugin.props`. */\n  elementToAttributes?: (element: N) => any;\n} & BoxStaticProps &\n  SlateRenderElementProps<N, P>;\n\nexport const SlateElement = (props: SlateElementProps) => {\n  const { as, attributes, element, elementToAttributes, nodeProps, ...rest } =\n    omitPluginContext(props);\n\n  const block = !!element.id && props.editor.api.isBlock(element);\n\n  const rootProps = {\n    ...attributes,\n    ...rest,\n    ...nodeProps,\n    ...elementToAttributes?.(element),\n    className: clsx(props.className, nodeProps?.className),\n    'data-block-id': block ? element.id : undefined,\n    style: {\n      position: 'relative',\n      ...props.style,\n      ...nodeProps?.style,\n    },\n  };\n\n  const Element = (as ?? 'div') as any;\n\n  return <Element {...rootProps} ref={attributes.ref} />;\n};\n","import React from 'react';\n\nimport type { SlateEditor } from '../editor';\nimport type { AnyEditorPlugin, NodeComponents } from '../plugin';\nimport type { RenderElementProps } from '../types/RenderElementProps';\n\nimport { SlateElement } from './components/SlateElement';\nimport { getPluginDataAttributes } from './utils';\nimport { getRenderNodeStaticProps } from './utils/getRenderNodeStaticProps';\n\nexport type SlateRenderElement = (\n  props: RenderElementProps\n) => React.ReactElement<any> | undefined;\n\nexport const pluginRenderElementStatic = (\n  editor: SlateEditor,\n  plugin: AnyEditorPlugin,\n  components?: NodeComponents\n): SlateRenderElement =>\n  function render(nodeProps) {\n    if (nodeProps.element.type === plugin.node.type) {\n      const element = nodeProps.element;\n\n      const key = plugin.key;\n      const Element: any = components?.[plugin.key] ?? SlateElement;\n\n      let { children } = nodeProps;\n\n      const aboveNodes = editor.pluginList.flatMap(\n        (o) => o.render?.aboveNodes ?? []\n      );\n      const belowNodes = editor.pluginList.flatMap(\n        (o) => o.render?.belowNodes ?? []\n      );\n\n      const dataAttributes = getPluginDataAttributes(editor, plugin, element);\n\n      nodeProps = getRenderNodeStaticProps({\n        attributes: {\n          ...(element.attributes as any),\n          ...dataAttributes,\n        },\n        editor,\n        node: element,\n        plugin,\n        props: nodeProps as any,\n      }) as any;\n\n      belowNodes.forEach((withHOC) => {\n        const hoc = withHOC({ ...nodeProps, key } as any);\n\n        if (hoc) {\n          children = hoc({ ...nodeProps, children } as any);\n        }\n      });\n\n      let component: React.ReactNode = (\n        <Element {...nodeProps}>{children}</Element>\n      );\n\n      aboveNodes.forEach((withHOC) => {\n        const hoc = withHOC({ ...nodeProps, key } as any);\n\n        if (hoc) {\n          component = hoc({ ...nodeProps, children: component } as any);\n        }\n      });\n\n      return component;\n    }\n  };\n","import React from 'react';\n\nexport function createStaticString({ text }: { text: string }) {\n  return React.createElement(\n    'span',\n    { 'data-slate-string': true },\n    text === '' ? '\\uFEFF' : text\n  );\n}\n","import { type TElement, type TText, TextApi } from '@udecode/slate';\nimport kebabCase from 'lodash/kebabCase.js';\n\nimport type { SlateEditor } from '../../editor';\n\nimport { type AnyEditorPlugin, getEditorPlugin } from '../../plugin';\n\nexport const getNodeDataAttributes = (\n  node: TElement | TText,\n  { isElement, isLeaf }: { isElement?: boolean; isLeaf?: boolean }\n) => {\n  const dataAttributes = Object.keys(node).reduce((acc, key) => {\n    if (typeof node[key] === 'object') return acc;\n    if (isElement && key === 'children') return acc;\n    if (isLeaf && key === 'text') return acc;\n\n    const attributeName = keyToDataAttribute(key);\n\n    return {\n      ...acc,\n      [attributeName]: node[key],\n    };\n  }, {});\n\n  return dataAttributes;\n};\n\nexport const getPluginDataAttributes = (\n  editor: SlateEditor,\n  plugin: AnyEditorPlugin,\n  node: TElement | TText\n) => {\n  const isElement = plugin.node.isElement;\n\n  const isLeaf = plugin.node.isLeaf;\n\n  const dataAttributes = getNodeDataAttributes(node, { isElement, isLeaf });\n\n  const customAttributes =\n    plugin.node.toDataAttributes?.({\n      ...(plugin ? (getEditorPlugin(editor, plugin) as any) : {}),\n      node,\n    }) ?? {};\n\n  return { ...dataAttributes, ...customAttributes };\n};\n\nexport const getLeafDataAttributes = (leaf: TText) =>\n  getNodeDataAttributes(leaf, { isElement: false, isLeaf: true });\n\nexport const getNodeDataAttributeKeys = (node: TElement | TText) => {\n  return Object.keys(node)\n    .filter(\n      (key) =>\n        typeof node[key] !== 'object' &&\n        (!TextApi.isText(node) || key !== 'text')\n    )\n    .map((key) => keyToDataAttribute(key));\n};\n\nexport const keyToDataAttribute = (key: string) => {\n  return `data-slate-${kebabCase(key)}`;\n};\n","import type { TElement, TText } from '@udecode/slate';\nimport type { AnyObject } from '@udecode/utils';\n\nimport clsx from 'clsx';\n\nimport type { SlateEditor } from '../../editor';\nimport type { SlateRenderNodeProps } from '../types';\n\nimport { pipeInjectNodeProps } from '../../../internal/plugin/pipeInjectNodeProps';\nimport { type AnyEditorPlugin, getEditorPlugin } from '../../plugin';\nimport { getSlateClass } from '../../utils';\nimport { getPluginNodeProps } from '../../utils/getPluginNodeProps';\n\nexport const getRenderNodeStaticProps = ({\n  attributes,\n  editor,\n  node,\n  plugin,\n  props,\n}: {\n  editor: SlateEditor;\n  props: SlateRenderNodeProps;\n  attributes?: AnyObject;\n  node?: TElement | TText;\n  plugin?: AnyEditorPlugin;\n}): SlateRenderNodeProps => {\n  let nodeProps = {\n    ...props,\n    ...(plugin ? (getEditorPlugin(editor, plugin) as any) : {}),\n  };\n\n  const { className } = props;\n\n  nodeProps = {\n    ...getPluginNodeProps({\n      attributes,\n      node,\n      plugin,\n      props: nodeProps,\n    }),\n    className: clsx(getSlateClass(plugin?.node.type), className),\n  };\n\n  nodeProps = pipeInjectNodeProps(\n    editor,\n    nodeProps,\n    (node) => editor.api.findPath(node)!\n  );\n\n  if (nodeProps.style && Object.keys(nodeProps.style).length === 0) {\n    delete nodeProps.style;\n  }\n\n  return nodeProps;\n};\n","import type { Path, TElement, TText } from '@udecode/slate';\n\nimport clsx from 'clsx';\n\nimport type { SlateEditor } from '../../lib/editor';\n\nimport { pluginInjectNodeProps } from './pluginInjectNodeProps';\n\n/** Inject plugin props, editor. */\nexport const pipeInjectNodeProps = (\n  editor: SlateEditor,\n  nodeProps: any,\n  getElementPath: (node: TElement | TText) => Path\n) => {\n  editor.pluginList.forEach((plugin) => {\n    if (plugin.inject.nodeProps) {\n      const newProps = pluginInjectNodeProps(\n        editor,\n        plugin,\n        nodeProps,\n        getElementPath\n      );\n\n      if (!newProps) return;\n\n      nodeProps = {\n        ...nodeProps,\n        ...newProps,\n        className: clsx(nodeProps.className, newProps.className),\n        style: {\n          ...nodeProps.style,\n          ...newProps.style,\n        },\n      };\n    }\n  });\n\n  return nodeProps;\n};\n","import type { Path, TElement, TText } from '@udecode/slate';\n\nimport { isDefined } from '@udecode/utils';\n\nimport type { SlateEditor } from '../../lib/editor';\nimport type {\n  EditorPlugin,\n  TransformOptions,\n} from '../../lib/plugin/SlatePlugin';\n\nimport {\n  type GetInjectNodePropsOptions,\n  type GetInjectNodePropsReturnType,\n  getEditorPlugin,\n} from '../../lib/plugin';\nimport { getInjectMatch } from '../../lib/utils/getInjectMatch';\n\n/**\n * Return if `element`, `text`, `nodeKey` is defined. Return if `node.type` is\n * not in `targetPlugins` (if defined). Return if `value = node[nodeKey]` is not\n * in `validNodeValues` (if defined). If `classNames[value]` is defined,\n * override `className` with it. If `styleKey` is defined, override `style` with\n * `[styleKey]: value`.\n */\nexport const pluginInjectNodeProps = (\n  editor: SlateEditor,\n  plugin: EditorPlugin,\n  nodeProps: GetInjectNodePropsOptions,\n  getElementPath: (node: TElement | TText) => Path\n): GetInjectNodePropsReturnType | undefined => {\n  const {\n    key,\n    inject: { nodeProps: injectNodeProps },\n  } = plugin;\n\n  const { element, text } = nodeProps;\n\n  const node = element ?? text;\n\n  if (!node) return;\n  if (!injectNodeProps) return;\n\n  const {\n    classNames,\n    defaultNodeValue,\n    nodeKey = key,\n    query,\n    styleKey = nodeKey as any,\n    transformClassName,\n    transformNodeValue,\n    transformProps,\n    transformStyle,\n    validNodeValues,\n  } = injectNodeProps;\n\n  const injectMatch = getInjectMatch(editor, plugin);\n\n  if (!injectMatch(node, getElementPath(node))) return;\n\n  const queryResult = query?.({\n    ...injectNodeProps,\n    ...(getEditorPlugin(editor, plugin) as any),\n    nodeProps,\n  });\n\n  if (query && !queryResult) {\n    return;\n  }\n\n  const nodeValue = node[nodeKey!] as any;\n\n  // early return if there is no reason to inject props\n  if (\n    !transformProps &&\n    (!isDefined(nodeValue) ||\n      (validNodeValues && !validNodeValues.includes(nodeValue)) ||\n      nodeValue === defaultNodeValue)\n  ) {\n    return;\n  }\n\n  const transformOptions: TransformOptions = {\n    ...nodeProps,\n    ...(getEditorPlugin(editor, plugin) as any),\n    nodeValue,\n  };\n  const value = transformNodeValue?.(transformOptions) ?? nodeValue;\n  transformOptions.value = value;\n\n  let newProps: GetInjectNodePropsReturnType = {};\n\n  if (element && nodeKey) {\n    newProps.className = `slate-${nodeKey}-${nodeValue}`;\n  }\n  if (classNames?.[nodeValue] || transformClassName) {\n    newProps.className =\n      transformClassName?.(transformOptions) ?? classNames?.[value];\n  }\n  if (styleKey) {\n    newProps.style =\n      transformStyle?.(transformOptions) ??\n      ({\n        [styleKey as string]: value,\n      } as any);\n  }\n  if (transformProps) {\n    newProps =\n      transformProps({ ...transformOptions, props: newProps }) ?? newProps;\n  }\n\n  return newProps;\n};\n","import type { NodeEntry, TRange } from '@udecode/slate';\n\nimport type { SlateEditor } from '../../editor';\nimport type { EditableProps } from '../../types/EditableProps';\n\nimport { getEditorPlugin } from '../../plugin';\n\n/**\n * @see {@link Decorate} .\n * Optimization: return undefined if empty list so Editable uses a memo.\n */\nexport const pipeDecorate = (\n  editor: SlateEditor,\n  decorateProp?:\n    | ((ctx: { editor: SlateEditor; entry: NodeEntry }) => TRange[] | undefined)\n    | null\n): EditableProps['decorate'] => {\n  const relevantPlugins = editor.pluginList.filter((plugin) => plugin.decorate);\n\n  if (relevantPlugins.length === 0 && !decorateProp) return;\n\n  return (entry: NodeEntry) => {\n    let ranges: TRange[] = [];\n\n    const addRanges = (newRanges?: TRange[]) => {\n      if (newRanges?.length) ranges = [...ranges, ...newRanges];\n    };\n\n    relevantPlugins.forEach((plugin) => {\n      addRanges(\n        plugin.decorate!({\n          ...(getEditorPlugin(editor, plugin) as any),\n          entry,\n        })\n      );\n    });\n\n    if (decorateProp) {\n      addRanges(\n        decorateProp({\n          editor,\n          entry,\n        })\n      );\n    }\n\n    return ranges;\n  };\n};\n","const classAttrRegExp = / class=\"([^\"]*)\"/g;\n\n/**\n * Remove all class names that do not start with one of preserveClassNames\n * (`slate-` by default)\n */\nexport const stripHtmlClassNames = (\n  html: string,\n  { preserveClassNames = ['slate-'] }: { preserveClassNames?: string[] }\n) => {\n  if (preserveClassNames.length === 0) {\n    return html.replaceAll(classAttrRegExp, '');\n  }\n\n  const preserveRegExp = new RegExp(\n    preserveClassNames.map((cn) => `^${cn}`).join('|')\n  );\n\n  return html.replaceAll(\n    classAttrRegExp,\n    (match: string, className: string) => {\n      const classesToKeep = className\n        .split(/\\s+/)\n        .filter((cn) => preserveRegExp.test(cn));\n\n      return classesToKeep.length === 0\n        ? ''\n        : ` class=\"${classesToKeep.join(' ')}\"`;\n    }\n  );\n};\n","// Remove redundant data attributes\nexport const stripSlateDataAttributes = (rawHtml: string): string =>\n  rawHtml\n    .replaceAll(/ data-slate(?:-node|-type|-leaf|-string)=\"[^\"]+\"/g, '')\n    .replaceAll(/ data-testid=\"[^\"]+\"/g, '');\n","import React from 'react';\n\nimport type { SlateEditor } from '../editor';\nimport type { NodeComponents, SlatePlugin } from '../plugin';\nimport type { RenderLeafProps } from '../types/RenderLeafProps';\n\nimport { SlateLeaf } from './components/SlateLeaf';\nimport {\n  getLeafDataAttributes,\n  getPluginDataAttributes,\n} from './utils/getNodeDataAttributes';\nimport { getRenderNodeStaticProps } from './utils/getRenderNodeStaticProps';\n\nexport type SlateRenderLeaf = (\n  props: RenderLeafProps\n) => React.ReactElement<any> | undefined;\n\nexport const pluginRenderLeafStatic = (\n  editor: SlateEditor,\n  plugin: SlatePlugin,\n  components: NodeComponents\n): SlateRenderLeaf =>\n  function render(nodeProps) {\n    const { children, leaf } = nodeProps;\n\n    if (leaf[plugin.node.type ?? plugin.key]) {\n      const Leaf = components?.[plugin.key] ?? SlateLeaf;\n\n      const dataAttributes = getPluginDataAttributes(editor, plugin, leaf);\n\n      const ctxProps = getRenderNodeStaticProps({\n        attributes: {\n          ...(leaf.attributes as any),\n          ...dataAttributes,\n        },\n        editor,\n        node: leaf,\n        plugin,\n        props: nodeProps as any,\n      }) as any;\n\n      return <Leaf {...ctxProps}>{children}</Leaf>;\n    }\n\n    return children;\n  };\n\n/** @see {@link RenderLeaf} */\nexport const pipeRenderLeafStatic = (\n  editor: SlateEditor,\n  {\n    components,\n    renderLeaf: renderLeafProp,\n  }: {\n    components: NodeComponents;\n    renderLeaf?: SlateRenderLeaf;\n  }\n): SlateRenderLeaf => {\n  const renderLeafs: SlateRenderLeaf[] = [];\n\n  editor.pluginList.forEach((plugin) => {\n    if (plugin.node.isLeaf && plugin.key) {\n      renderLeafs.push(pluginRenderLeafStatic(editor, plugin, components));\n    }\n  });\n\n  return function render(props) {\n    renderLeafs.forEach((renderLeaf) => {\n      const newChildren = renderLeaf(props as any);\n\n      if (newChildren !== undefined) {\n        props.children = newChildren;\n      }\n    });\n\n    if (renderLeafProp) {\n      return renderLeafProp(props);\n    }\n\n    const ctxProps = getRenderNodeStaticProps({\n      attributes: props.attributes as any,\n      editor,\n      props: props as any,\n    }) as any;\n\n    const leaf = ctxProps.leaf;\n\n    const dataAttributes = getLeafDataAttributes(leaf);\n\n    return <SlateLeaf {...ctxProps} {...dataAttributes} />;\n  };\n};\n","import React from 'react';\n\nimport type { DecoratedRange, TText } from '@udecode/slate';\n\nimport clsx from 'clsx';\n\nimport type { AnySlatePlugin } from '../../plugin';\nimport type { SlateRenderLeafProps, TextStaticProps } from '../types';\n\nimport { omitPluginContext } from '../../utils';\n\nexport type SlateLeafProps<\n  T extends TText = TText,\n  P extends AnySlatePlugin = AnySlatePlugin,\n> = {\n  decorations?: DecoratedRange[];\n  /** Get HTML attributes from Slate leaf. Alternative to `PlatePlugin.props`. */\n  leafToAttributes?: (leaf: T) => any;\n} & SlateRenderLeafProps<T, P> &\n  TextStaticProps;\n\nexport function SlateLeaf(props: SlateLeafProps) {\n  const { as, attributes, leaf, leafToAttributes, nodeProps, text, ...rest } =\n    omitPluginContext(props);\n\n  const rootProps = {\n    ...attributes,\n    ...rest,\n    ...nodeProps,\n    ...leafToAttributes?.(leaf),\n    className: clsx(props.className, nodeProps?.className),\n  };\n\n  const Leaf = (as ?? 'span') as any;\n\n  return <Leaf {...rootProps} />;\n}\n","import React from 'react';\n\nimport { decode } from 'html-entities';\n\nimport type { SlateEditor } from '../editor';\nimport type { NodeComponents } from '../plugin';\nimport type { PlateStaticProps } from './components/PlateStatic';\n\nimport { PlateStatic } from './components/PlateStatic';\nimport { stripHtmlClassNames } from './utils/stripHtmlClassNames';\nimport { stripSlateDataAttributes } from './utils/stripSlateDataAttributes';\n\nconst getReactDOMServer = async () => {\n  const ReactDOMServer = (await import('react-dom/server')).default;\n\n  return ReactDOMServer;\n};\n\nconst renderComponentToHtml = <P extends {}>(\n  ReactDOMServer: any,\n  Component: React.ComponentType<P>,\n  props: P\n): string => {\n  return decode(\n    ReactDOMServer.renderToStaticMarkup(React.createElement(Component, props))\n  );\n};\n\nexport type SerializeHtmlOptions<\n  T extends PlateStaticProps = PlateStaticProps,\n> = {\n  /** Node components to render the HTML */\n  components: NodeComponents;\n  /** The component used to render the editor content */\n  editorComponent?: React.ComponentType<T>;\n  /** List of className prefixes to preserve from being stripped out */\n  preserveClassNames?: string[];\n  /** Props to pass to the editor component */\n  props?: Partial<T>;\n  /** Enable stripping class names */\n  stripClassNames?: boolean;\n  /** Enable stripping data attributes */\n  stripDataAttributes?: boolean;\n};\n\n/**\n * Serialize the editor content to HTML. By default, uses `PlateStatic` as the\n * editor component, but you can provide a custom component (e.g.\n * `EditorStatic`).\n */\nexport const serializeHtml = async <\n  T extends PlateStaticProps = PlateStaticProps,\n>(\n  editor: SlateEditor,\n  {\n    components,\n    editorComponent: EditorComponent = PlateStatic,\n    preserveClassNames,\n    props = {},\n    stripClassNames = false,\n    stripDataAttributes = false,\n  }: SerializeHtmlOptions<T>\n): Promise<string> => {\n  const ReactDOMServer = await getReactDOMServer();\n\n  let htmlString = renderComponentToHtml(ReactDOMServer, EditorComponent, {\n    components,\n    editor,\n    ...props,\n  } as T);\n\n  if (stripClassNames) {\n    htmlString = stripHtmlClassNames(htmlString, {\n      preserveClassNames,\n    });\n  }\n  if (stripDataAttributes) {\n    htmlString = stripSlateDataAttributes(htmlString);\n  }\n\n  return htmlString;\n};\n","import React from 'react';\n\nimport {\n  type DecoratedRange,\n  type Descendant,\n  type NodeEntry,\n  type TElement,\n  type TText,\n  type Value,\n  ElementApi,\n  isElementDecorationsEqual,\n  isTextDecorationsEqual,\n  RangeApi,\n  TextApi,\n} from '@udecode/slate';\nimport clsx from 'clsx';\n\nimport type { SlateEditor } from '../../editor';\nimport type { NodeComponents } from '../../plugin';\nimport type { EditableProps } from '../../types/EditableProps';\nimport type { SlateRenderElementProps } from '../types';\n\nimport { pipeRenderElementStatic } from '../pipeRenderElementStatic';\nimport { pipeRenderLeafStatic } from '../pluginRenderLeafStatic';\nimport { pipeDecorate } from '../utils/pipeDecorate';\n\nfunction BaseElementStatic({\n  components,\n  decorate,\n  decorations,\n  editor,\n  element = { children: [], type: '' },\n}: {\n  components: NodeComponents;\n  decorate: EditableProps['decorate'];\n  decorations: DecoratedRange[];\n  editor: SlateEditor;\n  element: TElement;\n  style?: React.CSSProperties;\n}) {\n  const renderElement = pipeRenderElementStatic(editor, {\n    components,\n  });\n\n  const attributes: SlateRenderElementProps['attributes'] = {\n    'data-slate-node': 'element',\n    ref: null,\n  };\n\n  let children: React.ReactNode = (\n    <Children\n      components={components}\n      decorate={decorate}\n      decorations={decorations}\n      editor={editor}\n    >\n      {element.children}\n    </Children>\n  );\n\n  if (editor.api.isVoid(element)) {\n    attributes['data-slate-void'] = true;\n    children = (\n      <span\n        style={{\n          color: 'transparent',\n          height: '0',\n          outline: 'none',\n          position: 'absolute',\n        }}\n        data-slate-spacer\n      >\n        <Children\n          components={components}\n          decorate={decorate}\n          decorations={decorations}\n          editor={editor}\n        >\n          {element.children}\n        </Children>\n      </span>\n    );\n  }\n  if (editor.api.isInline(element)) {\n    attributes['data-slate-inline'] = true;\n  }\n\n  return (\n    <React.Fragment>\n      {renderElement?.({\n        attributes,\n        children,\n        element,\n      })}\n    </React.Fragment>\n  );\n}\n\nexport const ElementStatic = React.memo(BaseElementStatic, (prev, next) => {\n  return (\n    (prev.element === next.element ||\n      (prev.element._memo !== undefined &&\n        prev.element._memo === next.element._memo)) &&\n    isElementDecorationsEqual(prev.decorations, next.decorations)\n  );\n});\n\nfunction BaseLeafStatic({\n  components,\n  decorations,\n  editor,\n  leaf = { text: '' },\n}: {\n  components: NodeComponents;\n  decorations: DecoratedRange[];\n  editor: SlateEditor;\n  leaf: TText;\n}) {\n  const renderLeaf = pipeRenderLeafStatic(editor, {\n    components,\n  });\n\n  const leaves = TextApi.decorations(leaf, decorations);\n\n  return (\n    <span data-slate-node=\"text\">\n      {leaves.map((l, index) => {\n        const leafElement = renderLeaf!({\n          attributes: { 'data-slate-leaf': true },\n          children: (\n            <span data-slate-string={true}>\n              {l.text === '' ? '\\uFEFF' : l.text}\n            </span>\n          ),\n          leaf: l as TText,\n          text: l as TText,\n        });\n\n        return <React.Fragment key={index}>{leafElement}</React.Fragment>;\n      })}\n    </span>\n  );\n}\n\nexport const LeafStatic = React.memo(BaseLeafStatic, (prev, next) => {\n  return (\n    // prev.leaf === next.leaf &&\n    TextApi.equals(next.leaf, prev.leaf) &&\n    isTextDecorationsEqual(next.decorations, prev.decorations)\n  );\n});\n\nconst defaultDecorate: (entry: NodeEntry) => DecoratedRange[] = () => [];\n\nfunction Children({\n  children = [],\n  components,\n  decorate = defaultDecorate,\n  decorations = [],\n  editor,\n}: {\n  children: Descendant[];\n  components: NodeComponents;\n  decorate: EditableProps['decorate'];\n  decorations: DecoratedRange[];\n  editor: SlateEditor;\n}) {\n  return (\n    <React.Fragment>\n      {children.map((child, i) => {\n        const p = editor.api.findPath(child);\n\n        let ds: DecoratedRange[] = [];\n\n        if (p) {\n          const range = editor.api.range(p)!;\n          ds = decorate([child, p]);\n\n          for (const dec of decorations) {\n            const d = RangeApi.intersection(dec, range);\n\n            if (d) {\n              ds.push(d);\n            }\n          }\n        }\n\n        return ElementApi.isElement(child) ? (\n          <ElementStatic\n            key={i}\n            components={components}\n            decorate={decorate}\n            decorations={ds}\n            editor={editor}\n            element={child}\n          />\n        ) : (\n          <LeafStatic\n            key={i}\n            components={components}\n            decorations={ds}\n            editor={editor}\n            leaf={child}\n          />\n        );\n      })}\n    </React.Fragment>\n  );\n}\n\nexport type PlateStaticProps = {\n  /** Node components to render. */\n  components: NodeComponents;\n  /** Editor instance. */\n  editor: SlateEditor;\n  style?: React.CSSProperties;\n  /** Controlled value. Alias to `editor.children`. */\n  value?: Value;\n} & React.HTMLAttributes<HTMLDivElement>;\n\nexport function PlateStatic(props: PlateStaticProps) {\n  const { className, components, editor, value, ...rest } = props;\n\n  if (value) {\n    editor.children = value;\n  }\n\n  const decorate = pipeDecorate(editor);\n\n  let afterEditable: React.ReactNode = null;\n  let beforeEditable: React.ReactNode = null;\n\n  editor.pluginList.forEach((plugin) => {\n    const {\n      render: { afterEditable: AfterEditable, beforeEditable: BeforeEditable },\n    } = plugin;\n\n    if (AfterEditable) {\n      afterEditable = (\n        <>\n          {afterEditable}\n          <AfterEditable />\n        </>\n      );\n    }\n    if (BeforeEditable) {\n      beforeEditable = (\n        <>\n          {beforeEditable}\n          <BeforeEditable />\n        </>\n      );\n    }\n  });\n\n  const content = (\n    <div\n      className={clsx('slate-editor', className)}\n      data-slate-editor\n      data-slate-node=\"value\"\n      {...rest}\n    >\n      <Children\n        components={components}\n        decorate={decorate}\n        decorations={[]}\n        editor={editor}\n      >\n        {editor.children}\n      </Children>\n    </div>\n  );\n\n  let aboveEditable: React.ReactNode = (\n    <>\n      {beforeEditable}\n      {content}\n      {afterEditable}\n    </>\n  );\n\n  editor.pluginList.forEach((plugin) => {\n    const {\n      render: { aboveEditable: AboveEditable },\n    } = plugin;\n\n    if (AboveEditable) {\n      aboveEditable = <AboveEditable>{aboveEditable}</AboveEditable>;\n    }\n  });\n\n  return aboveEditable;\n}\n","export const isSlateVoid = (element: HTMLElement) => {\n  return element.dataset.slateVoid === 'true';\n};\n\nexport const isSlateElement = (element: HTMLElement) => {\n  return element.dataset.slateNode === 'element';\n};\n\nexport const isSlateText = (element: HTMLElement) => {\n  return element.dataset.slateNode === 'text';\n};\n\nexport const isSlateString = (element: HTMLElement) => {\n  return element.dataset.slateString === 'true';\n};\n\nexport const isSlateLeaf = (element: HTMLElement) => {\n  return element.dataset.slateLeaf === 'true';\n};\n\nexport const isSlateEditor = (element: HTMLElement) => {\n  return element.dataset.slateEditor === 'true';\n};\n\nexport const isSlateNode = (element: HTMLElement) => {\n  return (\n    isSlateLeaf(element) ||\n    isSlateElement(element) ||\n    isSlateVoid(element) ||\n    isSlateString(element) ||\n    isSlateText(element)\n  );\n};\n\nexport const isSlatePluginElement = (\n  element: HTMLElement,\n  pluginKey: string\n) => {\n  return (\n    element.dataset.slateNode === 'element' &&\n    element.classList.contains(`slate-${pluginKey}`)\n  );\n};\n\nexport const isSlatePluginNode = (element: HTMLElement, pluginKey: string) => {\n  return element.classList.contains(`slate-${pluginKey}`);\n};\n\nexport const getSlateElements = (element: HTMLElement): HTMLElement[] => {\n  return Array.from(element.querySelectorAll('[data-slate-node=\"element\"]'));\n};\n","/**\n * Convert HTML string exported from Plate into HTML element.\n *\n * @param html - The HTML string to convert exported from Plate.\n * @returns The Editor element without head and body.\n */\nexport const getEditorDOMFromHtmlString = (html: string) => {\n  const node = document.createElement('body');\n  node.innerHTML = html;\n  const editorNode = node.querySelector('[data-slate-editor=\"true\"]');\n\n  return editorNode as HTMLElement;\n};\n","/** Get slate class name: slate-<type> */\nexport const getSlateClass = (type?: string) => (type ? `slate-${type}` : '');\n","import type { Editor } from '@udecode/slate';\n\nimport { IS_APPLE } from '@udecode/utils';\nimport { type KeyboardEventLike, isKeyHotkey } from 'is-hotkey';\n\nexport { isHotkey } from 'is-hotkey';\n\n/** Hotkey mappings for each platform. */\nconst HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  insertSoftBreak: 'shift+enter',\n  italic: 'mod+i',\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  splitBlock: 'enter',\n  tab: 'tab',\n  undo: 'mod+z',\n  untab: 'shift+tab',\n};\n\nconst APPLE_HOTKEYS = {\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t',\n};\n\nconst WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z'],\n};\n\n/** Create a platform-aware hotkey checker. */\n\nexport const createHotkey = (key: string) => {\n  const generic = (HOTKEYS as any)[key];\n  const apple = (APPLE_HOTKEYS as any)[key];\n  const windows = (WINDOWS_HOTKEYS as any)[key];\n  const isGeneric = generic && isKeyHotkey(generic);\n  const isApple = apple && isKeyHotkey(apple);\n  const isWindows = windows && isKeyHotkey(windows);\n\n  return (event: KeyboardEventLike) => {\n    if (isGeneric?.(event)) return true;\n    if (IS_APPLE && isApple?.(event)) return true;\n    if (!IS_APPLE && isWindows?.(event)) return true;\n\n    return false;\n  };\n};\n\nconst createComposing =\n  (key: string) =>\n  (\n    editor: Editor,\n    event: React.KeyboardEvent,\n    {\n      composing,\n    }: {\n      /** Ignore the event if composing. */\n      composing?: boolean;\n    } = {}\n  ) => {\n    if (!createHotkey(key)(event)) return false;\n    if (!!composing !== editor.api.isComposing()) return false;\n\n    return true;\n  };\n\nexport const Hotkeys = {\n  isBold: createHotkey('bold'),\n  isCompose: createHotkey('compose'),\n  isDeleteBackward: createHotkey('deleteBackward'),\n  isDeleteForward: createHotkey('deleteForward'),\n  isDeleteLineBackward: createHotkey('deleteLineBackward'),\n  isDeleteLineForward: createHotkey('deleteLineForward'),\n  isDeleteWordBackward: createHotkey('deleteWordBackward'),\n  isDeleteWordForward: createHotkey('deleteWordForward'),\n  isExtendBackward: createHotkey('extendBackward'),\n  isExtendForward: createHotkey('extendForward'),\n  isExtendLineBackward: createHotkey('extendLineBackward'),\n  isExtendLineForward: createHotkey('extendLineForward'),\n  isItalic: createHotkey('italic'),\n  isMoveBackward: createHotkey('moveBackward'),\n  isMoveForward: createHotkey('moveForward'),\n  isMoveLineBackward: createHotkey('moveLineBackward'),\n  isMoveLineForward: createHotkey('moveLineForward'),\n  isMoveWordBackward: createHotkey('moveWordBackward'),\n  isMoveWordForward: createHotkey('moveWordForward'),\n  isRedo: createHotkey('redo'),\n  isSoftBreak: createHotkey('insertSoftBreak'),\n  isSplitBlock: createHotkey('splitBlock'),\n  isTab: createComposing('tab'),\n  isTransposeCharacter: createHotkey('transposeCharacter'),\n  isUndo: createHotkey('undo'),\n  isUntab: createComposing('untab'),\n};\n","import castArray from 'lodash/castArray.js';\n\nimport type { SlateEditor } from '../editor';\n\n/** Does the node match the type provided. */\nexport const isType = (\n  editor: SlateEditor,\n  node: any,\n  key?: string[] | string\n) => {\n  const keys = castArray(key);\n  const types: string[] = [];\n\n  keys.forEach((_key) => types.push(editor.getType({ key: _key })));\n\n  return types.includes(node?.type);\n};\n","import type { TNode } from '@udecode/slate';\n\nimport merge from 'lodash/merge.js';\n\nimport {\n  type ApplyDeepToNodesOptions,\n  applyDeepToNodes,\n} from './applyDeepToNodes';\n\n/** Recursively merge a source object to children nodes with a query. */\nexport const mergeDeepToNodes = <N extends TNode>(\n  options: Omit<ApplyDeepToNodesOptions<N>, 'apply'>\n) => {\n  applyDeepToNodes({ ...options, apply: merge });\n};\n","import {\n  type Descendant,\n  type Editor,\n  ElementApi,\n  TextApi,\n} from '@udecode/slate';\n\nimport type { SlateEditor } from '../editor';\nimport type { WithRequiredKey } from '../plugin';\n\nimport { BaseParagraphPlugin } from '../plugins';\n\nconst isInlineNode = (editor: Editor) => (node: Descendant) =>\n  TextApi.isText(node) ||\n  (ElementApi.isElement(node) && editor.api.isInline(node));\n\nconst makeBlockLazy = (type: string) => (): Descendant => ({\n  children: [],\n  type,\n});\n\nconst hasDifferentChildNodes = (\n  descendants: Descendant[],\n  isInline: (node: Descendant) => boolean\n): boolean => {\n  return descendants.some((descendant, index, arr) => {\n    const prevDescendant = arr[index - 1];\n\n    if (index !== 0) {\n      return isInline(descendant) !== isInline(prevDescendant);\n    }\n\n    return false;\n  });\n};\n\n/**\n * Handles 3rd constraint: \"Block nodes can only contain other blocks, or inline\n * and text nodes.\"\n */\nconst normalizeDifferentNodeTypes = (\n  descendants: Descendant[],\n  isInline: (node: Descendant) => boolean,\n  makeDefaultBlock: () => Descendant\n): Descendant[] => {\n  const hasDifferentNodes = hasDifferentChildNodes(descendants, isInline);\n\n  const { fragment } = descendants.reduce(\n    (memo, node) => {\n      if (hasDifferentNodes && isInline(node)) {\n        let block = memo.precedingBlock;\n\n        if (!block) {\n          block = makeDefaultBlock();\n          memo.precedingBlock = block;\n          memo.fragment.push(block);\n        }\n\n        (block.children as Descendant[]).push(node);\n      } else {\n        memo.fragment.push(node);\n        memo.precedingBlock = null;\n      }\n\n      return memo;\n    },\n    {\n      fragment: [] as Descendant[],\n      precedingBlock: null as Descendant | null,\n    }\n  );\n\n  return fragment;\n};\n\n/**\n * Handles 1st constraint: \"All Element nodes must contain at least one Text\n * descendant.\"\n */\nconst normalizeEmptyChildren = (descendants: Descendant[]): Descendant[] => {\n  if (descendants.length === 0) {\n    return [{ text: '' } as Descendant];\n  }\n\n  return descendants;\n};\n\nconst normalize = (\n  descendants: Descendant[],\n  isInline: (node: Descendant) => boolean,\n  makeDefaultBlock: () => Descendant\n): Descendant[] => {\n  descendants = normalizeEmptyChildren(descendants);\n  descendants = normalizeDifferentNodeTypes(\n    descendants,\n    isInline,\n    makeDefaultBlock\n  );\n\n  descendants = descendants.map((node) => {\n    if (ElementApi.isElement(node)) {\n      return {\n        ...node,\n        children: normalize(\n          node.children as Descendant[],\n          isInline,\n          makeDefaultBlock\n        ),\n      };\n    }\n\n    return node;\n  });\n\n  return descendants;\n};\n\n/** Normalize the descendants to a valid document fragment. */\nexport const normalizeDescendantsToDocumentFragment = (\n  editor: SlateEditor,\n  {\n    defaultElementPlugin = BaseParagraphPlugin,\n    descendants,\n  }: { descendants: Descendant[]; defaultElementPlugin?: WithRequiredKey }\n): Descendant[] => {\n  const isInline = isInlineNode(editor);\n  const defaultType = editor.getType(defaultElementPlugin);\n  const makeDefaultBlock = makeBlockLazy(defaultType);\n\n  return normalize(descendants, isInline, makeDefaultBlock as any);\n};\n","import type { DebugConfig } from '../getCorePlugins';\n\nimport { createTSlatePlugin } from '../../plugin';\n\nexport type DebugErrorType =\n  | (string & {})\n  | 'DEFAULT'\n  | 'OPTION_UNDEFINED'\n  | 'OVERRIDE_MISSING'\n  | 'PLUGIN_DEPENDENCY_MISSING'\n  | 'PLUGIN_MISSING'\n  | 'USE_CREATE_PLUGIN'\n  | 'USE_ELEMENT_CONTEXT';\n\nexport type LogLevel = 'error' | 'info' | 'log' | 'warn';\n\nexport class PlateError extends Error {\n  constructor(\n    message: string,\n    public type: DebugErrorType = 'DEFAULT'\n  ) {\n    super(`[${type}] ${message}`);\n    this.name = 'PlateError';\n  }\n}\n\nexport const DebugPlugin = createTSlatePlugin<DebugConfig>({\n  key: 'debug',\n  options: {\n    isProduction: process.env.NODE_ENV === 'production',\n    logger: {\n      error: (message, type, details) =>\n        console.error(`${type ? `[${type}] ` : ''}${message}`, details),\n      info: (message, type, details) =>\n        console.info(`${type ? `[${type}] ` : ''}${message}`, details),\n      log: (message, type, details) =>\n        console.log(`${type ? `[${type}] ` : ''}${message}`, details),\n      warn: (message, type, details) =>\n        console.warn(`${type ? `[${type}] ` : ''}${message}`, details),\n    },\n    logLevel:\n      process.env.NODE_ENV === 'production' ? 'error' : ('log' as LogLevel),\n    throwErrors: true,\n  },\n}).extendEditorApi<DebugConfig['api']>(({ getOptions }) => {\n  const logLevels: LogLevel[] = ['error', 'warn', 'info', 'log'];\n\n  const log = (\n    level: LogLevel,\n    message: any,\n    type?: DebugErrorType,\n    details?: any\n  ) => {\n    if (process.env.NODE_ENV === 'production') return;\n\n    const options = getOptions();\n\n    if (options.isProduction && level === 'log') return;\n    if (logLevels.indexOf(level) <= logLevels.indexOf(options.logLevel!)) {\n      if (level === 'error' && options.throwErrors) {\n        throw new PlateError(message, type);\n      } else {\n        options.logger[level]?.(message, type, details);\n      }\n    }\n  };\n\n  return {\n    debug: {\n      error: (message, type, details) => log('error', message, type, details),\n      info: (message, type, details) => log('info', message, type, details),\n      log: (message, type, details) => log('log', message, type, details),\n      warn: (message, type, details) => log('warn', message, type, details),\n    },\n  };\n});\n","import { bindFirst } from '@udecode/utils';\n\nimport { createSlatePlugin } from '../../plugin';\nimport { deserializeHtml, parseHtmlDocument } from './utils';\n\n/**\n * Enables support for deserializing inserted content from HTML format to Slate\n * format and serializing Slate content to HTML format.\n */\nexport const HtmlPlugin = createSlatePlugin({\n  key: 'html',\n})\n  .extendApi(({ editor }) => ({\n    deserialize: bindFirst(deserializeHtml, editor),\n  }))\n  .extend({\n    parser: {\n      format: 'text/html',\n      deserialize: ({ api, data }) => {\n        const document = parseHtmlDocument(data);\n\n        return api.html.deserialize({\n          element: document.body,\n        });\n      },\n    },\n  });\n","export const CARRIAGE_RETURN = '\\u000D';\n\nexport const LINE_FEED = '\\u000A';\n\nexport const NO_BREAK_SPACE = '\\u00A0';\n\nexport const SPACE = '\\u0020';\n\nexport const TAB = '\\u0009';\n\nexport const ZERO_WIDTH_SPACE = '\\u200B';\n","export const isHtmlElement = (node: Node): node is Element =>\n  node.nodeType === Node.ELEMENT_NODE;\n","type Callback = (node: Node) => boolean;\n\n/**\n * Depth-first pre-order tree traverse the given HTML node and calls the given\n * callback for each node. see:\n * https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)\n *\n * @param callback Returns a boolean indicating whether traversal should be\n *   continued\n */\nexport const traverseHtmlNode = (node: Node, callback: Callback): void => {\n  const keepTraversing = callback(node);\n\n  if (!keepTraversing) {\n    return;\n  }\n\n  let child = node.firstChild;\n\n  while (child) {\n    const currentChild = child;\n    const previousChild = child.previousSibling;\n    child = child.nextSibling;\n\n    traverseHtmlNode(currentChild, callback);\n\n    if (\n      // An unwrap was made. Need to compute the next child again.\n      !currentChild.previousSibling &&\n      !currentChild.nextSibling &&\n      !currentChild.parentNode &&\n      child &&\n      previousChild !== child.previousSibling &&\n      child.parentNode\n    ) {\n      child = previousChild ? previousChild.nextSibling : node.firstChild;\n    } else if (\n      // A list was created. Need to compute the next child again.\n      !currentChild.previousSibling &&\n      !currentChild.nextSibling &&\n      !currentChild.parentNode &&\n      child &&\n      !child.previousSibling &&\n      !child.nextSibling &&\n      !child.parentNode\n    ) {\n      if (previousChild) {\n        child = previousChild.nextSibling\n          ? previousChild.nextSibling.nextSibling\n          : null;\n      } else if (node.firstChild) {\n        child = node.firstChild.nextSibling;\n      }\n    }\n  }\n};\n","import { isHtmlElement } from './isHtmlElement';\nimport { traverseHtmlNode } from './traverseHtmlNode';\n\ntype Callback = (node: Element) => boolean;\n\n/**\n * Traverse the HTML elements of the given HTML node.\n *\n * @param rootNode The root HTML node to traverse.\n * @param callback The callback to call for each HTML element.\n */\nexport const traverseHtmlElements = (\n  rootNode: Node,\n  callback: Callback\n): void => {\n  traverseHtmlNode(rootNode, (node) => {\n    if (!isHtmlElement(node)) {\n      return true;\n    }\n\n    return callback(node);\n  });\n};\n","import { LINE_FEED } from '../constants';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\n/** Replace BR elements with line feeds. */\nexport const cleanHtmlBrElements = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.tagName !== 'BR') {\n      return true;\n    }\n\n    const replacementTextNode = document.createTextNode(LINE_FEED);\n\n    if (element.parentElement) {\n      element.parentElement.replaceChild(replacementTextNode, element);\n    }\n\n    return false;\n  });\n};\n","/** Replace \\r\\n and \\r with \\n */\nexport const cleanHtmlCrLf = (html: string): string => {\n  return html.replaceAll(/\\r\\n|\\r/g, '\\n');\n};\n","import { traverseHtmlElements } from './traverseHtmlElements';\n\nconst ALLOWED_EMPTY_ELEMENTS = new Set(['BR', 'IMG', 'TD', 'TH']);\n\nconst isEmpty = (element: Element): boolean => {\n  return (\n    !ALLOWED_EMPTY_ELEMENTS.has(element.nodeName) && !element.innerHTML.trim()\n  );\n};\n\nconst removeIfEmpty = (element: Element): void => {\n  if (isEmpty(element)) {\n    const { parentElement } = element;\n\n    element.remove();\n\n    if (parentElement) {\n      removeIfEmpty(parentElement);\n    }\n  }\n};\n\n/** Remove empty elements from rootNode. Allowed empty elements: BR, IMG. */\nexport const cleanHtmlEmptyElements = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    removeIfEmpty(element);\n\n    return true;\n  });\n};\n","/**\n * Replace `element` tag name by `tagName`. Attributes, innerHTML and parent\n * relationship is kept.\n */\nexport const replaceTagName = (element: Element, tagName: string): Element => {\n  const newElement = document.createElement(tagName);\n\n  newElement.innerHTML = element.innerHTML;\n\n  for (const { name } of element.attributes) {\n    const value = element.getAttribute(name);\n\n    if (value) {\n      newElement.setAttribute(name, value);\n    }\n  }\n\n  if (element.parentNode) {\n    element.parentNode.replaceChild(newElement, element);\n  }\n\n  return newElement;\n};\n","import { replaceTagName } from './replaceTagName';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\n/**\n * Replace FONT elements with SPAN elements if there is textContent (remove\n * otherwise).\n */\nexport const cleanHtmlFontElements = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.tagName === 'FONT') {\n      if (element.textContent) {\n        replaceTagName(element, 'span');\n      } else {\n        element.remove();\n      }\n    }\n\n    return true;\n  });\n};\n","/** If href starts with '#'. */\nexport const isHtmlFragmentHref = (href: string): boolean =>\n  href.startsWith('#');\n","/** Unwrap the given HTML element. */\nexport const unwrapHtmlElement = (element: Element): void => {\n  element.outerHTML = element.innerHTML;\n};\n","import { isHtmlFragmentHref } from './isHtmlFragmentHref';\nimport { traverseHtmlElements } from './traverseHtmlElements';\nimport { unwrapHtmlElement } from './unwrapHtmlElement';\n\n/** Remove fragment hrefs and spans without inner text. */\nexport const cleanHtmlLinkElements = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.tagName !== 'A') {\n      return true;\n    }\n\n    const href = element.getAttribute('href');\n\n    if (!href || isHtmlFragmentHref(href)) {\n      unwrapHtmlElement(element);\n    }\n    if (href && element.querySelector('img')) {\n      for (const span of element.querySelectorAll('span')) {\n        if (!span.textContent) {\n          unwrapHtmlElement(span);\n        }\n      }\n    }\n\n    return true;\n  });\n};\n","export const isHtmlText = (node: Node): node is Text =>\n  node.nodeType === Node.TEXT_NODE;\n","import { isHtmlText } from './isHtmlText';\nimport { traverseHtmlNode } from './traverseHtmlNode';\n\ntype Callback = (node: Text) => boolean;\n\nexport const traverseHtmlTexts = (rootNode: Node, callback: Callback): void => {\n  traverseHtmlNode(rootNode, (node) => {\n    if (!isHtmlText(node)) {\n      return true;\n    }\n\n    return callback(node);\n  });\n};\n","import {\n  CARRIAGE_RETURN,\n  LINE_FEED,\n  NO_BREAK_SPACE,\n  SPACE,\n} from '../constants';\nimport { traverseHtmlTexts } from './traverseHtmlTexts';\n\nexport const cleanHtmlTextNodes = (rootNode: Node): void => {\n  traverseHtmlTexts(rootNode, (textNode) => {\n    if (\n      /^\\n\\s*$/.test(textNode.data) &&\n      (textNode.previousElementSibling || textNode.nextElementSibling)\n    ) {\n      textNode.remove();\n\n      return true;\n    }\n\n    textNode.data = textNode.data.replaceAll(/\\n\\s*/g, '\\n');\n\n    if (\n      textNode.data.includes(CARRIAGE_RETURN) ||\n      textNode.data.includes(LINE_FEED) ||\n      textNode.data.includes(NO_BREAK_SPACE)\n    ) {\n      const hasSpace = textNode.data.includes(SPACE);\n      const hasNonWhitespace = /\\S/.test(textNode.data);\n      const hasLineFeed = textNode.data.includes(LINE_FEED);\n\n      if (!(hasSpace || hasNonWhitespace) && !hasLineFeed) {\n        if (textNode.data === NO_BREAK_SPACE) {\n          textNode.data = SPACE;\n\n          return true;\n        }\n\n        textNode.remove();\n\n        return true;\n      }\n      if (\n        textNode.previousSibling &&\n        textNode.previousSibling.nodeName === 'BR' &&\n        textNode.parentElement\n      ) {\n        textNode.previousSibling.remove();\n\n        const matches = /^[\\n\\r]+/.exec(textNode.data);\n        const offset = matches ? matches[0].length : 0;\n\n        textNode.data = textNode.data\n          .slice(Math.max(0, offset))\n          .replaceAll(new RegExp(LINE_FEED, 'g'), SPACE)\n          .replaceAll(new RegExp(CARRIAGE_RETURN, 'g'), SPACE);\n        textNode.data = `\\n${textNode.data}`;\n      } else {\n        textNode.data = textNode.data\n          .replaceAll(new RegExp(LINE_FEED, 'g'), SPACE)\n          .replaceAll(new RegExp(CARRIAGE_RETURN, 'g'), SPACE);\n      }\n    }\n\n    return true;\n  });\n};\n","/**\n * # Methodology\n *\n * ## Step 1. Get the list of all standard tag names\n *\n * Go to https://developer.mozilla.org/en-US/docs/Web/HTML/Element and run the\n * following in the console to generate a JSON array of tag names:\n *\n * ```js\n * JSON.stringify(\n *   Array.from(document.querySelectorAll('article table td:first-child'))\n *     .map((td) => {\n *       const body = document.createElement('body');\n *       body.innerHTML = td.textContent;\n *       return body.firstChild?.tagName;\n *     })\n *     .filter((tagName) => tagName)\n * );\n * ```\n *\n * Output (as of 2023-11-06):\n *\n * ```json\n * '[\"BASE\",\"LINK\",\"META\",\"STYLE\",\"TITLE\",\"ADDRESS\",\"ARTICLE\",\"ASIDE\",\"FOOTER\",\"HEADER\",\"H1\",\"HGROUP\",\"MAIN\",\"NAV\",\"SECTION\",\"SEARCH\",\"BLOCKQUOTE\",\"DD\",\"DIV\",\"DL\",\"DT\",\"FIGCAPTION\",\"FIGURE\",\"HR\",\"LI\",\"MENU\",\"OL\",\"P\",\"PRE\",\"UL\",\"A\",\"ABBR\",\"B\",\"BDI\",\"BDO\",\"BR\",\"CITE\",\"CODE\",\"DATA\",\"DFN\",\"EM\",\"I\",\"KBD\",\"MARK\",\"Q\",\"RP\",\"RT\",\"RUBY\",\"S\",\"SAMP\",\"SMALL\",\"SPAN\",\"STRONG\",\"SUB\",\"SUP\",\"TIME\",\"U\",\"VAR\",\"WBR\",\"AREA\",\"AUDIO\",\"IMG\",\"MAP\",\"TRACK\",\"VIDEO\",\"EMBED\",\"IFRAME\",\"OBJECT\",\"PICTURE\",\"PORTAL\",\"SOURCE\",\"svg\",\"math\",\"CANVAS\",\"NOSCRIPT\",\"SCRIPT\",\"DEL\",\"INS\",\"TABLE\",\"BUTTON\",\"DATALIST\",\"FIELDSET\",\"FORM\",\"INPUT\",\"LABEL\",\"LEGEND\",\"METER\",\"OPTGROUP\",\"OPTION\",\"OUTPUT\",\"PROGRESS\",\"SELECT\",\"TEXTAREA\",\"DETAILS\",\"DIALOG\",\"SUMMARY\",\"SLOT\",\"TEMPLATE\",\"ACRONYM\",\"BIG\",\"CENTER\",\"CONTENT\",\"DIR\",\"FONT\",\"IMG\",\"MARQUEE\",\"MENUITEM\",\"NOBR\",\"NOEMBED\",\"NOFRAMES\",\"PARAM\",\"PLAINTEXT\",\"RB\",\"RTC\",\"SHADOW\",\"STRIKE\",\"TT\",\"XMP\"]'\n * ```\n *\n * ## Step 2. For each tag name, determine the default browser style\n *\n * Open an empty HTML file in the browser and run the following in the console:\n *\n * ```js\n * const tagNames = JSON.parse(<JSON string from step 1>);\n *\n * JSON.stringify(\n *   tagNames.filter((tagName) => {\n *     const element = document.createElement(tagName);\n *     document.body.appendChild(element);\n *     const display = window.getComputedStyle(element).display;\n *     element.remove();\n *     return display.startsWith('inline');\n *   })\n * );\n * ```\n *\n * Place the result in the array below (accurate as of 2023-11-06).\n */\n\nexport const inlineTagNames = new Set([\n  'A',\n  'ABBR',\n  'ACRONYM',\n  'B',\n  'BDI',\n  'BDO',\n  'BIG',\n  'BR',\n  'BUTTON',\n  'CANVAS',\n  'CITE',\n  'CODE',\n  'CONTENT',\n  'DATA',\n  'DEL',\n  'DFN',\n  'EM',\n  'EMBED',\n  'FONT',\n  'I',\n  'IFRAME',\n  'IMG',\n  'IMG',\n  'INPUT',\n  'INS',\n  'KBD',\n  'LABEL',\n  'MAP',\n  'MARK',\n  'MARQUEE',\n  'math',\n  'MENUITEM',\n  'METER',\n  'NOBR',\n  'OBJECT',\n  'OUTPUT',\n  'PICTURE',\n  'PORTAL',\n  'PROGRESS',\n  'Q',\n  'S',\n  'SAMP',\n  'SELECT',\n  'SHADOW',\n  'SMALL',\n  'SOURCE',\n  'SPAN',\n  'STRIKE',\n  'STRONG',\n  'SUB',\n  'SUP',\n  'svg',\n  'TEXTAREA',\n  'TIME',\n  'TRACK',\n  'TT',\n  'U',\n  'VAR',\n  'VIDEO',\n  'WBR',\n]);\n","import { inlineTagNames } from './inlineTagNames';\nimport { isHtmlElement } from './isHtmlElement';\n\nexport const isHtmlInlineElement = (node: Node): boolean => {\n  if (!isHtmlElement(node)) return false;\n\n  const element = node as HTMLElement;\n\n  const tagNameIsInline = inlineTagNames.has(element.tagName);\n\n  /**\n   * Valid display values include 'inline flow'. We only care about the first\n   * part.\n   */\n  const displayProperty = element.style.display.split(' ')[0];\n\n  if (displayProperty === '') {\n    return tagNameIsInline;\n  }\n  if (displayProperty.startsWith('inline')) {\n    return true;\n  }\n  if (displayProperty === 'inherit' && element.parentElement) {\n    return isHtmlInlineElement(element.parentElement);\n  }\n  /**\n   * Handle all special values manually, so that any unhandled values can be\n   * assumed to be block.\n   *\n   * Note: Ideally, content inside `display: none` elements should not be\n   * parsed. However, if such elements are parsed, it's best for their inline or\n   * block status to be left unchanged.\n   */\n  if (\n    ['contents', 'initial', 'none', 'revert', 'revert-layer', 'unset'].includes(\n      displayProperty\n    )\n  ) {\n    return tagNameIsInline;\n  }\n\n  return false;\n};\n","import { isHtmlElement } from './isHtmlElement';\nimport { isHtmlInlineElement } from './isHtmlInlineElement';\n\nexport const isHtmlBlockElement = (node: Node): boolean => {\n  if (!isHtmlElement(node)) return false;\n\n  const element = node as HTMLElement;\n\n  return !isHtmlInlineElement(element);\n};\n","export const isHtmlTable = (element: Element) => element.nodeName === 'TABLE';\n","import { isHtmlBlockElement } from './isHtmlBlockElement';\nimport { isHtmlTable } from './isHtmlTable';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\n/**\n * Set HTML blocks mark styles to a new child span element if any. This allows\n * Plate to use block marks.\n */\nexport const copyBlockMarksToSpanChild = (rootNode: Node) => {\n  traverseHtmlElements(rootNode, (element) => {\n    const el = element as HTMLElement;\n\n    const styleAttribute = element.getAttribute('style');\n\n    if (!styleAttribute) return true;\n    if (isHtmlBlockElement(el) && !isHtmlTable(el)) {\n      const {\n        style: {\n          backgroundColor,\n          color,\n          fontFamily,\n          fontSize,\n          fontStyle,\n          fontWeight,\n          textDecoration,\n        },\n      } = el;\n\n      if (\n        backgroundColor ||\n        color ||\n        fontFamily ||\n        fontSize ||\n        fontStyle ||\n        fontWeight ||\n        textDecoration\n      ) {\n        const span = document.createElement('span');\n\n        if (!['inherit', 'initial'].includes(color)) {\n          span.style.color = color;\n        }\n\n        span.style.fontFamily = fontFamily;\n        span.style.fontSize = fontSize;\n\n        if (!['inherit', 'initial', 'normal'].includes(color)) {\n          span.style.fontStyle = fontStyle;\n        }\n        if (![400, 'normal'].includes(fontWeight)) {\n          span.style.fontWeight = fontWeight;\n        }\n\n        span.style.textDecoration = textDecoration;\n\n        span.innerHTML = el.innerHTML;\n        element.innerHTML = span.outerHTML;\n      }\n    }\n\n    return true;\n  });\n};\n","import type { TrimEndRule, TrimStartRule } from './types';\n\nexport const collapseString = (\n  text: string,\n  {\n    shouldCollapseWhiteSpace = true,\n    trimEnd = 'collapse',\n    trimStart = 'collapse',\n    whiteSpaceIncludesNewlines = true,\n  }: {\n    shouldCollapseWhiteSpace?: boolean;\n    trimEnd?: TrimEndRule;\n    trimStart?: TrimStartRule;\n    whiteSpaceIncludesNewlines?: boolean;\n  } = {}\n) => {\n  if (trimStart === 'all') {\n    text = text.replace(/^\\s+/, '');\n  }\n  if (trimEnd === 'single-newline') {\n    // Strip at most one newline from the end\n    text = text.replace(/\\n$/, '');\n  }\n  if (shouldCollapseWhiteSpace) {\n    if (whiteSpaceIncludesNewlines) {\n      text = text.replaceAll(/\\s+/g, ' ');\n    } else {\n      // Collapse horizontal whitespace\n      text = text.replaceAll(/[^\\S\\n\\r]+/g, ' ');\n\n      /**\n       * Trim horizontal whitespace from the start and end of lines (behavior of\n       * pre-line).\n       */\n      text = text.replaceAll(/^[^\\S\\n\\r]+/gm, '');\n      text = text.replaceAll(/[^\\S\\n\\r]+$/gm, '');\n    }\n  }\n\n  return text;\n};\n","import { isHtmlBlockElement } from '../isHtmlBlockElement';\n\nexport const isLastNonEmptyTextOfInlineFormattingContext = (\n  initialText: Text\n): boolean => {\n  let currentNode: Node | null = initialText;\n\n  while (true) {\n    if (currentNode.nextSibling) {\n      currentNode = currentNode.nextSibling;\n    } else {\n      // If there is no next sibling, ascend to the parent node\n      currentNode = currentNode.parentElement;\n\n      // If the parent node is a block, we've reached the end\n      if (currentNode && isHtmlBlockElement(currentNode)) {\n        return true;\n      }\n\n      // Otherwise, continue to the next sibling of the parent node\n      currentNode = currentNode?.nextSibling || null;\n    }\n    // If there's no next node, we've reached the end\n    if (!currentNode) {\n      return true;\n    }\n    // If the next node is a block, we've reached the end\n    if (isHtmlBlockElement(currentNode)) {\n      return true;\n    }\n    // If the next node is a non-empty text node, we're not at the end\n    if ((currentNode.textContent || '').length > 0) {\n      return false;\n    }\n\n    // Otherwise, continue to the next node\n  }\n};\n","import type { CollapseWhiteSpaceState } from './types';\n\nexport const upsertInlineFormattingContext = (\n  state: CollapseWhiteSpaceState\n) => {\n  if (state.inlineFormattingContext) {\n    state.inlineFormattingContext.atStart = false;\n  } else {\n    state.inlineFormattingContext = {\n      atStart: true,\n      lastHasTrailingWhiteSpace: false,\n    };\n  }\n};\n\nexport const endInlineFormattingContext = (state: CollapseWhiteSpaceState) => {\n  state.inlineFormattingContext = null;\n};\n","import type {\n  CollapseWhiteSpaceState,\n  TrimEndRule,\n  TrimStartRule,\n} from './types';\n\nimport { collapseString } from './collapseString';\nimport { isLastNonEmptyTextOfInlineFormattingContext } from './isLastNonEmptyTextOfInlineFormattingContext';\nimport { upsertInlineFormattingContext } from './stateTransforms';\n\nexport const collapseWhiteSpaceText = (\n  text: Text,\n  state: CollapseWhiteSpaceState\n) => {\n  const textContent = text.textContent || '';\n  const isWhiteSpaceOnly = textContent.trim() === '';\n\n  /**\n   * Do not start an inline formatting context with a text node containing only\n   * white space.\n   */\n  if (state.inlineFormattingContext || !isWhiteSpaceOnly) {\n    upsertInlineFormattingContext(state);\n  }\n\n  const { whiteSpaceRule } = state;\n\n  /**\n   * Note: Due to the way HTML strings are parsed in htmlStringToDOMNode, up to\n   * one newline is already trimmed from the start of text nodes inside <pre>\n   * elements. If we do so again here, we may remove too many newlines. This\n   * only applies to actual <pre> elements, not elements with the white-space\n   * CSS property.\n   */\n  const trimStart: TrimStartRule = (() => {\n    if (whiteSpaceRule !== 'normal') return 'collapse';\n    if (\n      !state.inlineFormattingContext ||\n      state.inlineFormattingContext.atStart ||\n      state.inlineFormattingContext.lastHasTrailingWhiteSpace\n    )\n      return 'all';\n\n    return 'collapse';\n  })();\n\n  const trimEnd: TrimEndRule = (() => {\n    if (whiteSpaceRule === 'normal') return 'collapse';\n    if (isLastNonEmptyTextOfInlineFormattingContext(text))\n      return 'single-newline';\n\n    return 'collapse';\n  })();\n\n  const shouldCollapseWhiteSpace: boolean = {\n    normal: true,\n    pre: false,\n    'pre-line': true,\n  }[whiteSpaceRule];\n\n  const whiteSpaceIncludesNewlines = whiteSpaceRule !== 'pre-line';\n\n  const collapsedTextContent = collapseString(textContent || '', {\n    shouldCollapseWhiteSpace,\n    trimEnd,\n    trimStart,\n    whiteSpaceIncludesNewlines,\n  });\n\n  if (state.inlineFormattingContext && shouldCollapseWhiteSpace) {\n    state.inlineFormattingContext.lastHasTrailingWhiteSpace =\n      collapsedTextContent.endsWith(' ');\n  }\n\n  text.textContent = collapsedTextContent;\n};\n","import type { CollapseWhiteSpaceState } from './types';\n\nimport { isHtmlElement } from '../isHtmlElement';\nimport { isHtmlText } from '../isHtmlText';\nimport { collapseWhiteSpaceChildren } from './collapseWhiteSpaceChildren';\nimport { collapseWhiteSpaceElement } from './collapseWhiteSpaceElement';\nimport { collapseWhiteSpaceText } from './collapseWhiteSpaceText';\n\nexport const collapseWhiteSpaceNode = (\n  node: Node,\n  state: CollapseWhiteSpaceState\n) => {\n  if (isHtmlElement(node)) {\n    collapseWhiteSpaceElement(node as HTMLElement, state);\n\n    return;\n  }\n  if (isHtmlText(node)) {\n    collapseWhiteSpaceText(node as Text, state);\n\n    return;\n  }\n\n  collapseWhiteSpaceChildren(node, state);\n};\n","import type { CollapseWhiteSpaceState } from './types';\n\nimport { collapseWhiteSpaceNode } from './collapseWhiteSpaceNode';\n\nexport const collapseWhiteSpaceChildren = (\n  node: Node,\n  state: CollapseWhiteSpaceState\n) => {\n  const childNodes = Array.from(node.childNodes);\n\n  for (const childNode of childNodes) {\n    collapseWhiteSpaceNode(childNode, state);\n  }\n};\n","import type { WhiteSpaceRule } from './types';\n\nexport const inferWhiteSpaceRule = (\n  element: HTMLElement\n): WhiteSpaceRule | null => {\n  const whiteSpaceProperty = element.style.whiteSpace;\n\n  switch (whiteSpaceProperty) {\n    case 'break-spaces':\n    case 'pre':\n    case 'pre-wrap': {\n      return 'pre';\n    }\n    case 'normal':\n    case 'nowrap': {\n      return 'normal';\n    }\n    case 'pre-line': {\n      return 'pre-line';\n    }\n  }\n\n  if (element.tagName === 'PRE') {\n    return 'pre';\n  }\n  if (whiteSpaceProperty === 'initial') {\n    return 'normal';\n  }\n\n  return null;\n};\n","import type { CollapseWhiteSpaceState } from './types';\n\nimport { isHtmlInlineElement } from '../isHtmlInlineElement';\nimport { collapseWhiteSpaceChildren } from './collapseWhiteSpaceChildren';\nimport { inferWhiteSpaceRule } from './inferWhiteSpaceRule';\nimport { endInlineFormattingContext } from './stateTransforms';\n\n/**\n * Note: We do not want to start an inline formatting context until we encounter\n * a text node.\n */\nexport const collapseWhiteSpaceElement = (\n  element: HTMLElement,\n  state: CollapseWhiteSpaceState\n) => {\n  const isInlineElement = isHtmlInlineElement(element);\n  const previousWhiteSpaceRule = state.whiteSpaceRule;\n  const inferredWhiteSpaceRule = inferWhiteSpaceRule(element);\n\n  if (inferredWhiteSpaceRule) {\n    state.whiteSpaceRule = inferredWhiteSpaceRule;\n  }\n  // End any existing inline formatting context\n  if (!isInlineElement) {\n    endInlineFormattingContext(state);\n  }\n\n  collapseWhiteSpaceChildren(element, state);\n\n  // Do not let inline formatting context break out of block elements\n  if (!isInlineElement) {\n    endInlineFormattingContext(state);\n  }\n\n  // Restore previous whiteSpaceRule\n  state.whiteSpaceRule = previousWhiteSpaceRule;\n};\n","import type { CollapseWhiteSpaceState } from './types';\n\nimport { collapseWhiteSpaceElement } from './collapseWhiteSpaceElement';\n\n// Entrypoint\nexport const collapseWhiteSpace = (element: HTMLElement) => {\n  const clonedElement = element.cloneNode(true) as HTMLElement;\n\n  // Mutable state object\n  const state: CollapseWhiteSpaceState = {\n    inlineFormattingContext: null,\n    whiteSpaceRule: 'normal',\n  };\n\n  collapseWhiteSpaceElement(clonedElement, state);\n\n  return clonedElement;\n};\n","import type { Descendant } from '@udecode/slate';\n\nimport { jsx } from 'slate-hyperscript';\n\nimport type { SlateEditor } from '../../../editor';\n\nimport { deserializeHtmlNodeChildren } from './deserializeHtmlNodeChildren';\n\njsx;\n\n/** Deserialize HTML body element to Fragment. */\nexport const htmlBodyToFragment = (\n  editor: SlateEditor,\n  element: HTMLElement\n): Descendant[] | undefined => {\n  if (element.nodeName === 'BODY') {\n    return jsx(\n      'fragment',\n      {},\n      deserializeHtmlNodeChildren(editor, element)\n    ) as Descendant[];\n  }\n};\n","import type { SlateEditor } from '../../../editor';\nimport type { DeserializeHtmlChildren } from '../types';\n\nimport { isSlateNode } from '../../../static';\nimport { deserializeHtmlNode } from './deserializeHtmlNode';\n\nexport const deserializeHtmlNodeChildren = (\n  editor: SlateEditor,\n  node: ChildNode | HTMLElement,\n  isSlateParent = false\n): DeserializeHtmlChildren[] => {\n  return Array.from(node.childNodes).flatMap((child) => {\n    if (\n      child.nodeType === 1 &&\n      !isSlateNode(child as HTMLElement) &&\n      isSlateParent\n    ) {\n      return deserializeHtmlNodeChildren(\n        editor,\n        child as HTMLElement,\n        isSlateParent\n      );\n    }\n\n    return deserializeHtmlNode(editor)(child);\n  }) as DeserializeHtmlChildren[];\n};\n","/** Deserialize HTML to break line. */\nexport const htmlBrToNewLine = (node: ChildNode | HTMLElement) => {\n  if (node.nodeName === 'BR') {\n    return '\\n';\n  }\n};\n","import type { Descendant } from '@udecode/slate';\n\nimport { jsx } from 'slate-hyperscript';\n\nimport type { SlateEditor } from '../../../editor';\n\nimport { isSlateVoid } from '../../../static';\nimport { deserializeHtmlNodeChildren } from './deserializeHtmlNodeChildren';\nimport { pipeDeserializeHtmlElement } from './pipeDeserializeHtmlElement';\n\n/** Deserialize HTML to Element. */\nexport const htmlElementToElement = (\n  editor: SlateEditor,\n  element: HTMLElement,\n  isSlate = false\n) => {\n  const deserialized = pipeDeserializeHtmlElement(editor, element);\n\n  if (deserialized) {\n    const { node, withoutChildren } = deserialized;\n\n    let descendants =\n      node.children ??\n      (deserializeHtmlNodeChildren(editor, element, isSlate) as Descendant[]);\n\n    if (descendants.length === 0 || withoutChildren || isSlateVoid(element)) {\n      descendants = [{ text: '' }];\n    }\n\n    return jsx('element', node, descendants) as Descendant;\n  }\n};\n","import { type AnyObject, type Nullable, isDefined } from '@udecode/utils';\nimport castArray from 'lodash/castArray.js';\n\nimport type { SlateEditor } from '../../../editor';\nimport type {\n  AnyEditorPlugin,\n  HtmlDeserializer,\n} from '../../../plugin/SlatePlugin';\n\nimport { getEditorPlugin } from '../../../plugin';\nimport { isSlateNode } from '../../../static';\nimport { getInjectedPlugins } from '../../../utils/getInjectedPlugins';\nimport { getDataNodeProps } from './getDataNodeProps';\n\n/**\n * Get a deserializer and add default rules for deserializing plate static\n * elements\n */\nconst getDeserializedWithStaticRules = (plugin: AnyEditorPlugin) => {\n  let deserializer = plugin.parsers?.html?.deserializer;\n\n  const rules = deserializer?.rules ?? [];\n\n  // Check if rules already contain slate-xxx className\n  const hasSlateRule = rules.some((rule) =>\n    rule.validClassName?.includes(`slate-${plugin.key}`)\n  );\n\n  const staticRules = hasSlateRule\n    ? rules\n    : [\n        {\n          validClassName: `slate-${plugin.key}`,\n          validNodeName: '*',\n        },\n        ...rules,\n      ];\n\n  if (!deserializer) deserializer = { rules: staticRules };\n\n  deserializer.rules = staticRules;\n\n  return deserializer;\n};\n\n/** Get a deserializer by type, node names, class names and styles. */\nexport const pluginDeserializeHtml = (\n  editor: SlateEditor,\n  plugin: AnyEditorPlugin,\n  {\n    deserializeLeaf,\n    element: el,\n  }: { element: HTMLElement; deserializeLeaf?: boolean }\n): (Nullable<HtmlDeserializer> & { node: AnyObject }) | undefined => {\n  const {\n    node: { isElement: isElementRoot, isLeaf: isLeafRoot },\n  } = plugin;\n\n  const deserializer = getDeserializedWithStaticRules(plugin);\n\n  if (!deserializer) return;\n\n  const {\n    attributeNames,\n    isElement: isElementRule,\n    isLeaf: isLeafRule,\n    query,\n    rules,\n  } = deserializer;\n  let { parse } = deserializer;\n\n  const isElement = isElementRule || isElementRoot;\n  const isLeaf = isLeafRule || isLeafRoot;\n\n  if (!deserializeLeaf && !isElement) {\n    return;\n  }\n  if (deserializeLeaf && !isLeaf) {\n    return;\n  }\n  if (rules) {\n    const isValid = rules.some(\n      ({ validAttribute, validClassName, validNodeName = '*', validStyle }) => {\n        if (validNodeName) {\n          const validNodeNames = castArray<string>(validNodeName);\n\n          // Ignore if el nodeName is not included in rule validNodeNames (except *).\n          if (\n            validNodeNames.length > 0 &&\n            !validNodeNames.includes(el.nodeName) &&\n            validNodeName !== '*'\n          )\n            return false;\n        }\n        // Ignore if the rule className is not in el class list.\n        if (validClassName && !el.classList.contains(validClassName))\n          return false;\n        if (validStyle) {\n          for (const [key, value] of Object.entries(validStyle)) {\n            const values = castArray<string>(value);\n\n            // Ignore if el style value is not included in rule style values (except *)\n            if (!values.includes((el.style as any)[key]) && value !== '*')\n              return;\n            // Ignore if el style value is falsy (for value *)\n            if (value === '*' && !(el.style as any)[key]) return;\n\n            const defaultNodeValue = plugin.inject.nodeProps?.defaultNodeValue;\n\n            // Ignore if the style value = plugin.inject.nodeProps.defaultNodeValue\n            if (\n              defaultNodeValue &&\n              defaultNodeValue === (el.style as any)[key]\n            ) {\n              return false;\n            }\n          }\n        }\n        if (validAttribute) {\n          if (typeof validAttribute === 'string') {\n            if (!el.getAttributeNames().includes(validAttribute)) return false;\n          } else {\n            for (const [attributeName, attributeValue] of Object.entries(\n              validAttribute\n            )) {\n              const attributeValues = castArray<string>(attributeValue);\n              const elAttribute = el.getAttribute(attributeName);\n\n              if (\n                !isDefined(elAttribute) ||\n                !attributeValues.includes(elAttribute)\n              )\n                return false;\n            }\n          }\n        }\n\n        return true;\n      }\n    );\n\n    if (!isValid) return;\n  }\n  if (\n    query &&\n    !query({ ...(getEditorPlugin(editor, plugin) as any), element: el })\n  ) {\n    return;\n  }\n  if (!parse)\n    if (isElement) {\n      parse = ({ type }) => ({ type: type });\n    } else if (isLeaf) {\n      parse = ({ type }) => ({ [type!]: true });\n    } else {\n      return;\n    }\n\n  const parsedNode = (() => {\n    if (isSlateNode(el)) {\n      return {};\n    }\n\n    return (\n      parse({\n        ...(getEditorPlugin(editor, plugin) as any),\n        element: el,\n        node: {},\n      }) ?? {}\n    );\n  })();\n\n  const dataNodeProps = getDataNodeProps({\n    editor,\n    element: el,\n    plugin,\n  });\n\n  let node = {\n    ...parsedNode,\n    ...dataNodeProps,\n  };\n\n  if (Object.keys(node).length === 0) return;\n\n  const injectedPlugins = getInjectedPlugins(editor, plugin);\n\n  injectedPlugins.forEach((injectedPlugin) => {\n    const res = injectedPlugin.parsers?.html?.deserializer?.parse?.({\n      ...(getEditorPlugin(editor, plugin) as any),\n      element: el,\n      node,\n    });\n\n    if (res && !isSlateNode(el)) {\n      node = {\n        ...node,\n        ...res,\n      };\n    }\n  });\n\n  if (attributeNames) {\n    const elementAttributes = {};\n\n    const elementAttributeNames = el.getAttributeNames();\n\n    for (const elementAttributeName of elementAttributeNames) {\n      if (attributeNames.includes(elementAttributeName)) {\n        (elementAttributes as any)[elementAttributeName] =\n          el.getAttribute(elementAttributeName);\n      }\n    }\n\n    if (Object.keys(elementAttributes).length > 0) {\n      node.attributes = elementAttributes;\n    }\n  }\n\n  return { ...deserializer, node };\n};\n","import type { SlateEditor } from '../../../editor';\n\nimport { type AnyEditorPlugin, getEditorPlugin } from '../../../plugin';\nimport { isSlateLeaf, isSlatePluginNode } from '../../../static';\n\nconst getDefaultNodeProps = ({\n  element,\n  type,\n}: {\n  element: HTMLElement;\n  type: string;\n}) => {\n  if (!isSlatePluginNode(element, type) && !isSlateLeaf(element)) return;\n\n  const dataAttributes: Record<string, any> = {};\n\n  // Get all data-slate-* attributes from dataset\n  Object.entries(element.dataset).forEach(([key, value]) => {\n    if (\n      key.startsWith('slate') &&\n      value &&\n      // Ignore slate default attributes\n      !['slateInline', 'slateLeaf', 'slateNode', 'slateVoid'].includes(key)\n    ) {\n      // Remove 'slate' prefix and convert to camelCase\n      const attributeKey = key.slice(5).charAt(0).toLowerCase() + key.slice(6);\n\n      // Parse value if it's a boolean or number string\n\n      if (value === undefined) return;\n\n      let parsedValue: any = value;\n\n      if (value === 'true') parsedValue = true;\n      else if (value === 'false') parsedValue = false;\n      else if (!Number.isNaN(Number(value))) parsedValue = Number(value);\n\n      dataAttributes[attributeKey] = parsedValue;\n    }\n  });\n\n  if (Object.keys(dataAttributes).length > 0) {\n    return dataAttributes;\n  }\n};\n\nexport const getDataNodeProps = ({\n  editor,\n  element,\n  plugin,\n}: {\n  editor: SlateEditor;\n  element: HTMLElement;\n  plugin: AnyEditorPlugin;\n}) => {\n  const toNodeProps = plugin.parsers.html?.deserializer?.toNodeProps;\n\n  const disableDefaultNodeProps =\n    plugin.parsers.html?.deserializer?.disableDefaultNodeProps ?? false;\n\n  const defaultNodeProps = disableDefaultNodeProps\n    ? {}\n    : getDefaultNodeProps({\n        ...(getEditorPlugin(editor, plugin) as any),\n        element,\n      });\n\n  if (!toNodeProps) return defaultNodeProps;\n\n  const customNodeProps =\n    toNodeProps({\n      ...(getEditorPlugin(editor, plugin) as any),\n      element,\n    }) ?? {};\n\n  return {\n    ...defaultNodeProps,\n    ...customNodeProps,\n  };\n};\n","import type { AnyObject, Nullable } from '@udecode/utils';\n\nimport type { SlateEditor } from '../../../editor';\nimport type { HtmlDeserializer } from '../../../plugin/SlatePlugin';\n\nimport { pluginDeserializeHtml } from './pluginDeserializeHtml';\n\nexport const pipeDeserializeHtmlElement = (\n  editor: SlateEditor,\n  element: HTMLElement\n) => {\n  let result: (Nullable<HtmlDeserializer> & { node: AnyObject }) | undefined;\n\n  [...editor.pluginList].reverse().some((plugin) => {\n    result = pluginDeserializeHtml(editor, plugin, { element });\n\n    return !!result;\n  });\n\n  return result;\n};\n","import { type Descendant, ElementApi, TextApi } from '@udecode/slate';\nimport { jsx } from 'slate-hyperscript';\n\nimport type { SlateEditor } from '../../../editor';\n\nimport { mergeDeepToNodes } from '../../../utils';\nimport { deserializeHtmlNodeChildren } from './deserializeHtmlNodeChildren';\nimport { pipeDeserializeHtmlLeaf } from './pipeDeserializeHtmlLeaf';\n\n/**\n * Deserialize HTML to Descendant[] with marks on Text. Build the leaf from the\n * leaf deserializers of each plugin.\n */\nexport const htmlElementToLeaf = (\n  editor: SlateEditor,\n  element: HTMLElement\n) => {\n  const node = pipeDeserializeHtmlLeaf(editor, element);\n\n  return deserializeHtmlNodeChildren(editor, element).reduce(\n    (arr: Descendant[], child) => {\n      if (!child) return arr;\n      if (ElementApi.isElement(child)) {\n        if (Object.keys(node).length > 0) {\n          mergeDeepToNodes({\n            node: child,\n            query: {\n              filter: ([n]) => TextApi.isText(n),\n            },\n            source: node,\n          });\n        }\n\n        arr.push(child);\n      } else {\n        const attributes = { ...node };\n\n        // attributes should not override child attributes\n        if (TextApi.isText(child) && child.text) {\n          Object.keys(attributes).forEach((key) => {\n            if (attributes[key] && child[key]) {\n              attributes[key] = child[key];\n            }\n          });\n        }\n\n        arr.push(jsx('text', attributes, child) as any);\n      }\n\n      return arr;\n    },\n    []\n  ) as Descendant[];\n};\n","import type { AnyObject } from '@udecode/utils';\n\nimport type { SlateEditor } from '../../../editor';\n\nimport { pluginDeserializeHtml } from './pluginDeserializeHtml';\n\nexport const pipeDeserializeHtmlLeaf = (\n  editor: SlateEditor,\n  element: HTMLElement\n) => {\n  let node: AnyObject = {};\n\n  [...editor.pluginList].reverse().forEach((plugin) => {\n    const deserialized = pluginDeserializeHtml(editor, plugin, {\n      deserializeLeaf: true,\n      element,\n    });\n\n    if (!deserialized) return;\n\n    node = { ...node, ...deserialized.node };\n  });\n\n  return node;\n};\n","/** Deserialize HTML text node to text. */\nimport { isHtmlText } from './isHtmlText';\n\nexport const htmlTextNodeToString = (node: ChildNode | HTMLElement) => {\n  if (isHtmlText(node)) {\n    if (node.parentElement?.dataset.platePreventDeserialization) return '';\n\n    return node.textContent || '';\n  }\n};\n","import type { SlateEditor } from '../../../editor';\nimport type { DeserializeHtmlNodeReturnType } from '../types';\n\nimport { isSlateNode } from '../../../static';\nimport { htmlBodyToFragment } from './htmlBodyToFragment';\nimport { htmlBrToNewLine } from './htmlBrToNewLine';\nimport { htmlElementToElement } from './htmlElementToElement';\nimport { htmlElementToLeaf } from './htmlElementToLeaf';\nimport { htmlTextNodeToString } from './htmlTextNodeToString';\nimport { isHtmlElement } from './isHtmlElement';\n\n/** Deserialize HTML element or child node. */\nexport const deserializeHtmlNode =\n  (editor: SlateEditor) =>\n  (node: ChildNode | HTMLElement): DeserializeHtmlNodeReturnType => {\n    const textNode = htmlTextNodeToString(node);\n\n    if (textNode) return textNode;\n    if (!isHtmlElement(node)) return null;\n\n    // break line\n    const breakLine = htmlBrToNewLine(node);\n\n    if (breakLine) return breakLine;\n\n    // body\n    const fragment = htmlBodyToFragment(editor, node as HTMLElement);\n\n    if (fragment) return fragment;\n\n    // element\n    const element = htmlElementToElement(\n      editor,\n      node as HTMLElement,\n      isSlateNode(node as HTMLElement)\n    );\n\n    if (element) return element;\n\n    // leaf\n    return htmlElementToLeaf(editor, node as HTMLElement);\n  };\n","import type { SlateEditor } from '../../../editor';\nimport type { DeserializeHtmlNodeReturnType } from '../types';\n\nimport { deserializeHtmlNode } from './deserializeHtmlNode';\n\n/** Deserialize HTML element to fragment. */\nexport const deserializeHtmlElement = (\n  editor: SlateEditor,\n  element: HTMLElement\n): DeserializeHtmlNodeReturnType => {\n  return deserializeHtmlNode(editor)(element);\n};\n","/** Convert HTML string into HTML element. */\nexport const htmlStringToDOMNode = (rawHtml: string) => {\n  const node = document.createElement('body');\n  node.innerHTML = rawHtml;\n\n  return node;\n};\n","import type { Descendant } from '@udecode/slate';\n\nimport type { SlateEditor } from '../../../editor';\nimport type { WithRequiredKey } from '../../../plugin';\n\nimport { normalizeDescendantsToDocumentFragment } from '../../../utils/normalizeDescendantsToDocumentFragment';\nimport { collapseWhiteSpace } from './collapse-white-space';\nimport { deserializeHtmlElement } from './deserializeHtmlElement';\nimport { htmlStringToDOMNode } from './htmlStringToDOMNode';\n\n/** Deserialize HTML element to a valid document fragment. */\nexport const deserializeHtml = (\n  editor: SlateEditor,\n  {\n    collapseWhiteSpace: shouldCollapseWhiteSpace = true,\n    defaultElementPlugin,\n    element,\n  }: {\n    element: HTMLElement | string;\n    collapseWhiteSpace?: boolean;\n    defaultElementPlugin?: WithRequiredKey;\n  }\n): Descendant[] => {\n  // for serializer\n  if (typeof element === 'string') {\n    element = htmlStringToDOMNode(element);\n  }\n  if (shouldCollapseWhiteSpace) {\n    element = collapseWhiteSpace(element);\n  }\n\n  const fragment = deserializeHtmlElement(editor, element) as Descendant[];\n\n  return normalizeDescendantsToDocumentFragment(editor, {\n    defaultElementPlugin,\n    descendants: fragment,\n  });\n};\n","import { traverseHtmlElements } from './traverseHtmlElements';\n\n/**\n * Find the first HTML element that matches the given selector.\n *\n * @param rootNode\n * @param predicate\n */\nexport const findHtmlElement = (\n  rootNode: Node,\n  predicate: (node: HTMLElement) => boolean\n) => {\n  let res: Node | null = null;\n\n  traverseHtmlElements(rootNode, (node) => {\n    if (predicate(node as HTMLElement)) {\n      res = node;\n\n      return false;\n    }\n\n    return true;\n  });\n\n  return res;\n};\n\nexport const someHtmlElement = (\n  rootNode: Node,\n  predicate: (node: HTMLElement) => boolean\n) => {\n  return !!findHtmlElement(rootNode, predicate);\n};\n","const acceptNode = () => NodeFilter.FILTER_ACCEPT;\n\nexport const getHtmlComments = (node: Node): string[] => {\n  const comments: string[] = [];\n  const iterator = document.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {\n    acceptNode,\n  });\n  let currentNode = iterator.nextNode();\n\n  while (currentNode) {\n    if (currentNode.nodeValue) {\n      comments.push(currentNode.nodeValue);\n    }\n\n    currentNode = iterator.nextNode();\n  }\n\n  return comments;\n};\n","export const isHtmlComment = (node: Node): node is Comment =>\n  node.nodeType === Node.COMMENT_NODE;\n","export const isOlSymbol = (symbol: string): boolean => {\n  return /[\\da-np-z]\\S/.test(symbol.toLowerCase());\n};\n","export const parseHtmlDocument = (html: string) => {\n  return new DOMParser().parseFromString(html, 'text/html');\n};\n","import { parseHtmlDocument } from './parseHtmlDocument';\n\nexport const parseHtmlElement = (html: string) => {\n  const { body } = parseHtmlDocument(html);\n\n  return body.firstElementChild as HTMLElement;\n};\n","import { ZERO_WIDTH_SPACE } from '../constants';\n\n/** Trim the html and remove zero width spaces, then wrap it with a body element. */\nexport const postCleanHtml = (html: string): string => {\n  const cleanHtml = html\n    .trim()\n    .replaceAll(new RegExp(ZERO_WIDTH_SPACE, 'g'), '');\n\n  return `<body>${cleanHtml}</body>`;\n};\n","/** Remove string before <html */\nconst removeBeforeHtml = (html: string): string => {\n  const index = html.indexOf('<html');\n\n  if (index === -1) {\n    return html;\n  }\n\n  return html.slice(Math.max(0, index));\n};\n\n/** Remove string after </html> */\nconst removeAfterHtml = (html: string): string => {\n  const index = html.lastIndexOf('</html>');\n\n  if (index === -1) {\n    return html;\n  }\n\n  return html.slice(0, Math.max(0, index + '</html>'.length));\n};\n\n/** Remove string before <html and after </html> */\nexport const removeHtmlSurroundings = (html: string): string => {\n  return removeBeforeHtml(removeAfterHtml(html));\n};\n","import { cleanHtmlCrLf } from './cleanHtmlCrLf';\nimport { removeHtmlSurroundings } from './removeHtmlSurroundings';\n\nconst cleaners = [removeHtmlSurroundings, cleanHtmlCrLf];\n\n/** Remove HTML surroundings and clean HTML from CR/LF */\nexport const preCleanHtml = (html: string): string => {\n  return cleaners.reduce((result, clean) => clean(result), html);\n};\n","import { isHtmlComment } from './isHtmlComment';\nimport { traverseHtmlNode } from './traverseHtmlNode';\n\ntype Callback = (node: Comment) => boolean;\n\n/** Traverse HTML comments. */\nexport const traverseHtmlComments = (\n  rootNode: Node,\n  callback: Callback\n): void => {\n  traverseHtmlNode(rootNode, (node) => {\n    if (!isHtmlComment(node)) {\n      return true;\n    }\n\n    return callback(node);\n  });\n};\n","import { isHtmlComment } from './isHtmlComment';\nimport { traverseHtmlComments } from './traverseHtmlComments';\n\n/** Removes HTML nodes between HTML comments. */\nexport const removeHtmlNodesBetweenComments = (\n  rootNode: Node,\n  start: string,\n  end: string\n): void => {\n  const isClosingComment = (node: Node) =>\n    isHtmlComment(node) && node.data === end;\n\n  traverseHtmlComments(rootNode, (comment) => {\n    if (comment.data === start) {\n      let node = comment.nextSibling;\n\n      comment.remove();\n\n      while (node && !isClosingComment(node)) {\n        const { nextSibling } = node;\n        node.remove();\n        node = nextSibling;\n      }\n\n      if (node && isClosingComment(node)) {\n        node.remove();\n      }\n    }\n\n    return true;\n  });\n};\n","import type { LengthConfig } from '../getCorePlugins';\n\nimport { createTSlatePlugin } from '../../plugin';\n\nexport const LengthPlugin = createTSlatePlugin<LengthConfig>({\n  key: 'length',\n}).overrideEditor(({ editor, getOptions, tf: { apply } }) => ({\n  transforms: {\n    apply(operation) {\n      editor.tf.withoutNormalizing(() => {\n        apply(operation);\n\n        const options = getOptions();\n\n        if (options.maxLength) {\n          const length = editor.api.string([]).length;\n\n          // Make sure to remove overflow of text beyond character limit\n          if (length > options.maxLength) {\n            const overflowLength = length - options.maxLength;\n\n            editor.tf.delete({\n              distance: overflowLength,\n              reverse: true,\n              unit: 'character',\n            });\n          }\n        }\n      });\n    },\n  },\n}));\n","import { type PluginConfig, createSlatePlugin } from '../../plugin';\n\nexport type ParagraphConfig = PluginConfig<'p'>;\n\nexport const BaseParagraphPlugin = createSlatePlugin({\n  key: 'p',\n  node: {\n    isElement: true,\n  },\n  parsers: {\n    html: {\n      deserializer: {\n        rules: [\n          {\n            validNodeName: 'P',\n          },\n        ],\n        query: ({ element }) => element.style.fontFamily !== 'Consolas',\n      },\n    },\n  },\n});\n","import type { Descendant, TRange, Value } from '@udecode/slate';\n\nimport { createSlatePlugin } from '../../plugin';\nimport { BaseParagraphPlugin } from '../paragraph';\n\n/** Opinionated extension of slate default behavior. */\nexport const SlateExtensionPlugin = createSlatePlugin({\n  key: 'slateExtension',\n})\n  .overrideEditor(\n    ({\n      editor,\n      tf: { apply, deleteBackward, deleteForward, deleteFragment },\n    }) => {\n      const resetMarks = () => {\n        if (editor.api.isAt({ start: true })) {\n          editor.tf.removeMarks();\n        }\n      };\n\n      return {\n        api: {\n          create: {\n            block: (node) => ({\n              children: [{ text: '' }],\n              type: editor.getType(BaseParagraphPlugin),\n              ...node,\n            }),\n          },\n        },\n        transforms: {\n          apply(operation) {\n            if (operation.type === 'set_selection') {\n              const { properties } = operation;\n              editor.prevSelection = properties as TRange | null;\n              apply(operation);\n              editor.currentKeyboardEvent = null;\n\n              return;\n            }\n\n            apply(operation);\n          },\n          deleteBackward(unit) {\n            deleteBackward(unit);\n            resetMarks();\n          },\n          deleteForward(unit) {\n            deleteForward(unit);\n            resetMarks();\n          },\n          deleteFragment(options) {\n            deleteFragment(options);\n            resetMarks();\n          },\n        },\n      };\n    }\n  )\n  .extendEditorTransforms(({ editor }) => ({\n    setValue: <V extends Value>(value?: V | string) => {\n      let children: Descendant[] = value as any;\n\n      if (typeof value === 'string') {\n        children = editor.api.html.deserialize({\n          element: value,\n        });\n      } else if (!value || value.length === 0) {\n        children = editor.api.create.value();\n      }\n\n      editor.tf.replaceNodes(children, {\n        at: [],\n        children: true,\n      });\n    },\n  }));\n","import type { AnySlatePlugin, SlatePluginContext } from '../plugin';\n\nexport const omitPluginContext = <T extends SlatePluginContext<AnySlatePlugin>>(\n  ctx: T\n) => {\n  const {\n    api,\n    editor,\n    getOption,\n    getOptions,\n    plugin,\n    setOption,\n    setOptions,\n    tf,\n    type,\n    ...rest\n  } = ctx;\n\n  return rest;\n};\n","import defaultsDeep from 'lodash/defaultsDeep.js';\n\nimport type { AnySlatePlugin } from '../plugin/SlatePlugin';\n\n/**\n * Recursive deep merge of each plugin from `override.plugins` into plugin with\n * same key (plugin > plugin.plugins).\n */\nexport const overridePluginsByKey = (\n  plugin: AnySlatePlugin,\n  overrideByKey: Record<string, Partial<AnySlatePlugin>> = {},\n  nested = false\n): AnySlatePlugin => {\n  if (overrideByKey[plugin.key]) {\n    const {\n      __extensions: pluginOverridesExtensions,\n      plugins: pluginOverridesPlugins,\n      ...pluginOverrides\n    } = overrideByKey[plugin.key];\n\n    // Override plugin\n    plugin = defaultsDeep({}, pluginOverrides, plugin);\n\n    // Merge __extensions\n    if (pluginOverridesExtensions) {\n      plugin.__extensions = [\n        ...(plugin.__extensions || []),\n        ...pluginOverridesExtensions,\n      ];\n    }\n    if (!nested) {\n      // Concat new pluginOverrides.plugins to plugin.plugins\n      pluginOverridesPlugins?.forEach((pOverrides) => {\n        if (!plugin.plugins) plugin.plugins = [];\n\n        const found = plugin.plugins.find((p) => p.key === pOverrides.key);\n\n        if (!found) plugin.plugins.push(pOverrides);\n      });\n    }\n  }\n  if (plugin.plugins) {\n    // Override plugin.plugins\n    plugin.plugins = plugin.plugins.map((p) =>\n      overridePluginsByKey(p, overrideByKey, true)\n    );\n  }\n\n  return plugin;\n};\n","import type { SlateEditor } from '../editor';\nimport type { ParserOptions } from '../plugin/BasePlugin';\nimport type { AnyEditorPlugin } from '../plugin/SlatePlugin';\n\nimport { getEditorPlugin } from '../plugin';\n\n/** Is the plugin disabled by another plugin. */\nexport const pipeInsertDataQuery = (\n  editor: SlateEditor,\n  plugins: Partial<AnyEditorPlugin>[],\n  { data, dataTransfer }: ParserOptions\n) =>\n  plugins.every((p) => {\n    const query = p.parser?.query;\n\n    return (\n      !query ||\n      query({\n        ...getEditorPlugin(editor, p as any),\n        data,\n        dataTransfer,\n      })\n    );\n  });\n","import {\n  assignLegacyApi,\n  assignLegacyTransforms,\n  syncLegacyMethods,\n} from '@udecode/slate';\nimport { isDefined } from '@udecode/utils';\nimport merge from 'lodash/merge.js';\nimport { createZustandStore } from 'zustand-x';\n\nimport type { SlateEditor } from '../editor';\n\nimport { resolvePlugin } from '../../internal/plugin/resolvePlugin';\nimport { mergePlugins } from '../../internal/utils/mergePlugins';\nimport {\n  type SlatePlugin,\n  type SlatePlugins,\n  getEditorPlugin,\n} from '../plugin';\n\n/**\n * Initialize and configure the editor's plugin system. This function sets up\n * the editor's plugins, resolving core and custom plugins, and applying any\n * overrides specified in the plugins.\n */\nexport const resolvePlugins = (\n  editor: SlateEditor,\n  plugins: SlatePlugins = []\n) => {\n  editor.pluginList = [];\n  editor.plugins = {};\n  editor.shortcuts = {} as any;\n\n  const resolvedPlugins = resolveAndSortPlugins(editor, plugins);\n\n  applyPluginsToEditor(editor, resolvedPlugins);\n\n  resolvePluginOverrides(editor);\n\n  resolvePluginStores(editor);\n\n  // extendEditor\n  editor.pluginList.forEach((plugin) => {\n    if (plugin.extendEditor) {\n      editor = plugin.extendEditor(getEditorPlugin(editor, plugin) as any);\n\n      // Sync any editor methods that were modified by extendEditor\n      syncLegacyMethods(editor);\n    }\n\n    // Sync overridden plugin methods to legacy editor methods\n    resolvePluginMethods(editor, plugin);\n  });\n\n  resolvePluginShortcuts(editor);\n\n  return editor;\n};\n\nconst resolvePluginStores = (editor: SlateEditor) => {\n  // Create zustand stores for each plugin\n  editor.pluginList.forEach((plugin) => {\n    let store = createZustandStore(plugin.options, {\n      mutative: true,\n      name: plugin.key,\n    });\n\n    // Apply option extensions\n    if (\n      (plugin as any).__selectorExtensions &&\n      (plugin as any).__selectorExtensions.length > 0\n    ) {\n      (plugin as any).__selectorExtensions.forEach((extension: any) => {\n        const extendedOptions = extension(getEditorPlugin(editor, plugin));\n\n        store = store.extendSelectors(() => extendedOptions);\n      });\n    }\n\n    plugin.optionsStore = store;\n  });\n};\n\nconst resolvePluginMethods = (editor: SlateEditor, plugin: any) => {\n  // Merge APIs\n  Object.entries(plugin.api).forEach(([apiKey, apiFunction]) => {\n    (editor.api as any)[apiKey] = apiFunction;\n  });\n\n  // Apply API and transform extensions\n  if (plugin.__apiExtensions && plugin.__apiExtensions.length > 0) {\n    plugin.__apiExtensions.forEach(\n      ({ extension, isOverride, isPluginSpecific, isTransform }: any) => {\n        const newExtensions = extension(getEditorPlugin(editor, plugin) as any);\n\n        if (isOverride) {\n          // Handle combined API and transforms override\n          if (newExtensions.api) {\n            merge(editor.api, newExtensions.api);\n            merge(plugin.api, newExtensions.api);\n            assignLegacyApi(editor, editor.api);\n          }\n          if (newExtensions.transforms) {\n            merge(editor.transforms, newExtensions.transforms);\n            merge(plugin.transforms, newExtensions.transforms);\n            assignLegacyTransforms(editor, newExtensions.transforms);\n          }\n        } else if (isTransform) {\n          // Handle transforms\n          if (isPluginSpecific) {\n            // Plugin-specific transform\n            if (!(editor.transforms as any)[plugin.key]) {\n              (editor.transforms as any)[plugin.key] = {};\n            }\n            if (!(plugin.transforms as any)[plugin.key]) {\n              (plugin.transforms as any)[plugin.key] = {};\n            }\n\n            merge((editor.transforms as any)[plugin.key], newExtensions);\n            merge((plugin.transforms as any)[plugin.key], newExtensions);\n          } else {\n            // Editor-wide transform\n            merge(editor.transforms, newExtensions);\n            merge(plugin.transforms, newExtensions);\n            assignLegacyTransforms(editor, newExtensions);\n          }\n        } else {\n          // Handle APIs\n          if (isPluginSpecific) {\n            // Plugin-specific API\n            if (!(editor.api as any)[plugin.key]) {\n              (editor.api as any)[plugin.key] = {};\n            }\n            if (!(plugin.api as any)[plugin.key]) {\n              (plugin.api as any)[plugin.key] = {};\n            }\n\n            merge((editor.api as any)[plugin.key], newExtensions);\n            merge((plugin.api as any)[plugin.key], newExtensions);\n          } else {\n            // Editor-wide API\n            merge(editor.api, newExtensions);\n            merge(plugin.api, newExtensions);\n            assignLegacyApi(editor, editor.api);\n          }\n        }\n      }\n    );\n    delete plugin.__apiExtensions;\n  }\n};\n\nconst resolvePluginShortcuts = (editor: SlateEditor) => {\n  const shortcutsByPriority: any[] = [];\n\n  editor.pluginList.forEach((plugin) => {\n    // Merge shortcuts\n    Object.entries(plugin.shortcuts).forEach(([key, hotkey]) => {\n      if (hotkey === null) {\n        // Remove any existing hotkey with this key\n        const index = shortcutsByPriority.findIndex((item) => item.key === key);\n\n        if (index !== -1) {\n          shortcutsByPriority.splice(index, 1);\n        }\n      } else {\n        const priority = (hotkey as any).priority ?? plugin.priority;\n        const existingIndex = shortcutsByPriority.findIndex(\n          (item) => item.key === key\n        );\n\n        if (\n          existingIndex === -1 ||\n          priority >= shortcutsByPriority[existingIndex].priority\n        ) {\n          if (existingIndex !== -1) {\n            shortcutsByPriority.splice(existingIndex, 1);\n          }\n\n          shortcutsByPriority.push({ key, hotkey, priority });\n        }\n      }\n    });\n  });\n\n  // Sort shortcuts by priority (descending)\n  shortcutsByPriority.sort((a, b) => b.hotkey.priority - a.hotkey.priority);\n\n  // After processing all plugins, set the final shortcuts on the editor\n  editor.shortcuts = Object.fromEntries(\n    shortcutsByPriority.map(({ key, hotkey }) => {\n      const { priority, ...hotkeyWithoutPriority } = hotkey;\n\n      return [key, hotkeyWithoutPriority];\n    })\n  );\n};\n\nconst flattenAndResolvePlugins = (\n  editor: SlateEditor,\n  plugins: SlatePlugins\n): Map<string, SlatePlugin> => {\n  const pluginMap = new Map<string, SlatePlugin>();\n\n  const processPlugin = (plugin: SlatePlugin) => {\n    const resolvedPlugin = resolvePlugin(editor, plugin);\n    const existingPlugin = pluginMap.get(resolvedPlugin.key);\n\n    if (existingPlugin) {\n      pluginMap.set(\n        resolvedPlugin.key,\n        mergePlugins(existingPlugin, resolvedPlugin)\n      );\n    } else {\n      pluginMap.set(resolvedPlugin.key, resolvedPlugin);\n    }\n    if (resolvedPlugin.plugins && resolvedPlugin.plugins.length > 0) {\n      resolvedPlugin.plugins.forEach(processPlugin);\n    }\n  };\n\n  plugins.forEach(processPlugin);\n\n  return pluginMap;\n};\n\nexport const resolveAndSortPlugins = (\n  editor: SlateEditor,\n  plugins: SlatePlugins\n): SlatePlugins => {\n  // Step 1: Resolve, flatten, and merge all plugins\n  const pluginMap = flattenAndResolvePlugins(editor, plugins);\n\n  // Step 2: Filter out disabled plugins\n  const enabledPlugins = Array.from(pluginMap.values()).filter(\n    (plugin) => plugin.enabled !== false\n  );\n\n  // Step 3: Sort plugins by priority\n  enabledPlugins.sort((a, b) => b.priority - a.priority);\n\n  // Step 4: Reorder based on dependencies\n  const orderedPlugins: SlatePlugins = [];\n  const visited = new Set<string>();\n\n  const visit = (plugin: SlatePlugin) => {\n    if (visited.has(plugin.key)) return;\n\n    visited.add(plugin.key);\n\n    plugin.dependencies?.forEach((depKey) => {\n      const depPlugin = pluginMap.get(depKey);\n\n      if (depPlugin) {\n        visit(depPlugin);\n      } else {\n        editor.api.debug.warn(\n          `Plugin \"${plugin.key}\" depends on missing plugin \"${depKey}\"`,\n          'PLUGIN_DEPENDENCY_MISSING'\n        );\n      }\n    });\n\n    orderedPlugins.push(plugin);\n  };\n\n  enabledPlugins.forEach(visit);\n\n  return orderedPlugins;\n};\n\nexport const applyPluginsToEditor = (\n  editor: SlateEditor,\n  plugins: SlatePlugins\n) => {\n  editor.pluginList = plugins;\n  editor.plugins = Object.fromEntries(\n    plugins.map((plugin) => [plugin.key, plugin])\n  );\n};\n\nexport const resolvePluginOverrides = (editor: SlateEditor) => {\n  const applyOverrides = (plugins: SlatePlugin[]): SlatePlugin[] => {\n    let overriddenPlugins = [...plugins];\n\n    const enabledOverrides: Record<string, boolean> = {};\n    const componentOverrides: Record<\n      string,\n      { component: any; priority: number }\n    > = {};\n    const pluginOverrides: Record<string, Partial<SlatePlugin>> = {};\n\n    // Collect all overrides\n    for (const plugin of plugins) {\n      if (plugin.override.enabled) {\n        Object.assign(enabledOverrides, plugin.override.enabled);\n      }\n      // TODO react\n      if ((plugin.override as any).components) {\n        Object.entries((plugin.override as any).components).forEach(\n          ([key, component]) => {\n            if (\n              !componentOverrides[key] ||\n              plugin.priority > componentOverrides[key].priority\n            ) {\n              componentOverrides[key] = {\n                component,\n                priority: plugin.priority,\n              };\n            }\n          }\n        );\n      }\n      if (plugin.override.plugins) {\n        Object.entries(plugin.override.plugins).forEach(([key, value]) => {\n          pluginOverrides[key] = mergePlugins(pluginOverrides[key], value);\n\n          if (value.enabled !== undefined) {\n            enabledOverrides[key] = value.enabled;\n          }\n        });\n      }\n    }\n\n    // Apply overrides\n    overriddenPlugins = overriddenPlugins.map((p) => {\n      let updatedPlugin = { ...p };\n\n      // Apply plugin overrides\n      if (pluginOverrides[p.key]) {\n        updatedPlugin = mergePlugins(updatedPlugin, pluginOverrides[p.key]);\n      }\n      // Apply component overrides\n      // TODO react\n      if (\n        componentOverrides[p.key] &&\n        ((!(p as any).render.node && !(p as any).node.component) ||\n          componentOverrides[p.key].priority > p.priority)\n      ) {\n        (updatedPlugin as any).render.node =\n          componentOverrides[p.key].component;\n        (updatedPlugin as any).node.component =\n          componentOverrides[p.key].component;\n      }\n\n      // Apply enabled overrides\n      const enabled = enabledOverrides[p.key] ?? updatedPlugin.enabled;\n\n      if (isDefined(enabled)) {\n        updatedPlugin.enabled = enabled;\n      }\n\n      return updatedPlugin;\n    });\n\n    return overriddenPlugins\n      .filter((p) => p.enabled !== false)\n      .map((plugin) => ({\n        ...plugin,\n        plugins: applyOverrides(plugin.plugins || []),\n      }));\n  };\n\n  editor.pluginList = applyOverrides(editor.pluginList as any);\n  editor.plugins = Object.fromEntries(\n    editor.pluginList.map((plugin) => [plugin.key, plugin])\n  );\n};\n","import { pipeInsertFragment } from '../../internal/plugin/pipeInsertFragment';\nimport { pipeTransformData } from '../../internal/plugin/pipeTransformData';\nimport { pipeTransformFragment } from '../../internal/plugin/pipeTransformFragment';\nimport { createSlatePlugin, getEditorPlugin } from '../plugin';\nimport { getInjectedPlugins } from '../utils';\nimport { pipeInsertDataQuery } from '../utils/pipeInsertDataQuery';\n\nexport const ParserPlugin = createSlatePlugin({\n  key: 'parser',\n}).overrideEditor(({ editor, tf: { insertData } }) => ({\n  transforms: {\n    insertData(dataTransfer: DataTransfer) {\n      const inserted = [...editor.pluginList].reverse().some((plugin) => {\n        const parser = plugin.parser;\n\n        if (!parser) return false;\n\n        const injectedPlugins = getInjectedPlugins(editor, plugin);\n        const { deserialize, format, mimeTypes } = parser;\n\n        if (!format) return false;\n\n        // Handle both string and string[] formats\n        const formats = Array.isArray(format) ? format : [format];\n        const mimeTypeList =\n          mimeTypes ||\n          formats.map((fmt) => (fmt.includes('/') ? fmt : `text/${fmt}`));\n\n        for (const mimeType of mimeTypeList) {\n          let data = dataTransfer.getData(mimeType);\n\n          if (!data) continue;\n          if (\n            !pipeInsertDataQuery(editor, injectedPlugins, {\n              data,\n              dataTransfer,\n            })\n          ) {\n            continue;\n          }\n\n          data = pipeTransformData(editor, injectedPlugins, {\n            data,\n            dataTransfer,\n          });\n\n          let fragment = deserialize?.({\n            ...getEditorPlugin(editor, plugin),\n            data,\n            dataTransfer,\n          });\n\n          if (!fragment?.length) continue;\n\n          fragment = pipeTransformFragment(editor, injectedPlugins, {\n            data,\n            dataTransfer,\n            fragment,\n          });\n\n          if (fragment.length === 0) continue;\n\n          pipeInsertFragment(editor, injectedPlugins, {\n            data,\n            dataTransfer,\n            fragment,\n          });\n\n          return true;\n        }\n\n        return false;\n      });\n\n      if (inserted) return;\n\n      insertData(dataTransfer);\n    },\n  },\n}));\n","/* eslint-disable perfectionist/sort-imports */\nimport type { AnyPluginConfig, PluginConfig } from '../plugin/BasePlugin';\nimport type { SlatePlugin } from '../plugin/SlatePlugin';\n\nimport { AstPlugin } from './AstPlugin';\nimport { DOMPlugin } from './DOMPlugin';\nimport { HistoryPlugin } from './HistoryPlugin';\nimport { InlineVoidPlugin } from './InlineVoidPlugin';\nimport { ParserPlugin } from './ParserPlugin';\nimport { type DebugErrorType, type LogLevel, DebugPlugin } from './debug';\nimport { HtmlPlugin } from './html';\nimport { LengthPlugin } from './length';\nimport { BaseParagraphPlugin } from './paragraph';\nimport { SlateExtensionPlugin } from './slate-extension';\n\nexport type CorePlugin = ReturnType<typeof getCorePlugins>[number];\n\nexport type GetCorePluginsOptions = {\n  /** Specifies the maximum number of characters allowed in the editor. */\n  maxLength?: number;\n  /** Override the core plugins using the same key. */\n  plugins?: AnyPluginConfig[];\n};\n\nexport const getCorePlugins = ({\n  maxLength,\n  plugins = [],\n}: GetCorePluginsOptions) => {\n  let corePlugins = [\n    DebugPlugin as SlatePlugin<DebugConfig>,\n    SlateExtensionPlugin,\n    DOMPlugin,\n    HistoryPlugin,\n    InlineVoidPlugin,\n    ParserPlugin,\n    maxLength\n      ? LengthPlugin.configure({\n          options: { maxLength },\n        })\n      : LengthPlugin,\n    HtmlPlugin,\n    AstPlugin,\n    BaseParagraphPlugin,\n  ];\n\n  // Create a map for quick lookup of custom plugins\n  const customPluginsMap = new Map(\n    plugins.map((plugin) => [plugin.key, plugin])\n  );\n\n  // Replace core plugins with custom plugins if they exist and remove them from plugins\n  corePlugins = corePlugins.map((corePlugin) => {\n    const customPlugin = customPluginsMap.get(corePlugin.key);\n\n    if (customPlugin) {\n      // Remove the custom plugin from the plugins array\n      const index = plugins.findIndex((p) => p.key === corePlugin.key);\n\n      if (index !== -1) {\n        plugins.splice(index, 1);\n      }\n\n      return customPlugin;\n    }\n\n    return corePlugin as any;\n  });\n\n  return corePlugins;\n};\n\nexport type DebugConfig = PluginConfig<\n  'debug',\n  {\n    isProduction: boolean;\n    logger: Partial<Record<LogLevel, LogFunction>>;\n    logLevel: LogLevel;\n    throwErrors: boolean;\n  },\n  {\n    debug: {\n      error: (\n        message: string | unknown,\n        type?: DebugErrorType,\n        details?: any\n      ) => void;\n      info: (message: string, type?: DebugErrorType, details?: any) => void;\n      log: (message: string, type?: DebugErrorType, details?: any) => void;\n      warn: (message: string, type?: DebugErrorType, details?: any) => void;\n    };\n  }\n>;\n\nexport type LengthConfig = PluginConfig<\n  'length',\n  {\n    maxLength: number;\n  }\n>;\n\ntype LogFunction = (\n  message: string,\n  type?: DebugErrorType,\n  details?: any\n) => void;\n","export { nanoid } from 'nanoid';\n","export type { TStateApi as ZustandStoreApi } from 'zustand-x';\n\nexport { createZustandStore } from 'zustand-x';\n"],"mappings":"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","names":["config","result","merge","merge","plugin","React","React","React","clsx","clsx","isDefined","isDefined","clsx","clsx","node","React","React","React","React","clsx","clsx","React","React","React","React","ElementApi","TextApi","clsx","React","TextApi","ElementApi","clsx","React","merge","merge","ElementApi","TextApi","jsx","isDefined","castArray","castArray","isDefined","jsx","ElementApi","TextApi","jsx","ElementApi","TextApi","jsx","document","TextApi","ElementApi","assignLegacyApi","assignLegacyTransforms","syncLegacyMethods","isDefined","merge","createZustandStore","resolvePlugins","resolveAndSortPlugins","applyPluginsToEditor","resolvePluginOverrides","resolvePluginStores","syncLegacyMethods","resolvePluginMethods","resolvePluginShortcuts","createZustandStore","merge","assignLegacyApi","assignLegacyTransforms","flattenAndResolvePlugins","isDefined","nanoid","createZustandStore"]}