{"version":3,"sources":["../../src/react/TablePlugin.tsx","../../src/lib/BaseTablePlugin.ts","../../src/lib/api/getEmptyCellNode.ts","../../src/lib/api/getEmptyRowNode.ts","../../src/lib/api/getEmptyTableNode.ts","../../src/lib/merge/deleteColumn.ts","../../src/lib/constants.ts","../../src/lib/utils/computeCellIndices.ts","../../src/lib/utils/getCellIndices.ts","../../src/lib/utils/getCellRowIndexByPath.ts","../../src/lib/utils/getCellType.ts","../../src/lib/normalizeInitialValueTable.ts","../../src/lib/withApplyTable.ts","../../src/lib/transforms/overrideSelectionFromCell.ts","../../src/lib/transforms/moveSelectionFromCell.ts","../../src/lib/queries/getTableGridAbove.ts","../../src/lib/queries/getTableGridByRange.ts","../../src/lib/merge/getTableGridByRange.ts","../../src/lib/queries/getColSpan.ts","../../src/lib/queries/getRowSpan.ts","../../src/lib/merge/getCellIndicesWithSpans.ts","../../src/lib/merge/findCellByIndexes.ts","../../src/lib/withDeleteTable.ts","../../src/lib/withGetFragmentTable.ts","../../src/lib/withInsertFragmentTable.ts","../../src/lib/queries/getCellInNextTableRow.ts","../../src/lib/queries/getCellInPreviousTableRow.ts","../../src/lib/queries/getLeftTableCell.ts","../../src/lib/queries/getNextTableCell.ts","../../src/lib/queries/getPreviousTableCell.ts","../../src/lib/queries/getSelectedCellsBoundingBox.ts","../../src/lib/queries/getTopTableCell.ts","../../src/lib/queries/getSelectedCellsBorders.ts","../../src/lib/queries/getTableAbove.ts","../../src/lib/queries/getTableCellBorders.ts","../../src/lib/queries/getTableCellSize.ts","../../src/lib/queries/getTableColumnCount.ts","../../src/lib/queries/getTableEntries.ts","../../src/lib/queries/getTableOverriddenColSizes.ts","../../src/lib/withInsertTextTable.ts","../../src/lib/withMarkTable.tsx","../../src/lib/withNormalizeTable.ts","../../src/lib/withSetFragmentDataTable.ts","../../src/lib/withTable.ts","../../src/lib/transforms/deleteColumn.ts","../../src/lib/merge/deleteColumnWhenExpanded.ts","../../src/lib/transforms/deleteRow.ts","../../src/lib/merge/deleteRow.ts","../../src/lib/merge/deleteRowWhenExpanded.ts","../../src/lib/transforms/deleteTable.ts","../../src/lib/transforms/insertTable.ts","../../src/lib/transforms/insertTableColumn.ts","../../src/lib/merge/insertTableColumn.ts","../../src/lib/merge/getCellPath.ts","../../src/lib/transforms/insertTableRow.ts","../../src/lib/merge/insertTableRow.ts","../../src/lib/transforms/setBorderSize.ts","../../src/lib/transforms/setTableColSize.ts","../../src/lib/transforms/setTableMarginLeft.ts","../../src/lib/transforms/setTableRowSize.ts","../../src/lib/merge/getTableMergedColumnCount.ts","../../src/lib/merge/isTableRectangular.ts","../../src/lib/merge/mergeTableCells.ts","../../src/lib/merge/splitTableCell.ts","../../src/react/onKeyDownTable.ts","../../src/react/components/TableCellElement/getOnSelectTableBorderFactory.ts","../../src/react/components/TableCellElement/roundCellSizeToStep.ts","../../src/react/components/TableCellElement/useIsCellSelected.ts","../../src/react/components/TableCellElement/useTableBordersDropdownMenuContentState.ts","../../src/react/components/TableCellElement/useTableCellBorders.ts","../../src/react/hooks/useCellIndices.ts","../../src/react/components/TableCellElement/useTableCellElement.ts","../../src/react/stores/useTableStore.ts","../../src/react/components/TableCellElement/useTableCellSize.ts","../../src/react/components/TableElement/useSelectedCells.ts","../../src/react/components/TableElement/useTableColSizes.ts","../../src/react/components/TableElement/useTableElement.ts","../../src/react/components/TableCellElement/useTableCellElementResizable.ts","../../src/react/hooks/useTableMergeState.ts"],"sourcesContent":["import { toPlatePlugin } from '@udecode/plate/react';\n\nimport {\n  BaseTableCellHeaderPlugin,\n  BaseTableCellPlugin,\n  BaseTablePlugin,\n  BaseTableRowPlugin,\n} from '../lib/BaseTablePlugin';\nimport { onKeyDownTable } from './onKeyDownTable';\n\nexport const TableRowPlugin = toPlatePlugin(BaseTableRowPlugin);\n\nexport const TableCellPlugin = toPlatePlugin(BaseTableCellPlugin);\n\nexport const TableCellHeaderPlugin = toPlatePlugin(BaseTableCellHeaderPlugin);\n\n/** Enables support for tables with React-specific features. */\nexport const TablePlugin = toPlatePlugin(BaseTablePlugin, {\n  handlers: {\n    onKeyDown: onKeyDownTable,\n  },\n  plugins: [TableRowPlugin, TableCellPlugin, TableCellHeaderPlugin],\n});\n","import {\n  type Descendant,\n  type HtmlDeserializer,\n  type OmitFirst,\n  type PluginConfig,\n  type TElement,\n  bindFirst,\n  createSlatePlugin,\n  createTSlatePlugin,\n} from '@udecode/plate';\n\nimport type { TTableCellElement } from './types';\nimport type { CellIndices } from './utils';\n\nimport { getEmptyCellNode, getEmptyRowNode, getEmptyTableNode } from './api';\nimport { mergeTableCells, splitTableCell } from './merge';\nimport { normalizeInitialValueTable } from './normalizeInitialValueTable';\nimport {\n  getColSpan,\n  getRowSpan,\n  getTableCellBorders,\n  getTableCellSize,\n} from './queries';\nimport {\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  insertTable,\n  insertTableColumn,\n  insertTableRow,\n} from './transforms/index';\nimport { withTable } from './withTable';\n\nconst parse: HtmlDeserializer['parse'] = ({ element, type }) => {\n  const background = element.style.background || element.style.backgroundColor;\n\n  if (background) {\n    return {\n      background,\n      type,\n    };\n  }\n\n  return { type };\n};\n\nexport const BaseTableRowPlugin = createSlatePlugin({\n  key: 'tr',\n  node: { isElement: true },\n  parsers: {\n    html: {\n      deserializer: {\n        rules: [{ validNodeName: 'TR' }],\n      },\n    },\n  },\n});\n\nexport const BaseTableCellPlugin = createSlatePlugin({\n  key: 'td',\n  node: {\n    dangerouslyAllowAttributes: ['colspan', 'rowspan'],\n    isElement: true,\n    props: ({ element }) => ({\n      nodeProps: {\n        colSpan: (element?.attributes as any)?.colspan,\n        rowSpan: (element?.attributes as any)?.rowspan,\n      },\n    }),\n  },\n  parsers: {\n    html: {\n      deserializer: {\n        attributeNames: ['rowspan', 'colspan'],\n        parse,\n        rules: [{ validNodeName: 'TD' }],\n      },\n    },\n  },\n});\n\nexport const BaseTableCellHeaderPlugin = createSlatePlugin({\n  key: 'th',\n  node: {\n    dangerouslyAllowAttributes: ['colspan', 'rowspan'],\n    isElement: true,\n    props: ({ element }) => ({\n      nodeProps: {\n        colSpan: (element?.attributes as any)?.colspan,\n        rowSpan: (element?.attributes as any)?.rowspan,\n      },\n    }),\n  },\n  parsers: {\n    html: {\n      deserializer: {\n        attributeNames: ['rowspan', 'colspan'],\n        parse,\n        rules: [{ validNodeName: 'TH' }],\n      },\n    },\n  },\n});\n\nexport type TableConfig = PluginConfig<\n  'table',\n  {\n    /** @private Keeps Track of cell indices by id. */\n    _cellIndices: Record<string, { col: number; row: number }>;\n    /** The currently selected cells. */\n    selectedCells: TElement[] | null;\n    /** The currently selected tables. */\n    selectedTables: TElement[] | null;\n    /** Disable expanding the table when inserting cells. */\n    disableExpandOnInsert?: boolean;\n    // Disable first column left resizer.\n    disableMarginLeft?: boolean;\n    /**\n     * Disable cell merging functionality.\n     *\n     * @default false\n     */\n    disableMerge?: boolean;\n    /**\n     * Disable unsetting the first column width when the table has one column.\n     * Set it to true if you want to resize the table width when there is only\n     * one column. Keep it false if you have a full-width table.\n     */\n    enableUnsetSingleColSize?: boolean;\n    /**\n     * If defined, a normalizer will set each undefined table `colSizes` to this\n     * value divided by the number of columns. Merged cells not supported.\n     */\n    initialTableWidth?: number;\n    /**\n     * The minimum width of a column.\n     *\n     * @default 48\n     */\n    minColumnWidth?: number;\n  },\n  {\n    create: {\n      table: OmitFirst<typeof getEmptyTableNode>;\n      /** Cell node factory used each time a cell is created. */\n      tableCell: OmitFirst<typeof getEmptyCellNode>;\n      tableRow: OmitFirst<typeof getEmptyRowNode>;\n    };\n    table: {\n      getCellBorders: OmitFirst<typeof getTableCellBorders>;\n      getCellSize: OmitFirst<typeof getTableCellSize>;\n      getColSpan: typeof getColSpan;\n      getRowSpan: typeof getRowSpan;\n      getCellChildren: (cell: TTableCellElement) => Descendant[];\n    };\n  },\n  {\n    insert: {\n      table: OmitFirst<typeof insertTable>;\n      tableColumn: OmitFirst<typeof insertTableColumn>;\n      tableRow: OmitFirst<typeof insertTableRow>;\n    };\n    remove: {\n      table: OmitFirst<typeof deleteTable>;\n      tableColumn: OmitFirst<typeof deleteColumn>;\n      tableRow: OmitFirst<typeof deleteRow>;\n    };\n    table: {\n      merge: OmitFirst<typeof mergeTableCells>;\n      split: OmitFirst<typeof splitTableCell>;\n    };\n  },\n  {\n    cellIndices?: (id: string) => CellIndices;\n  }\n>;\n\n/** Enables support for tables. */\nexport const BaseTablePlugin = createTSlatePlugin<TableConfig>({\n  key: 'table',\n  // dependencies: [NodeIdPlugin.key],\n  node: {\n    isElement: true,\n  },\n  normalizeInitialValue: normalizeInitialValueTable,\n  options: {\n    _cellIndices: {},\n    disableMerge: false,\n    minColumnWidth: 48,\n    selectedCells: null as TElement[] | null,\n    selectedTables: null as TElement[] | null,\n  },\n  parsers: {\n    html: {\n      deserializer: {\n        rules: [{ validNodeName: 'TABLE' }],\n      },\n    },\n  },\n  plugins: [BaseTableRowPlugin, BaseTableCellPlugin, BaseTableCellHeaderPlugin],\n})\n  .extendSelectors<TableConfig['selectors']>(({ getOptions }) => ({\n    cellIndices: (id) => getOptions()._cellIndices[id],\n  }))\n  .extendEditorApi<TableConfig['api']>(({ editor }) => ({\n    create: {\n      table: bindFirst(getEmptyTableNode, editor),\n      tableCell: bindFirst(getEmptyCellNode, editor),\n      tableRow: bindFirst(getEmptyRowNode, editor),\n    },\n    table: {\n      getCellBorders: bindFirst(getTableCellBorders, editor),\n      getCellSize: bindFirst(getTableCellSize, editor),\n      getColSpan: getColSpan,\n      getRowSpan: getRowSpan,\n      getCellChildren: (cell) => cell.children,\n    },\n  }))\n  .extendEditorTransforms<TableConfig['transforms']>(({ editor }) => ({\n    insert: {\n      table: bindFirst(insertTable, editor),\n      tableColumn: bindFirst(insertTableColumn, editor),\n      tableRow: bindFirst(insertTableRow, editor),\n    },\n    remove: {\n      table: bindFirst(deleteTable, editor),\n      tableColumn: bindFirst(deleteColumn, editor),\n      tableRow: bindFirst(deleteRow, editor),\n    },\n    table: {\n      merge: bindFirst(mergeTableCells, editor),\n      split: bindFirst(splitTableCell, editor),\n    },\n  }))\n  .overrideEditor(withTable);\n","import type { SlateEditor, TElement } from '@udecode/plate';\n\nimport type { CreateCellOptions } from '../types';\n\nimport {\n  BaseTableCellHeaderPlugin,\n  BaseTableCellPlugin,\n} from '../BaseTablePlugin';\n\nexport const getEmptyCellNode = (\n  editor: SlateEditor,\n  { children, header, row }: CreateCellOptions = {}\n) => {\n  header =\n    header ??\n    (row\n      ? (row as TElement).children.every(\n          (c) => c.type === editor.getType(BaseTableCellHeaderPlugin)\n        )\n      : false);\n\n  return {\n    children: children ?? [editor.api.create.block()],\n    type: header\n      ? editor.getType(BaseTableCellHeaderPlugin)\n      : editor.getType(BaseTableCellPlugin),\n  };\n};\n","import type { SlateEditor } from '@udecode/plate';\n\nimport type { CreateCellOptions } from '../types';\n\nimport { type TableConfig, BaseTableRowPlugin } from '../BaseTablePlugin';\n\nexport interface GetEmptyRowNodeOptions extends CreateCellOptions {\n  colCount?: number;\n}\n\nexport const getEmptyRowNode = (\n  editor: SlateEditor,\n  { colCount = 1, ...cellOptions }: GetEmptyRowNodeOptions = {}\n) => {\n  const { api } = editor.getPlugin<TableConfig>({ key: 'table' });\n\n  return {\n    children: Array.from({ length: colCount })\n      .fill(colCount)\n      .map(() => api.create.tableCell(cellOptions)),\n    type: editor.getType(BaseTableRowPlugin),\n  };\n};\n","import type { SlateEditor } from '@udecode/plate';\n\nimport type { TTableElement } from '../types';\nimport type { GetEmptyRowNodeOptions } from './getEmptyRowNode';\n\nimport { type TableConfig, BaseTablePlugin } from '../BaseTablePlugin';\n\nexport interface GetEmptyTableNodeOptions extends GetEmptyRowNodeOptions {\n  rowCount?: number;\n}\n\nexport const getEmptyTableNode = (\n  editor: SlateEditor,\n  {\n    colCount,\n    header,\n    rowCount = 0,\n    ...cellOptions\n  }: GetEmptyTableNodeOptions = {}\n): TTableElement => {\n  const { api } = editor.getPlugin<TableConfig>({ key: 'table' });\n\n  const rows = Array.from({ length: rowCount })\n    .fill(rowCount)\n    .map((_, index) =>\n      api.create.tableRow({\n        colCount,\n        ...cellOptions,\n        header: header && index === 0,\n      })\n    );\n\n  return {\n    children: rows,\n    type: editor.getType(BaseTablePlugin),\n  };\n};\n","import { type Path, type SlateEditor, getEditorPlugin } from '@udecode/plate';\nimport cloneDeep from 'lodash/cloneDeep.js';\n\nimport {\n  type TTableCellElement,\n  type TTableElement,\n  BaseTableRowPlugin,\n  getCellIndices,\n  getCellTypes,\n} from '..';\nimport { BaseTablePlugin } from '../BaseTablePlugin';\nimport { deleteColumnWhenExpanded } from './deleteColumnWhenExpanded';\nimport { findCellByIndexes } from './findCellByIndexes';\nimport { getCellPath } from './getCellPath';\n\nexport const deleteTableMergeColumn = (editor: SlateEditor) => {\n  const type = editor.getType(BaseTablePlugin);\n  const tableEntry = editor.api.above<TTableElement>({\n    match: { type },\n  });\n\n  if (!tableEntry) return;\n\n  editor.tf.withoutNormalizing(() => {\n    const { api } = getEditorPlugin(editor, BaseTablePlugin);\n\n    if (editor.api.isExpanded()) {\n      return deleteColumnWhenExpanded(editor, tableEntry);\n    }\n\n    const table = tableEntry[0] as TTableElement;\n\n    const selectedCellEntry = editor.api.above({\n      match: {\n        type: getCellTypes(editor),\n      },\n    });\n\n    if (!selectedCellEntry) return;\n\n    const selectedCell = selectedCellEntry[0] as TTableCellElement;\n\n    const { col: deletingColIndex } = getCellIndices(editor, selectedCell);\n    const colsDeleteNumber = api.table.getColSpan(selectedCell);\n\n    const endingColIndex = deletingColIndex + colsDeleteNumber - 1;\n\n    const rowNumber = table.children.length;\n    const affectedCellsSet = new Set();\n    // iterating by rows is important here to keep the order of affected cells\n    Array.from({ length: rowNumber }, (_, i) => i).forEach((rI) => {\n      return Array.from({ length: colsDeleteNumber }, (_, i) => i).forEach(\n        (cI) => {\n          const colIndex = deletingColIndex + cI;\n          const found = findCellByIndexes(editor, table, rI, colIndex);\n\n          if (found) {\n            affectedCellsSet.add(found);\n          }\n        }\n      );\n    });\n    const affectedCells = Array.from(affectedCellsSet) as TTableCellElement[];\n\n    const { squizeColSpanCells } = affectedCells.reduce<{\n      squizeColSpanCells: TTableCellElement[];\n    }>(\n      (acc, cur) => {\n        if (!cur) return acc;\n\n        const currentCell = cur as TTableCellElement;\n        const { col: curColIndex } = getCellIndices(editor, currentCell);\n        const curColSpan = api.table.getColSpan(currentCell);\n\n        if (curColIndex < deletingColIndex && curColSpan > 1) {\n          acc.squizeColSpanCells.push(currentCell);\n        } else if (\n          curColSpan > 1 &&\n          curColIndex + curColSpan - 1 > endingColIndex\n        ) {\n          acc.squizeColSpanCells.push(currentCell);\n        }\n\n        return acc;\n      },\n      { squizeColSpanCells: [] }\n    );\n\n    /** Change colSpans */\n    squizeColSpanCells.forEach((cur) => {\n      const curCell = cur as TTableCellElement;\n\n      const { col: curColIndex, row: curColRowIndex } = getCellIndices(\n        editor,\n        curCell\n      );\n      const curColSpan = api.table.getColSpan(curCell);\n\n      const curCellPath = getCellPath(\n        editor,\n        tableEntry,\n        curColRowIndex,\n        curColIndex\n      );\n\n      const curCellEndingColIndex = Math.min(\n        curColIndex + curColSpan - 1,\n        endingColIndex\n      );\n      const colsNumberAffected = curCellEndingColIndex - deletingColIndex + 1;\n      const colSpan = curColSpan - colsNumberAffected;\n      const newCell = cloneDeep({ ...curCell, colSpan });\n\n      if (newCell.attributes?.colspan) {\n        newCell.attributes.colspan = colSpan.toString();\n      }\n\n      editor.tf.setNodes<TTableCellElement>(newCell, { at: curCellPath });\n    });\n\n    const trEntry = editor.api.above({\n      match: { type: editor.getType(BaseTableRowPlugin) },\n    });\n\n    /** Remove cells */\n    if (\n      selectedCell &&\n      trEntry &&\n      tableEntry &&\n      // Cannot delete the last cell\n      trEntry[0].children.length > 1\n    ) {\n      const [tableNode, tablePath] = tableEntry;\n\n      // calc paths to delete\n      const paths: Path[][] = [];\n      affectedCells.forEach((cur) => {\n        const curCell = cur as TTableCellElement;\n        const { col: curColIndex, row: curRowIndex } = getCellIndices(\n          editor,\n          curCell\n        );\n\n        if (\n          !squizeColSpanCells.includes(curCell) &&\n          curColIndex >= deletingColIndex &&\n          curColIndex <= endingColIndex\n        ) {\n          const cellPath = getCellPath(\n            editor,\n            tableEntry,\n            curRowIndex,\n            curColIndex\n          );\n\n          if (!paths[curRowIndex]) {\n            paths[curRowIndex] = [];\n          }\n\n          paths[curRowIndex].push(cellPath);\n        }\n      });\n\n      paths.forEach((cellPaths) => {\n        const pathToDelete = cellPaths[0];\n        cellPaths.forEach(() => {\n          editor.tf.removeNodes({\n            at: pathToDelete,\n          });\n        });\n      });\n\n      const { colSizes } = tableNode;\n\n      if (colSizes) {\n        const newColSizes = [...colSizes];\n        newColSizes.splice(deletingColIndex, 1);\n\n        editor.tf.setNodes<TTableElement>(\n          { colSizes: newColSizes },\n          { at: tablePath }\n        );\n      }\n    }\n  });\n};\n","export const KEY_SHIFT_EDGES = {\n  'shift+down': 'bottom',\n  'shift+left': 'left',\n  'shift+right': 'right',\n  'shift+up': 'top',\n};\n","import { type SlateEditor, getEditorPlugin } from '@udecode/plate';\n\nimport type {\n  TTableCellElement,\n  TTableElement,\n  TTableRowElement,\n} from '../types';\n\nimport { BaseTablePlugin } from '../BaseTablePlugin';\n\nexport function computeCellIndices(\n  editor: SlateEditor,\n  {\n    all,\n    cellNode,\n    tableNode,\n  }: {\n    all?: boolean;\n    cellNode?: TTableCellElement;\n    tableNode?: TTableElement;\n  }\n) {\n  const { api, getOptions, setOption } = getEditorPlugin<\n    typeof BaseTablePlugin\n  >(editor, {\n    key: 'table',\n  });\n\n  if (!tableNode) {\n    if (!cellNode) return;\n\n    tableNode = editor.api.above<TTableElement>({\n      at: cellNode,\n      match: { type: editor.getType(BaseTablePlugin) },\n    })?.[0];\n\n    if (!tableNode) return;\n  }\n\n  const { _cellIndices: prevIndices } = getOptions();\n\n  // Store previous indices to check for changes\n  const cellIndices = { ...prevIndices };\n  let hasIndicesChanged = false;\n\n  const skipCells: boolean[][] = [];\n  let targetIndices: { col: number; row: number } | undefined;\n\n  for (let rowIndex = 0; rowIndex < tableNode.children.length; rowIndex++) {\n    const row = tableNode.children[rowIndex] as TTableRowElement;\n    let colIndex = 0;\n\n    for (const cellElement of row.children as TTableCellElement[]) {\n      while (skipCells[rowIndex]?.[colIndex]) {\n        colIndex++;\n      }\n\n      const currentIndices = { col: colIndex, row: rowIndex };\n      const prevIndicesForCell = prevIndices[cellElement.id!];\n\n      // Check if indices changed for this cell\n      if (\n        prevIndicesForCell?.col !== currentIndices.col ||\n        prevIndicesForCell?.row !== currentIndices.row\n      ) {\n        hasIndicesChanged = true;\n      }\n\n      cellIndices[cellElement.id!] = currentIndices;\n\n      if (cellElement.id === cellNode?.id) {\n        targetIndices = currentIndices;\n\n        if (!all) break;\n      }\n\n      const colSpan = api.table.getColSpan(cellElement);\n      const rowSpan = api.table.getRowSpan(cellElement);\n\n      for (let r = 0; r < rowSpan; r++) {\n        skipCells[rowIndex + r] = skipCells[rowIndex + r] || [];\n\n        for (let c = 0; c < colSpan; c++) {\n          skipCells[rowIndex + r][colIndex + c] = true;\n        }\n      }\n\n      colIndex += colSpan;\n    }\n  }\n\n  if (hasIndicesChanged) {\n    setOption('_cellIndices', cellIndices);\n  }\n\n  return targetIndices;\n}\n","import { type SlateEditor, getEditorPlugin } from '@udecode/plate';\n\nimport type { TableConfig } from '../BaseTablePlugin';\nimport type { TTableCellElement } from '../types';\n\nimport { computeCellIndices } from './computeCellIndices';\n\nexport type CellIndices = {\n  col: number;\n  row: number;\n};\n\nexport const getCellIndices = (\n  editor: SlateEditor,\n  element: TTableCellElement\n): CellIndices => {\n  const { getOption } = getEditorPlugin<TableConfig>(editor, {\n    key: 'table',\n  });\n\n  let indices = getOption('cellIndices', element.id!);\n\n  if (!indices) {\n    indices = computeCellIndices(editor, {\n      cellNode: element,\n    })!;\n\n    if (!indices) {\n      editor.api.debug.warn(\n        'No cell indices found for element. Make sure all table cells have an id.',\n        'TABLE_CELL_INDICES'\n      );\n    }\n  }\n\n  return indices ?? { col: 0, row: 0 };\n};\n","import type { Path } from '@udecode/plate';\n\nexport const getCellRowIndexByPath = (cellPath: Path): number => {\n  const index = cellPath.at(-2);\n\n  if (index === undefined)\n    throw new Error(`can not get rowIndex of path ${cellPath}`);\n\n  return index;\n};\n","import { type SlateEditor, getPluginTypes } from '@udecode/plate';\n\nimport {\n  BaseTableCellHeaderPlugin,\n  BaseTableCellPlugin,\n} from '../BaseTablePlugin';\n\n/** Get td and th types */\nexport const getCellTypes = (editor: SlateEditor) =>\n  getPluginTypes(editor, [BaseTableCellPlugin, BaseTableCellHeaderPlugin]);\n","import type { NormalizeInitialValue } from '@udecode/plate';\n\nimport type { TableConfig } from './BaseTablePlugin';\nimport type { TTableElement } from './types';\n\nimport { computeCellIndices } from './utils';\n\nexport const normalizeInitialValueTable: NormalizeInitialValue<TableConfig> = ({\n  editor,\n  type,\n}) => {\n  const tables = editor.api.nodes<TTableElement>({\n    at: [],\n    match: { type },\n  });\n\n  for (const [table] of tables) {\n    computeCellIndices(editor, {\n      tableNode: table,\n    });\n  }\n};\n","import {\n  type OverrideEditor,\n  type TElement,\n  type TRange,\n  RangeApi,\n} from '@udecode/plate';\n\nimport type {\n  TTableCellElement,\n  TTableElement,\n  TTableRowElement,\n} from './types';\n\nimport { type TableConfig, BaseTableRowPlugin } from './BaseTablePlugin';\nimport { overrideSelectionFromCell } from './transforms/overrideSelectionFromCell';\nimport { computeCellIndices, getCellTypes } from './utils';\n\n// TODO: tests\n\n/**\n * Selection table:\n *\n * - If anchor is in table, focus in a block before: set focus to start of table\n * - If anchor is in table, focus in a block after: set focus to end of table\n * - If focus is in table, anchor in a block before: set focus to end of table\n * - If focus is in table, anchor in a block after: set focus to the point before\n *   start of table\n */\nexport const withApplyTable: OverrideEditor<TableConfig> = ({\n  editor,\n  getOptions,\n  tf: { apply },\n  type: tableType,\n}) => ({\n  transforms: {\n    apply(op) {\n      if (op.type === 'set_selection' && op.newProperties) {\n        const newSelection = {\n          ...editor.selection,\n          ...op.newProperties,\n        } as TRange | null;\n\n        if (\n          RangeApi.isRange(newSelection) &&\n          editor.api.isAt({\n            at: newSelection,\n            blocks: true,\n            match: (n) => n.type === tableType,\n          })\n        ) {\n          const anchorEntry = editor.api.block({\n            at: newSelection.anchor,\n            match: (n) => n.type === tableType,\n          });\n\n          if (anchorEntry) {\n            const [, anchorPath] = anchorEntry;\n            const isBackward = RangeApi.isBackward(newSelection);\n\n            if (isBackward) {\n              op.newProperties.focus = editor.api.start(anchorPath);\n            } else {\n              const pointBefore = editor.api.before(anchorPath);\n\n              // if the table is the first block\n              if (pointBefore) {\n                op.newProperties.focus = editor.api.end(anchorPath);\n              }\n            }\n          } else {\n            const focusEntry = editor.api.block({\n              at: newSelection.focus,\n              match: (n) => n.type === tableType,\n            });\n\n            if (focusEntry) {\n              const [, focusPath] = focusEntry;\n              const isBackward = RangeApi.isBackward(newSelection);\n\n              if (isBackward) {\n                const startPoint = editor.api.start(focusPath)!;\n                const pointBefore = editor.api.before(startPoint);\n                op.newProperties.focus = pointBefore ?? startPoint;\n              } else {\n                op.newProperties.focus = editor.api.end(focusPath);\n              }\n            }\n          }\n        }\n\n        overrideSelectionFromCell(editor, newSelection);\n      }\n\n      const opType =\n        op.type === 'remove_node'\n          ? (op.node.type as string)\n          : op.type === 'move_node'\n            ? editor.api.node<TElement>(op.path)?.[0].type\n            : undefined;\n\n      const isTableOperation =\n        (op.type === 'remove_node' || op.type === 'move_node') &&\n        opType &&\n        [\n          editor.getType(BaseTableRowPlugin),\n          tableType,\n          ...getCellTypes(editor),\n        ].includes(opType as string);\n\n      // Cleanup cell indices when removing a table cell\n      if (isTableOperation && op.type === 'remove_node') {\n        const cells = [\n          ...editor.api.nodes<TTableCellElement>({\n            at: op.path,\n            match: { type: getCellTypes(editor) },\n          }),\n        ];\n\n        const cellIndices = getOptions()._cellIndices;\n\n        cells.forEach(([cell]) => {\n          delete cellIndices[cell.id as string];\n        });\n      }\n\n      apply(op);\n\n      let table: TTableElement | undefined;\n\n      if (\n        isTableOperation &&\n        // There is no new indices when moving/removing a table\n        opType !== tableType\n      ) {\n        table = editor.api.node<TTableRowElement>({\n          at: op.type === 'move_node' ? op.newPath : op.path,\n          match: { type: tableType },\n        })?.[0];\n\n        if (table) {\n          computeCellIndices(editor, {\n            tableNode: table,\n          });\n        }\n      }\n    },\n  },\n});\n","import { type SlateEditor, type TRange, isHotkey } from '@udecode/plate';\n\nimport { getCellTypes, KEY_SHIFT_EDGES } from '..';\nimport { moveSelectionFromCell } from './moveSelectionFromCell';\n\n/**\n * Override the new selection if the previous selection and the new one are in\n * different cells.\n */\nexport const overrideSelectionFromCell = (\n  editor: SlateEditor,\n  newSelection?: TRange | null\n) => {\n  let hotkey: string | undefined;\n\n  if (\n    !editor.currentKeyboardEvent ||\n    !['up', 'down', 'shift+up', 'shift+right', 'shift+down', 'shift+left'].some(\n      (key) => {\n        const valid = isHotkey(key, editor.currentKeyboardEvent!);\n\n        if (valid) hotkey = key;\n\n        return valid;\n      }\n    ) ||\n    !editor.selection?.focus ||\n    !newSelection?.focus ||\n    !editor.api.isAt({\n      at: {\n        anchor: editor.selection.focus,\n        focus: newSelection.focus,\n      },\n      blocks: true,\n      match: { type: getCellTypes(editor) },\n    })\n  ) {\n    return;\n  }\n  if (!hotkey) return;\n\n  const edge = (KEY_SHIFT_EDGES as any)[hotkey];\n\n  // if the previous selection was in many cells, return\n  if (\n    edge &&\n    !editor.api.isAt({ block: true, match: { type: getCellTypes(editor) } })\n  ) {\n    return;\n  }\n\n  const prevSelection = editor.selection;\n  const reverse = ['shift+up', 'up'].includes(hotkey);\n\n  setTimeout(() => {\n    moveSelectionFromCell(editor, {\n      at: prevSelection,\n      edge,\n      fromOneCell: true,\n      reverse,\n    });\n  }, 0);\n};\n","import { type SlateEditor, type TLocation, NodeApi } from '@udecode/plate';\n\nimport { getTableGridAbove } from '../queries/getTableGridAbove';\nimport { getCellTypes } from '../utils/getCellType';\n\n/** Move selection by cell unit. */\nexport const moveSelectionFromCell = (\n  editor: SlateEditor,\n  {\n    at,\n    edge,\n    fromOneCell,\n    reverse,\n  }: {\n    at?: TLocation;\n    /** Expand cell selection to an edge. */\n    edge?: 'bottom' | 'left' | 'right' | 'top';\n    /** Move selection from one selected cell */\n    fromOneCell?: boolean;\n    /** False: move selection to cell below true: move selection to cell above */\n    reverse?: boolean;\n  } = {}\n) => {\n  if (edge) {\n    const cellEntries = getTableGridAbove(editor, { at, format: 'cell' });\n\n    const minCell = fromOneCell ? 0 : 1;\n\n    if (cellEntries.length > minCell) {\n      const [, firstCellPath] = cellEntries[0];\n      const [, lastCellPath] = cellEntries.at(-1)!;\n\n      const anchorPath = [...firstCellPath];\n      const focusPath = [...lastCellPath];\n\n      switch (edge) {\n        case 'bottom': {\n          focusPath[focusPath.length - 2] += 1;\n\n          break;\n        }\n        case 'left': {\n          anchorPath[anchorPath.length - 1] -= 1;\n\n          break;\n        }\n        case 'right': {\n          focusPath[focusPath.length - 1] += 1;\n\n          break;\n        }\n        case 'top': {\n          anchorPath[anchorPath.length - 2] -= 1;\n\n          break;\n        }\n        // No default\n      }\n\n      if (NodeApi.has(editor, anchorPath) && NodeApi.has(editor, focusPath)) {\n        editor.tf.select({\n          anchor: editor.api.start(anchorPath)!,\n          focus: editor.api.start(focusPath)!,\n        });\n      }\n\n      return true;\n    }\n\n    return;\n  }\n\n  const cellEntry = editor.api.block({\n    at,\n    match: { type: getCellTypes(editor) },\n  });\n\n  if (cellEntry) {\n    const [, cellPath] = cellEntry;\n\n    const nextCellPath = [...cellPath];\n\n    const offset = reverse ? -1 : 1;\n\n    nextCellPath[nextCellPath.length - 2] += offset;\n\n    if (NodeApi.has(editor, nextCellPath)) {\n      editor.tf.select(editor.api.start(nextCellPath)!);\n    } else {\n      const tablePath = cellPath.slice(0, -2);\n\n      if (reverse) {\n        editor.tf.withoutNormalizing(() => {\n          editor.tf.select(editor.api.start(tablePath)!);\n          editor.tf.move({ reverse: true });\n        });\n      } else {\n        editor.tf.withoutNormalizing(() => {\n          editor.tf.select(editor.api.end(tablePath)!);\n          editor.tf.move();\n        });\n      }\n    }\n\n    return true;\n  }\n};\n","import {\n  type EditorAboveOptions,\n  type ElementEntry,\n  type SlateEditor,\n  PathApi,\n} from '@udecode/plate';\n\nimport type { TableConfig } from '../BaseTablePlugin';\n\nimport { getCellTypes } from '../../lib/utils';\nimport {\n  type GetTableGridByRangeOptions,\n  getTableGridByRange,\n} from './getTableGridByRange';\n\nexport type GetTableGridAboveOptions = EditorAboveOptions &\n  Pick<GetTableGridByRangeOptions, 'format'>;\n\n/** Get sub table above anchor and focus. Format: tables or cells. */\nexport const getTableGridAbove = (\n  editor: SlateEditor,\n  { format = 'table', ...options }: GetTableGridAboveOptions = {}\n): ElementEntry[] => {\n  const { api } = editor.getPlugin<TableConfig>({ key: 'table' });\n\n  const edges = editor.api.edgeBlocks({\n    match: {\n      type: getCellTypes(editor),\n    },\n    ...options,\n  });\n\n  if (edges) {\n    const [start, end] = edges;\n\n    if (!PathApi.equals(start[1], end[1])) {\n      return getTableGridByRange(editor, {\n        at: {\n          anchor: {\n            offset: 0,\n            path: start[1],\n          },\n          focus: {\n            offset: 0,\n            path: end[1],\n          },\n        },\n        format,\n      });\n    }\n    if (format === 'table') {\n      const table = api.create.table({ rowCount: 1 });\n      table.children[0].children = [start[0]];\n\n      return [[table, start[1].slice(0, -2)]];\n    }\n\n    return [start];\n  }\n\n  return [];\n};\n","import {\n  type ElementEntry,\n  type SlateEditor,\n  type TElement,\n  type TRange,\n  NodeApi,\n} from '@udecode/plate';\n\nimport type { TTableElement } from '../../lib/types';\n\nimport { type TableConfig, BaseTablePlugin } from '../../lib/BaseTablePlugin';\nimport { getTableMergeGridByRange } from '../merge/getTableGridByRange';\n\nexport interface GetTableGridByRangeOptions {\n  at: TRange;\n\n  /**\n   * Format of the output:\n   *\n   * - Table element\n   * - Array of cells\n   */\n  format?: 'cell' | 'table';\n}\n\n/** Get sub table between 2 cell paths. */\nexport const getTableGridByRange = (\n  editor: SlateEditor,\n  { at, format = 'table' }: GetTableGridByRangeOptions\n): ElementEntry[] => {\n  const { api } = editor.getPlugin<TableConfig>({ key: 'table' });\n  const { disableMerge } = editor.getOptions(BaseTablePlugin);\n\n  if (!disableMerge) {\n    return getTableMergeGridByRange(editor, { at, format });\n  }\n\n  const startCellPath = at.anchor.path;\n  const endCellPath = at.focus.path;\n\n  const _startRowIndex = startCellPath.at(-2)!;\n  const _endRowIndex = endCellPath.at(-2)!;\n  const _startColIndex = startCellPath.at(-1)!;\n  const _endColIndex = endCellPath.at(-1)!;\n\n  const startRowIndex = Math.min(_startRowIndex, _endRowIndex);\n  const endRowIndex = Math.max(_startRowIndex, _endRowIndex);\n  const startColIndex = Math.min(_startColIndex, _endColIndex);\n  const endColIndex = Math.max(_startColIndex, _endColIndex);\n\n  const tablePath = startCellPath.slice(0, -2);\n\n  const relativeRowIndex = endRowIndex - startRowIndex;\n  const relativeColIndex = endColIndex - startColIndex;\n\n  const table: TTableElement = api.create.table({\n    children: [],\n    colCount: relativeColIndex + 1,\n    rowCount: relativeRowIndex + 1,\n  });\n\n  let rowIndex = startRowIndex;\n  let colIndex = startColIndex;\n\n  const cellEntries: ElementEntry[] = [];\n\n  while (true) {\n    const cellPath = tablePath.concat([rowIndex, colIndex]);\n\n    const cell = NodeApi.get<TElement>(editor, cellPath);\n\n    if (!cell) break;\n\n    const rows = table.children[rowIndex - startRowIndex]\n      .children as TElement[];\n\n    rows[colIndex - startColIndex] = cell;\n\n    cellEntries.push([cell, cellPath]);\n\n    if (colIndex + 1 <= endColIndex) {\n      colIndex += 1;\n    } else if (rowIndex + 1 <= endRowIndex) {\n      colIndex = startColIndex;\n      rowIndex += 1;\n    } else {\n      break;\n    }\n  }\n\n  if (format === 'cell') {\n    return cellEntries;\n  }\n\n  return [[table, tablePath]];\n};\n","import {\n  type ElementEntry,\n  type SlateEditor,\n  type TElement,\n  type TRange,\n  getEditorPlugin,\n} from '@udecode/plate';\n\nimport type {\n  TTableCellElement,\n  TTableElement,\n  TTableRowElement,\n} from '../types';\n\nimport { BaseTablePlugin } from '../BaseTablePlugin';\nimport { getCellTypes } from '../utils';\nimport { getCellIndices } from '../utils/getCellIndices';\nimport { findCellByIndexes } from './findCellByIndexes';\nimport { getCellIndicesWithSpans } from './getCellIndicesWithSpans';\n\ntype FormatType = 'all' | 'cell' | 'table';\n\ninterface GetTableGridByRangeOptions<T extends FormatType> {\n  at: TRange;\n\n  /**\n   * Format of the output:\n   *\n   * - Table element\n   * - Array of cells\n   */\n  format?: T;\n}\n\ntype GetTableGridReturnType<T> = T extends 'all'\n  ? TableGridEntries\n  : ElementEntry[];\n\ninterface TableGridEntries {\n  cellEntries: ElementEntry[];\n  tableEntries: ElementEntry[];\n}\n\n/**\n * Get sub table between 2 cell paths. Ensure that the selection is always a\n * valid table grid.\n */\nexport const getTableMergeGridByRange = <T extends FormatType>(\n  editor: SlateEditor,\n  { at, format }: GetTableGridByRangeOptions<T>\n): GetTableGridReturnType<T> => {\n  const { api, type } = getEditorPlugin(editor, BaseTablePlugin);\n\n  const startCellEntry = editor.api.node<TTableCellElement>({\n    at: at.anchor.path,\n    match: { type: getCellTypes(editor) },\n  })!;\n  const endCellEntry = editor.api.node<TTableCellElement>({\n    at: at.focus.path,\n    match: { type: getCellTypes(editor) },\n  })!;\n\n  const startCell = startCellEntry[0];\n  const endCell = endCellEntry[0];\n\n  const startCellPath = at.anchor.path;\n  const tablePath = startCellPath.slice(0, -2);\n\n  const tableEntry = editor.api.node<TTableElement>({\n    at: tablePath,\n    match: { type },\n  })!;\n  const realTable = tableEntry[0];\n\n  const { col: _startColIndex, row: _startRowIndex } = getCellIndicesWithSpans(\n    getCellIndices(editor, startCell),\n    startCell\n  );\n\n  const { col: _endColIndex, row: _endRowIndex } = getCellIndicesWithSpans(\n    getCellIndices(editor, endCell),\n    endCell\n  );\n\n  let startRowIndex = Math.min(_startRowIndex, _endRowIndex);\n  let endRowIndex = Math.max(_startRowIndex, _endRowIndex);\n  let startColIndex = Math.min(_startColIndex, _endColIndex);\n  let endColIndex = Math.max(_startColIndex, _endColIndex);\n\n  const relativeRowIndex = endRowIndex - startRowIndex;\n  const relativeColIndex = endColIndex - startColIndex;\n\n  let table: TTableElement = api.create.table({\n    children: [],\n    colCount: relativeColIndex + 1,\n    rowCount: relativeRowIndex + 1,\n  });\n\n  let cellEntries: ElementEntry[] = [];\n  let cellsSet = new WeakSet();\n\n  let rowIndex = startRowIndex;\n  let colIndex = startColIndex;\n\n  while (true) {\n    const cell = findCellByIndexes(editor, realTable, rowIndex, colIndex);\n\n    if (!cell) {\n      break;\n    }\n\n    const indicies = getCellIndices(editor, cell);\n    const { col: cellColWithSpan, row: cellRowWithSpan } =\n      getCellIndicesWithSpans(indicies, cell);\n    const { col: cellCol, row: cellRow } = indicies;\n\n    // check if cell is still in range\n    const hasOverflowTop = cellRow < startRowIndex;\n    const hasOverflowBottom = cellRowWithSpan > endRowIndex;\n    const hasOverflowLeft = cellCol < startColIndex;\n    const hasOverflowRight = cellColWithSpan > endColIndex;\n\n    if (\n      hasOverflowTop ||\n      hasOverflowBottom ||\n      hasOverflowLeft ||\n      hasOverflowRight\n    ) {\n      // reset the cycle if has overflow\n      cellsSet = new WeakSet();\n      cellEntries = [];\n      startRowIndex = Math.min(startRowIndex, cellRow);\n      endRowIndex = Math.max(endRowIndex, cellRowWithSpan);\n      startColIndex = Math.min(startColIndex, cellCol);\n      endColIndex = Math.max(endColIndex, cellColWithSpan);\n      rowIndex = startRowIndex;\n      colIndex = startColIndex;\n      const newRelativeRowIndex = endRowIndex - startRowIndex;\n      const newRelativeColIndex = endColIndex - startColIndex;\n      table = api.create.table({\n        children: [],\n        colCount: newRelativeColIndex + 1,\n        rowCount: newRelativeRowIndex + 1,\n      });\n\n      continue;\n    }\n    if (!cellsSet.has(cell)) {\n      cellsSet.add(cell);\n\n      const rows = table.children[rowIndex - startRowIndex]\n        .children as TElement[];\n      rows[colIndex - startColIndex] = cell;\n\n      const cellPath = editor.api.findPath(cell)!;\n\n      cellEntries.push([cell, cellPath]);\n    }\n    if (colIndex + 1 <= endColIndex) {\n      colIndex = colIndex + 1;\n    } else if (rowIndex + 1 <= endRowIndex) {\n      colIndex = startColIndex;\n      rowIndex = rowIndex + 1;\n    } else {\n      break;\n    }\n  }\n\n  const formatType = (format as string) || 'table';\n\n  if (formatType === 'cell') {\n    return cellEntries as GetTableGridReturnType<T>;\n  }\n\n  // clear redundant cells\n  table.children?.forEach((rowEl) => {\n    const rowElement = rowEl as TTableRowElement;\n\n    const filteredChildren = rowElement.children?.filter((cellEl) => {\n      const cellElement = cellEl as TTableCellElement;\n\n      return api.table.getCellChildren!(cellElement).length > 0;\n    });\n\n    rowElement.children = filteredChildren;\n  });\n\n  if (formatType === 'table') {\n    return [[table, tablePath]] as GetTableGridReturnType<T>;\n  }\n\n  return {\n    cellEntries,\n    tableEntries: [[table, tablePath]],\n  } as GetTableGridReturnType<T>;\n};\n","import type { TTableCellElement } from '../types';\n\n/**\n * Returns the colspan attribute of the table cell element.\n *\n * @default 1 if undefined.\n */\nexport const getColSpan = (cellElem: TTableCellElement) => {\n  return cellElem.colSpan || Number(cellElem.attributes?.colspan) || 1;\n};\n","import type { TTableCellElement } from '../types';\n\n/**\n * Returns the rowspan attribute of the table cell element.\n *\n * @default 1 if undefined\n */\nexport const getRowSpan = (cellElem: TTableCellElement) => {\n  return cellElem.rowSpan || Number(cellElem.attributes?.rowspan) || 1;\n};\n","import type { TTableCellElement } from '../types';\n\nimport { getColSpan } from '../queries/getColSpan';\nimport { getRowSpan } from '../queries/getRowSpan';\n\nexport const getCellIndicesWithSpans = (\n  { col, row }: { col: number; row: number },\n  endCell: TTableCellElement\n) => {\n  return {\n    col: col + getColSpan(endCell) - 1,\n    row: row + getRowSpan(endCell) - 1,\n  };\n};\n","import type { SlateEditor } from '@udecode/plate';\n\nimport type { TTableCellElement, TTableElement } from '../types';\n\nimport { getCellIndices } from '../utils/getCellIndices';\nimport { getCellIndicesWithSpans } from './getCellIndicesWithSpans';\n\nexport const findCellByIndexes = (\n  editor: SlateEditor,\n  table: TTableElement,\n  searchRowIndex: number,\n  searchColIndex: number\n) => {\n  const allCells = table.children.flatMap(\n    (current) => current.children\n  ) as TTableCellElement[];\n\n  const foundCell = allCells.find((cellNode) => {\n    const indices = getCellIndices(editor, cellNode);\n\n    const { col: _startColIndex, row: _startRowIndex } = indices;\n    const { col: _endColIndex, row: _endRowIndex } = getCellIndicesWithSpans(\n      indices,\n      cellNode\n    );\n\n    if (\n      searchColIndex >= _startColIndex &&\n      searchColIndex <= _endColIndex &&\n      searchRowIndex >= _startRowIndex &&\n      searchRowIndex <= _endRowIndex\n    ) {\n      return true;\n    }\n\n    return false;\n  });\n\n  return foundCell;\n};\n","import {\n  type OverrideEditor,\n  type SlateEditor,\n  PointApi,\n} from '@udecode/plate';\n\nimport { type TableConfig, getCellTypes } from '.';\nimport { getTableGridAbove } from './queries/getTableGridAbove';\n\n/**\n * Return true if:\n *\n * - At start/end of a cell.\n * - Next to a table cell. Move selection to the table cell.\n */\nexport const preventDeleteTableCell = (\n  editor: SlateEditor,\n  {\n    reverse,\n    unit,\n  }: {\n    reverse?: boolean;\n    unit?: 'block' | 'character' | 'line' | 'word';\n  }\n) => {\n  const { selection } = editor;\n  const getNextPoint = reverse ? editor.api.after : editor.api.before;\n\n  if (editor.api.isCollapsed()) {\n    const cellEntry = editor.api.block({\n      match: { type: getCellTypes(editor) },\n    });\n\n    if (cellEntry) {\n      // Prevent deleting cell at the start or end of a cell\n      const [, cellPath] = cellEntry;\n      const start = reverse\n        ? editor.api.end(cellPath)\n        : editor.api.start(cellPath);\n\n      if (selection && PointApi.equals(selection.anchor, start!)) {\n        return true;\n      }\n    } else {\n      // Prevent deleting cell when selection is before or after a table\n      const nextPoint = getNextPoint(selection!, { unit });\n      const nextCellEntry = editor.api.block({\n        at: nextPoint,\n        match: { type: getCellTypes(editor) },\n      });\n\n      if (nextCellEntry) {\n        editor.tf.move({ reverse: !reverse });\n\n        return true;\n      }\n    }\n  }\n};\n\n/** Prevent cell deletion. */\nexport const withDeleteTable: OverrideEditor<TableConfig> = ({\n  editor,\n  tf: { deleteBackward, deleteForward, deleteFragment },\n  type,\n}) => ({\n  transforms: {\n    deleteBackward(unit) {\n      if (preventDeleteTableCell(editor, { unit: unit })) return;\n\n      deleteBackward(unit);\n    },\n\n    deleteForward(unit) {\n      if (\n        preventDeleteTableCell(editor, {\n          reverse: true,\n          unit: unit,\n        })\n      )\n        return;\n\n      deleteForward(unit);\n    },\n\n    deleteFragment(direction) {\n      if (editor.api.isAt({ block: true, match: (n) => n.type === type })) {\n        const cellEntries = getTableGridAbove(editor, { format: 'cell' });\n\n        if (cellEntries.length > 1) {\n          editor.tf.withoutNormalizing(() => {\n            cellEntries.forEach(([, cellPath]) => {\n              editor.tf.replaceNodes(editor.api.create.block(), {\n                at: cellPath,\n                children: true,\n              });\n            });\n\n            // set back the selection\n            editor.tf.select({\n              anchor: editor.api.start(cellEntries[0][1])!,\n              focus: editor.api.end(cellEntries.at(-1)![1])!,\n            });\n          });\n\n          return;\n        }\n      }\n\n      deleteFragment(direction);\n    },\n  },\n});\n","import type { Descendant, OverrideEditor, TElement } from '@udecode/plate';\n\nimport type { TableConfig } from './BaseTablePlugin';\nimport type { TTableCellElement, TTableRowElement } from './types';\n\nimport { getTableGridAbove } from './queries/getTableGridAbove';\n\n/** If selection is in a table, get subtable above. */\nexport const withGetFragmentTable: OverrideEditor<TableConfig> = ({\n  api,\n  api: { getFragment },\n  editor,\n  type,\n}) => ({\n  api: {\n    getFragment() {\n      const fragment = getFragment();\n      const newFragment: Descendant[] = [];\n\n      fragment.forEach((node) => {\n        if (node.type === type) {\n          const rows = node.children as TTableRowElement[];\n          const rowCount = rows.length;\n\n          if (!rowCount) return;\n\n          const colCount = rows[0].children.length;\n          const hasOneCell = rowCount <= 1 && colCount <= 1;\n\n          if (hasOneCell) {\n            const cell = rows[0] as TTableCellElement;\n            const cellChildren = api.table.getCellChildren!(cell);\n            newFragment.push(...(cellChildren[0].children as TElement[]));\n\n            return;\n          } else {\n            const subTable = getTableGridAbove(editor);\n\n            if (subTable.length > 0) {\n              newFragment.push(subTable[0][0]);\n\n              return;\n            }\n          }\n        }\n\n        newFragment.push(node);\n      });\n\n      return newFragment;\n    },\n  },\n});\n","import {\n  type OverrideEditor,\n  type Path,\n  type TElement,\n  NodeApi,\n} from '@udecode/plate';\nimport cloneDeep from 'lodash/cloneDeep.js';\n\nimport {\n  type TableConfig,\n  type TTableCellElement,\n  type TTableElement,\n  type TTableRowElement,\n  getTableAbove,\n} from '.';\nimport { BaseTablePlugin } from './BaseTablePlugin';\nimport { getTableGridAbove } from './queries/getTableGridAbove';\n\n/**\n * If inserting a table, If block above anchor is a table,\n *\n * - Replace each cell above by the inserted table until out of bounds.\n * - Select the inserted cells.\n */\nexport const withInsertFragmentTable: OverrideEditor<TableConfig> = ({\n  api,\n  editor,\n  getOptions,\n  tf: { insert, insertFragment },\n  type,\n}) => ({\n  transforms: {\n    insertFragment(fragment) {\n      const insertedTable = fragment.find(\n        (n) => (n as TElement).type === type\n      ) as TTableElement | undefined;\n\n      if (!insertedTable) {\n        const tableEntry = getTableAbove(editor, {\n          at: editor.selection?.anchor,\n        });\n\n        if (tableEntry) {\n          const cellEntries = getTableGridAbove(editor, {\n            format: 'cell',\n          });\n\n          if (cellEntries.length > 1) {\n            cellEntries.forEach((cellEntry) => {\n              if (cellEntry) {\n                const [, cellPath] = cellEntry;\n\n                editor.tf.replaceNodes(cloneDeep(fragment) as any, {\n                  at: cellPath,\n                  children: true,\n                });\n              }\n            });\n\n            editor.tf.select({\n              anchor: editor.api.start(cellEntries[0][1])!,\n              focus: editor.api.end(cellEntries.at(-1)![1])!,\n            });\n\n            return;\n          }\n        }\n      }\n      if (insertedTable) {\n        const tableEntry = getTableAbove(editor, {\n          at: editor.selection?.anchor,\n        });\n\n        // inserting inside table\n        if (tableEntry) {\n          const [cellEntry] = getTableGridAbove(editor, {\n            at: editor.selection?.anchor,\n            format: 'cell',\n          });\n\n          if (cellEntry) {\n            editor.tf.withoutNormalizing(() => {\n              const [, startCellPath] = cellEntry;\n              const cellPath = [...startCellPath];\n\n              const startColIndex = cellPath.at(-1)!;\n              let lastCellPath: Path | null = null;\n\n              let initRow = true;\n              const insertedRows = insertedTable.children as TTableRowElement[];\n              insertedRows.forEach((row) => {\n                cellPath[cellPath.length - 1] = startColIndex;\n\n                // last inserted row\n                if (!initRow) {\n                  const fromRow = cellPath.slice(0, -1);\n                  cellPath[cellPath.length - 2] += 1;\n\n                  if (!NodeApi.has(editor, cellPath)) {\n                    if (getOptions().disableExpandOnInsert) {\n                      return;\n                    } else {\n                      insert.tableRow({\n                        fromRow,\n                      });\n                    }\n                  }\n                }\n\n                initRow = false;\n\n                const insertedCells = row.children as TTableCellElement[];\n                let initCell = true;\n\n                insertedCells.forEach((cell) => {\n                  if (!initCell) {\n                    const fromCell = [...cellPath];\n                    cellPath[cellPath.length - 1] += 1;\n\n                    if (!NodeApi.has(editor, cellPath)) {\n                      if (getOptions().disableExpandOnInsert) {\n                        return;\n                      } else {\n                        insert.tableColumn({\n                          fromCell,\n                        });\n                      }\n                    }\n                  }\n\n                  initCell = false;\n\n                  const cellChildren = api.table.getCellChildren!(\n                    cell\n                  ) as TTableCellElement[];\n\n                  editor.tf.replaceNodes(cloneDeep(cellChildren as any), {\n                    at: cellPath,\n                    children: true,\n                  });\n\n                  lastCellPath = [...cellPath];\n                });\n              });\n\n              if (lastCellPath) {\n                editor.tf.select({\n                  anchor: editor.api.start(startCellPath)!,\n                  focus: editor.api.end(lastCellPath)!,\n                });\n              }\n            });\n\n            return;\n          }\n        } else if (\n          fragment.length === 1 &&\n          fragment[0].type === BaseTablePlugin.key\n        ) {\n          // needed to insert as node, otherwise it will be inserted as text\n          editor.tf.insertNodes(fragment[0]);\n\n          return;\n        }\n      }\n\n      insertFragment(fragment);\n    },\n  },\n});\n","import {\n  type Editor,\n  type NodeEntry,\n  type Path,\n  type TElement,\n  PathApi,\n} from '@udecode/plate';\n\nexport const getCellInNextTableRow = (\n  editor: Editor,\n  currentRowPath: Path\n): NodeEntry | undefined => {\n  const nextRow = editor.api.node<TElement>(PathApi.next(currentRowPath));\n\n  if (!nextRow) return;\n\n  // TODO: Many tables in rich text editors (Google Docs, Word),\n  // add a new row if we're in the last cell. Should we do the same?\n  const [nextRowNode, nextRowPath] = nextRow;\n  const nextCell = nextRowNode?.children?.[0];\n  const nextCellPath = nextRowPath.concat(0);\n\n  if (nextCell && nextCellPath) {\n    return editor.api.node(nextCellPath);\n  }\n};\n","import {\n  type Editor,\n  type NodeEntry,\n  type Path,\n  type TElement,\n  PathApi,\n} from '@udecode/plate';\n\nexport const getCellInPreviousTableRow = (\n  editor: Editor,\n  currentRowPath: Path\n): NodeEntry | undefined => {\n  const prevPath = PathApi.previous(currentRowPath);\n\n  if (!prevPath) return;\n\n  const previousRow = editor.api.node<TElement>(prevPath);\n\n  if (!previousRow) return;\n\n  const [previousRowNode, previousRowPath] = previousRow;\n  const previousCell =\n    previousRowNode?.children?.[previousRowNode.children.length - 1];\n  const previousCellPath = previousRowPath.concat(\n    previousRowNode.children.length - 1\n  );\n\n  if (previousCell && previousCellPath) {\n    return editor.api.node(previousCellPath);\n  }\n};\n","import { type Path, type SlateEditor, PathApi } from '@udecode/plate';\n\nimport type { TTableCellElement } from '../types';\n\nimport { getCellTypes } from '../utils';\n\n// Get cell to the left of the current cell\nexport const getLeftTableCell = (\n  editor: SlateEditor,\n  {\n    at: cellPath,\n  }: {\n    at?: Path;\n  } = {}\n) => {\n  if (!cellPath) {\n    cellPath = editor.api.node<TTableCellElement>({\n      match: { type: getCellTypes(editor) },\n    })?.[1];\n\n    if (!cellPath) return;\n  }\n\n  const cellIndex = cellPath.at(-1);\n\n  if (!cellIndex) return;\n\n  const prevCellPath = PathApi.previous(cellPath)!;\n\n  return editor.api.node<TTableCellElement>(prevCellPath);\n};\n","import {\n  type Editor,\n  type NodeEntry,\n  type Path,\n  PathApi,\n} from '@udecode/plate';\n\nimport { getCellInNextTableRow } from './getCellInNextTableRow';\n\nexport const getNextTableCell = (\n  editor: Editor,\n  currentCell: NodeEntry,\n  currentPath: Path,\n  currentRow: NodeEntry\n): NodeEntry | undefined => {\n  const cell = editor.api.node(PathApi.next(currentPath));\n\n  if (cell) return cell;\n\n  const [, currentRowPath] = currentRow;\n\n  return getCellInNextTableRow(editor, currentRowPath);\n};\n","import {\n  type Editor,\n  type NodeEntry,\n  type Path,\n  PathApi,\n} from '@udecode/plate';\n\nimport { getCellInPreviousTableRow } from './getCellInPreviousTableRow';\n\nexport const getPreviousTableCell = (\n  editor: Editor,\n  currentCell: NodeEntry,\n  currentPath: Path,\n  currentRow: NodeEntry\n): NodeEntry | undefined => {\n  const prevPath = PathApi.previous(currentPath);\n\n  if (!prevPath) {\n    const [, currentRowPath] = currentRow;\n\n    return getCellInPreviousTableRow(editor, currentRowPath);\n  }\n\n  const cell = editor.api.node(prevPath);\n\n  if (cell) return cell;\n};\n","import type { SlateEditor } from '@udecode/plate';\n\nimport type { TTableCellElement } from '../types';\n\nimport { getCellIndices } from '../utils';\nimport { getColSpan } from './getColSpan';\nimport { getRowSpan } from './getRowSpan';\n\n/** Return bounding box [minRow..maxRow, minCol..maxCol] of all selected cells. */\nexport function getSelectedCellsBoundingBox(\n  editor: SlateEditor,\n  cells: TTableCellElement[]\n): { maxCol: number; maxRow: number; minCol: number; minRow: number } {\n  let minRow = Infinity;\n  let maxRow = -Infinity;\n  let minCol = Infinity;\n  let maxCol = -Infinity;\n\n  for (const cell of cells) {\n    const { col, row } = getCellIndices(editor, cell);\n    const cSpan = getColSpan(cell);\n    const rSpan = getRowSpan(cell);\n    const endRow = row + rSpan - 1;\n    const endCol = col + cSpan - 1;\n\n    if (row < minRow) minRow = row;\n    if (endRow > maxRow) maxRow = endRow;\n    if (col < minCol) minCol = col;\n    if (endCol > maxCol) maxCol = endCol;\n  }\n\n  return { maxCol, maxRow, minCol, minRow };\n}\n","import { type Path, type SlateEditor, PathApi } from '@udecode/plate';\n\nimport type { TTableCellElement } from '../types';\n\nimport { getCellTypes } from '../utils/index';\n\n// Get cell to the top of the current cell\nexport const getTopTableCell = (\n  editor: SlateEditor,\n  {\n    at: cellPath,\n  }: {\n    at?: Path;\n  } = {}\n) => {\n  if (!cellPath) {\n    cellPath = editor.api.node<TTableCellElement>({\n      match: { type: getCellTypes(editor) },\n    })?.[1];\n\n    if (!cellPath) return;\n  }\n\n  const cellIndex = cellPath.at(-1)!;\n  const rowIndex = cellPath.at(-2)!;\n\n  // If the current cell is in the first row, there is no cell above it\n  if (rowIndex === 0) return;\n\n  const cellAbovePath = [\n    ...PathApi.parent(PathApi.parent(cellPath)),\n    rowIndex - 1,\n    cellIndex,\n  ];\n\n  return editor.api.node<TTableCellElement>(cellAbovePath);\n};\n","import type { SlateEditor, TElement } from '@udecode/plate';\n\nimport type { BorderDirection, TTableCellElement } from '../types';\n\nimport { getCellIndices, getCellTypes } from '../utils';\nimport { getColSpan } from './getColSpan';\nimport { getLeftTableCell } from './getLeftTableCell';\nimport { getRowSpan } from './getRowSpan';\nimport { getSelectedCellsBoundingBox } from './getSelectedCellsBoundingBox';\nimport { getTopTableCell } from './getTopTableCell';\n\nexport interface GetSelectedCellsBordersOptions {\n  select?: {\n    none?: boolean;\n    outer?: boolean;\n    side?: boolean;\n  };\n}\n\nexport interface TableBorderStates {\n  bottom: boolean;\n  left: boolean;\n  none: boolean;\n  outer: boolean;\n  right: boolean;\n  top: boolean;\n}\n\n/**\n * Get all border states for the selected cells at once. Returns an object with\n * boolean flags for each border state:\n *\n * - Top/bottom/left/right: true if border is visible (size > 0)\n * - Outer: true if all outer borders are visible\n * - None: true if all borders are hidden (size === 0)\n */\nexport const getSelectedCellsBorders = (\n  editor: SlateEditor,\n  selectedCells?: TElement[] | null,\n  options: GetSelectedCellsBordersOptions = {}\n): TableBorderStates => {\n  const { select = { none: true, outer: true, side: true } } = options;\n\n  // If no cells are selected, try to get the current cell\n  if (!selectedCells || selectedCells.length === 0) {\n    const cell = editor.api.block({ match: { type: getCellTypes(editor) } });\n\n    if (cell) {\n      selectedCells = [cell[0]];\n    } else {\n      return {\n        bottom: true,\n        left: true,\n        none: false,\n        outer: true,\n        right: true,\n        top: true,\n      };\n    }\n  }\n\n  // Convert to TTableCellElement\n  const cells = selectedCells.map((cell) => cell as TTableCellElement);\n\n  // Get bounding box once\n  const { maxCol, maxRow, minCol, minRow } = getSelectedCellsBoundingBox(\n    editor,\n    cells\n  );\n\n  // Track border states\n  let hasAnyBorder = false;\n  let allOuterBordersSet = true;\n  const borderStates = {\n    bottom: false,\n    left: false,\n    right: false,\n    top: false,\n  };\n\n  // Single pass through cells to check all border conditions\n  for (const cell of cells) {\n    const { col, row } = getCellIndices(editor, cell);\n    const cellPath = editor.api.findPath(cell);\n    const cSpan = getColSpan(cell);\n    const rSpan = getRowSpan(cell);\n    const isFirstRow = row === 0;\n    const isFirstCell = col === 0;\n\n    if (!cellPath) continue;\n    // Check borders for 'none' state\n    if (select.none && !hasAnyBorder) {\n      // Check own borders\n      if (isFirstRow && (cell.borders?.top?.size ?? 1) > 0) hasAnyBorder = true;\n      if (isFirstCell && (cell.borders?.left?.size ?? 1) > 0)\n        hasAnyBorder = true;\n      if ((cell.borders?.bottom?.size ?? 1) > 0) hasAnyBorder = true;\n      if ((cell.borders?.right?.size ?? 1) > 0) hasAnyBorder = true;\n      // Check adjacent cells if still no border found\n      if (!hasAnyBorder) {\n        if (!isFirstRow) {\n          const cellAboveEntry = getTopTableCell(editor, { at: cellPath });\n\n          if (\n            cellAboveEntry &&\n            (cellAboveEntry[0].borders?.bottom?.size ?? 1) > 0\n          ) {\n            hasAnyBorder = true;\n          }\n        }\n        if (!isFirstCell) {\n          const prevCellEntry = getLeftTableCell(editor, { at: cellPath });\n\n          if (\n            prevCellEntry &&\n            (prevCellEntry[0].borders?.right?.size ?? 1) > 0\n          ) {\n            hasAnyBorder = true;\n          }\n        }\n      }\n    }\n    // Only check borders if side or outer is requested\n    if (select.side || select.outer) {\n      // Check outer borders state\n      for (let rr = row; rr < row + rSpan; rr++) {\n        for (let cc = col; cc < col + cSpan; cc++) {\n          // Top border\n          if (rr === minRow) {\n            if (isFirstRow) {\n              if ((cell.borders?.top?.size ?? 1) < 1) {\n                borderStates.top = false;\n\n                if (select.outer) allOuterBordersSet = false;\n              } else if (!borderStates.top) {\n                borderStates.top = true;\n              }\n            } else {\n              const cellAboveEntry = getTopTableCell(editor, { at: cellPath });\n\n              if (cellAboveEntry) {\n                const [cellAbove] = cellAboveEntry;\n\n                if ((cellAbove.borders?.bottom?.size ?? 1) < 1) {\n                  borderStates.top = false;\n\n                  if (select.outer) allOuterBordersSet = false;\n                } else if (!borderStates.top) {\n                  borderStates.top = true;\n                }\n              }\n            }\n          }\n          // Bottom border\n          if (rr === maxRow) {\n            if ((cell.borders?.bottom?.size ?? 1) < 1) {\n              borderStates.bottom = false;\n\n              if (select.outer) allOuterBordersSet = false;\n            } else if (!borderStates.bottom) {\n              borderStates.bottom = true;\n            }\n          }\n          // Left border\n          if (cc === minCol) {\n            if (isFirstCell) {\n              if ((cell.borders?.left?.size ?? 1) < 1) {\n                borderStates.left = false;\n\n                if (select.outer) allOuterBordersSet = false;\n              } else if (!borderStates.left) {\n                borderStates.left = true;\n              }\n            } else {\n              const prevCellEntry = getLeftTableCell(editor, { at: cellPath });\n\n              if (prevCellEntry) {\n                const [prevCell] = prevCellEntry;\n\n                if ((prevCell.borders?.right?.size ?? 1) < 1) {\n                  borderStates.left = false;\n\n                  if (select.outer) allOuterBordersSet = false;\n                } else if (!borderStates.left) {\n                  borderStates.left = true;\n                }\n              }\n            }\n          }\n          // Right border\n          if (cc === maxCol) {\n            if ((cell.borders?.right?.size ?? 1) < 1) {\n              borderStates.right = false;\n\n              if (select.outer) allOuterBordersSet = false;\n            } else if (!borderStates.right) {\n              borderStates.right = true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    ...(select.side\n      ? borderStates\n      : { bottom: true, left: true, right: true, top: true }),\n    none: select.none ? !hasAnyBorder : false,\n    outer: select.outer ? allOuterBordersSet : true,\n  };\n};\n\n/**\n * Tells if the entire selection is currently borderless (size=0 on all edges).\n * If **any** edge is > 0, returns false.\n */\nexport function isSelectedCellBordersNone(\n  editor: SlateEditor,\n  cells: TTableCellElement[]\n): boolean {\n  return cells.every((cell) => {\n    const { borders } = cell;\n    const { col, row } = getCellIndices(editor, cell);\n    const cellPath = editor.api.findPath(cell);\n\n    if (!cellPath) return true;\n\n    // Check own borders\n    const isFirstRow = row === 0;\n    const isFirstCell = col === 0;\n\n    if (isFirstRow && (borders?.top?.size ?? 1) > 0) return false;\n    if (isFirstCell && (borders?.left?.size ?? 1) > 0) return false;\n    if ((borders?.bottom?.size ?? 1) > 0) return false;\n    if ((borders?.right?.size ?? 1) > 0) return false;\n    // Check adjacent cells' borders\n    if (!isFirstRow) {\n      const cellAboveEntry = getTopTableCell(editor, { at: cellPath });\n\n      if (cellAboveEntry) {\n        const [cellAbove] = cellAboveEntry;\n\n        if ((cellAbove.borders?.bottom?.size ?? 1) > 0) return false;\n      }\n    }\n    if (!isFirstCell) {\n      const prevCellEntry = getLeftTableCell(editor, { at: cellPath });\n\n      if (prevCellEntry) {\n        const [prevCell] = prevCellEntry;\n\n        if ((prevCell.borders?.right?.size ?? 1) > 0) return false;\n      }\n    }\n\n    return true;\n  });\n}\n\n/**\n * Tells if the bounding rectangle for the entire selection is fully set for the\n * **outer** edges, i.e. top/left/bottom/right edges have size=1. We ignore\n * internal edges, only bounding rectangle edges.\n */\nexport function isSelectedCellBordersOuter(\n  editor: SlateEditor,\n  cells: TTableCellElement[]\n): boolean {\n  const { maxCol, maxRow, minCol, minRow } = getSelectedCellsBoundingBox(\n    editor,\n    cells\n  );\n\n  // For each cell, figure out which edges are relevant on the bounding rect\n  // and confirm they are all size=1\n  for (const cell of cells) {\n    const { col, row } = getCellIndices(editor, cell);\n    const cSpan = getColSpan(cell);\n    const rSpan = getRowSpan(cell);\n\n    for (let rr = row; rr < row + rSpan; rr++) {\n      for (let cc = col; cc < col + cSpan; cc++) {\n        // If on top boundary => must have top=1, etc.\n        if (rr === minRow && (cell.borders?.top?.size ?? 1) < 1) return false;\n        if (rr === maxRow && (cell.borders?.bottom?.size ?? 1) < 1)\n          return false;\n        if (cc === minCol && (cell.borders?.left?.size ?? 1) < 1) return false;\n        if (cc === maxCol && (cell.borders?.right?.size ?? 1) < 1) return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Tells if the bounding rectangle for the entire selection is fully set for\n * that single side. Example: border='top' => if every cell that sits along the\n * top boundary has top=1.\n */\nexport function isSelectedCellBorder(\n  editor: SlateEditor,\n  cells: TTableCellElement[],\n  side: BorderDirection\n): boolean {\n  const { maxCol, maxRow, minCol, minRow } = getSelectedCellsBoundingBox(\n    editor,\n    cells\n  );\n\n  return cells.every((cell) => {\n    const { col, row } = getCellIndices(editor, cell);\n    const cSpan = getColSpan(cell);\n    const rSpan = getRowSpan(cell);\n    const cellPath = editor.api.findPath(cell);\n\n    if (!cellPath) return true;\n\n    for (let rr = row; rr < row + rSpan; rr++) {\n      for (let cc = col; cc < col + cSpan; cc++) {\n        if (side === 'top' && rr === minRow) {\n          const isFirstRow = row === 0;\n\n          if (isFirstRow) {\n            return (cell.borders?.top?.size ?? 1) >= 1;\n          }\n\n          const cellAboveEntry = getTopTableCell(editor, { at: cellPath });\n\n          if (!cellAboveEntry) return true;\n\n          const [cellAboveNode] = cellAboveEntry;\n\n          return (cellAboveNode.borders?.bottom?.size ?? 1) >= 1;\n        }\n        if (side === 'bottom' && rr === maxRow) {\n          return (cell.borders?.bottom?.size ?? 1) >= 1;\n        }\n        if (side === 'left' && cc === minCol) {\n          const isFirstCell = col === 0;\n\n          if (isFirstCell) {\n            return (cell.borders?.left?.size ?? 1) >= 1;\n          }\n\n          const prevCellEntry = getLeftTableCell(editor, { at: cellPath });\n\n          if (!prevCellEntry) return true;\n\n          const [prevCellNode] = prevCellEntry;\n\n          return (prevCellNode.borders?.right?.size ?? 1) >= 1;\n        }\n        if (side === 'right' && cc === maxCol) {\n          return (cell.borders?.right?.size ?? 1) >= 1;\n        }\n      }\n    }\n\n    return true;\n  });\n}\n","import type { EditorAboveOptions, SlateEditor } from '@udecode/plate';\n\nimport { BaseTablePlugin } from '../BaseTablePlugin';\n\nexport const getTableAbove = (\n  editor: SlateEditor,\n  options?: EditorAboveOptions\n) =>\n  editor.api.block({\n    above: true,\n    match: {\n      type: editor.getType(BaseTablePlugin),\n    },\n    ...options,\n  });\n","import type { SlateEditor } from '@udecode/plate';\n\nimport type {\n  BorderDirection,\n  BorderStyle,\n  TTableCellElement,\n  TTableElement,\n  TTableRowElement,\n} from '../types';\n\nimport { type CellIndices, getCellIndices } from '../utils/getCellIndices';\n\nexport interface BorderStylesDefault {\n  bottom: BorderStyle;\n  right: BorderStyle;\n  left?: BorderStyle;\n  top?: BorderStyle;\n}\n\nexport const getTableCellBorders = (\n  editor: SlateEditor,\n  {\n    cellIndices,\n    defaultBorder = {\n      size: 1,\n    },\n    element,\n  }: {\n    element: TTableCellElement;\n    cellIndices?: CellIndices;\n    defaultBorder?: BorderStyle;\n  }\n): BorderStylesDefault => {\n  const cellPath = editor.api.findPath(element)!;\n  const [rowNode, rowPath] = editor.api.parent<TTableRowElement>(cellPath)!;\n  const [tableNode] = editor.api.parent<TTableElement>(rowPath)!;\n\n  const { col } = cellIndices ?? getCellIndices(editor, element);\n  const isFirstCell = col === 0;\n  const isFirstRow = tableNode.children?.[0] === rowNode;\n\n  const getBorder = (dir: BorderDirection) => {\n    const border = element.borders?.[dir];\n\n    return {\n      color: border?.color ?? defaultBorder.color,\n      size: border?.size ?? defaultBorder.size,\n      style: border?.style ?? defaultBorder.style,\n    };\n  };\n\n  return {\n    bottom: getBorder('bottom'),\n    left: isFirstCell ? getBorder('left') : undefined,\n    right: getBorder('right'),\n    top: isFirstRow ? getBorder('top') : undefined,\n  };\n};\n","import { type SlateEditor, getEditorPlugin } from '@udecode/plate';\n\nimport {\n  type CellIndices,\n  type TableConfig,\n  type TTableCellElement,\n  type TTableElement,\n  type TTableRowElement,\n  getCellIndices,\n  getTableOverriddenColSizes,\n} from '..';\n\n/** Get the width of a cell with colSpan support. */\nexport const getTableCellSize = (\n  editor: SlateEditor,\n  {\n    cellIndices,\n    colSizes,\n    element,\n    rowSize,\n  }: {\n    element: TTableCellElement;\n    cellIndices?: CellIndices;\n    colSizes?: number[];\n    rowSize?: number;\n  }\n) => {\n  const { api } = getEditorPlugin<TableConfig>(editor, {\n    key: 'table',\n  });\n  const path = editor.api.findPath(element)!;\n\n  if (!rowSize) {\n    const [rowElement] = editor.api.parent<TTableRowElement>(path) ?? [];\n\n    if (!rowElement) return { minHeight: 0, width: 0 };\n\n    rowSize = rowElement.size;\n  }\n  if (!colSizes) {\n    const [, rowPath] = editor.api.parent<TTableRowElement>(path)!;\n    const [tableNode] = editor.api.parent<TTableElement>(rowPath)!;\n    colSizes = getTableOverriddenColSizes(tableNode);\n  }\n\n  const colSpan = api.table.getColSpan(element);\n\n  const { col } = cellIndices ?? getCellIndices(editor, element);\n\n  const width = (colSizes ?? [])\n    .slice(col, col + colSpan)\n    .reduce((total, w) => total + (w || 0), 0);\n\n  return { minHeight: rowSize, width };\n};\n","import type { TElement } from '@udecode/plate';\n\nexport const getTableColumnCount = (tableNode: TElement): number => {\n  if ((tableNode.children as TElement[])?.[0]?.children) {\n    return (tableNode.children as TElement[])[0].children\n      .map(\n        (element) =>\n          element.colSpan || (element?.attributes as any)?.colspan || 1\n      )\n      .reduce((total: number, num: number) => Number(total) + Number(num));\n  }\n\n  return 0;\n};\n","import type { SlateEditor, TLocation } from '@udecode/plate';\n\nimport { BaseTablePlugin, BaseTableRowPlugin } from '../BaseTablePlugin';\nimport { getCellTypes } from '../utils';\n\n/**\n * If at (default = selection) is in table>tr>td|th, return table, row, and cell\n * node entries.\n */\nexport const getTableEntries = (\n  editor: SlateEditor,\n  { at = editor.selection }: { at?: TLocation | null } = {}\n) => {\n  if (!at) return;\n\n  const cellEntry = editor.api.node({\n    at,\n    match: {\n      type: getCellTypes(editor),\n    },\n  });\n\n  if (!cellEntry) return;\n\n  const [, cellPath] = cellEntry;\n\n  const rowEntry = editor.api.above({\n    at: cellPath,\n    match: { type: editor.getType(BaseTableRowPlugin) },\n  });\n\n  if (!rowEntry) return;\n\n  const [, rowPath] = rowEntry;\n\n  const tableEntry = editor.api.above({\n    at: rowPath,\n    match: { type: editor.getType(BaseTablePlugin) },\n  });\n\n  if (!tableEntry) return;\n\n  return {\n    cell: cellEntry,\n    row: rowEntry,\n    table: tableEntry,\n  };\n};\n","import type { TableStoreSizeOverrides, TTableElement } from '../types';\n\nimport { getTableColumnCount } from './index';\n\n/**\n * Returns node.colSizes if it exists, applying overrides, otherwise returns a\n * 0-filled array.\n */\nexport const getTableOverriddenColSizes = (\n  tableNode: TTableElement,\n  colSizeOverrides?: TableStoreSizeOverrides\n): number[] => {\n  const colCount = getTableColumnCount(tableNode);\n\n  const colSizes = (\n    tableNode.colSizes\n      ? [...tableNode.colSizes]\n      : (Array.from({ length: colCount }).fill(0) as number[])\n  ).map((size, index) => colSizeOverrides?.get?.(index) ?? size);\n\n  return colSizes;\n};\n","import type { OverrideEditor } from '@udecode/plate';\n\nimport { type TableConfig, getTableAbove } from '.';\nimport { getTableGridAbove } from './queries';\n\nexport const withInsertTextTable: OverrideEditor<TableConfig> = ({\n  editor,\n  tf: { insertText },\n}) => ({\n  transforms: {\n    insertText(text, options) {\n      if (editor.api.isExpanded()) {\n        const entry = getTableAbove(editor, {\n          at: editor.selection?.anchor,\n        });\n\n        if (entry) {\n          const cellEntries = getTableGridAbove(editor, {\n            format: 'cell',\n          });\n\n          if (cellEntries.length > 1) {\n            editor.tf.collapse({\n              edge: 'focus',\n            });\n          }\n        }\n      }\n\n      insertText(text, options);\n    },\n  },\n});\n","import { type OverrideEditor, TextApi } from '@udecode/plate';\n\nimport type { TableConfig } from '.';\n\nimport { getTableGridAbove } from './queries';\n\nexport const withMarkTable: OverrideEditor<TableConfig> = ({\n  api: { marks },\n  editor,\n  tf: { addMark, removeMark },\n}) => ({\n  api: {\n    marks() {\n      const { selection } = editor;\n\n      if (!selection || editor.api.isCollapsed()) return marks();\n\n      const matchesCell = getTableGridAbove(editor, { format: 'cell' });\n\n      if (matchesCell.length === 0) return marks();\n\n      const totalMarks: Record<string, any> = {};\n\n      matchesCell.forEach(([_cell, cellPath]) => {\n        const textNodeEntry = editor.api.nodes({\n          at: cellPath,\n          match: (n) => TextApi.isText(n),\n        });\n\n        Array.from(textNodeEntry, (item) => item[0]).forEach((item) => {\n          const keys = Object.keys(item);\n\n          if (keys.length === 1) return;\n\n          keys.splice(keys.indexOf('text'), 1);\n\n          keys.forEach((k) => {\n            totalMarks[k] = item[k];\n          });\n        });\n      });\n\n      return totalMarks;\n    },\n  },\n  transforms: {\n    addMark(key: string, value: any) {\n      const { selection } = editor;\n\n      if (!selection || editor.api.isCollapsed()) return addMark(key, value);\n\n      const matchesCell = getTableGridAbove(editor, { format: 'cell' });\n\n      if (matchesCell.length <= 1) return addMark(key, value);\n\n      matchesCell.forEach(([_cell, cellPath]) => {\n        editor.tf.setNodes(\n          {\n            [key]: value,\n          },\n          {\n            at: cellPath,\n            split: true,\n            voids: true,\n            match: (n) => TextApi.isText(n),\n          }\n        );\n      });\n    },\n\n    removeMark(key: string) {\n      const { selection } = editor;\n\n      if (!selection || editor.api.isCollapsed()) return removeMark(key);\n\n      const matchesCell = getTableGridAbove(editor, { format: 'cell' });\n\n      if (matchesCell.length === 0) return removeMark(key);\n\n      matchesCell.forEach(([_cell, cellPath]) => {\n        editor.tf.unsetNodes(key, {\n          at: cellPath,\n          split: true,\n          voids: true,\n          match: (n) => TextApi.isText(n),\n        });\n      });\n    },\n  },\n});\n","import {\n  type OverrideEditor,\n  type TElement,\n  ElementApi,\n  TextApi,\n} from '@udecode/plate';\n\nimport type { TTableCellElement, TTableElement } from './types';\n\nimport { type TableConfig, BaseTableRowPlugin } from './BaseTablePlugin';\nimport { getTableColumnCount } from './queries';\nimport { computeCellIndices, getCellTypes } from './utils/index';\n\n/**\n * Normalize table:\n *\n * - Wrap cell children in a paragraph if they are texts.\n */\nexport const withNormalizeTable: OverrideEditor<TableConfig> = ({\n  editor,\n  getOption,\n  getOptions,\n  tf: { normalizeNode },\n  type,\n}) => ({\n  transforms: {\n    normalizeNode([n, path]) {\n      const { enableUnsetSingleColSize, initialTableWidth } = getOptions();\n\n      if (ElementApi.isElement(n)) {\n        if (n.type === type) {\n          const node = n as TTableElement;\n\n          if (\n            !node.children.some(\n              (child) =>\n                ElementApi.isElement(child) &&\n                child.type === editor.getType(BaseTableRowPlugin)\n            )\n          ) {\n            editor.tf.removeNodes({ at: path });\n\n            return;\n          }\n          if (\n            node.colSizes &&\n            node.colSizes.length > 0 &&\n            enableUnsetSingleColSize &&\n            getTableColumnCount(node) < 2\n          ) {\n            editor.tf.unsetNodes('colSizes', {\n              at: path,\n            });\n\n            return;\n          }\n\n          const tableEntry = editor.api.block({\n            above: true,\n            at: path,\n            match: { type: type },\n          });\n\n          if (tableEntry) {\n            editor.tf.unwrapNodes({\n              at: path,\n            });\n\n            return;\n          }\n          if (initialTableWidth) {\n            const tableNode = node as TTableElement;\n            const colCount = (\n              tableNode.children[0]?.children as TElement[] | undefined\n            )?.length;\n\n            if (colCount) {\n              const colSizes: number[] = [];\n\n              if (!tableNode.colSizes) {\n                for (let i = 0; i < colCount; i++) {\n                  colSizes.push(initialTableWidth / colCount);\n                }\n              } else if (tableNode.colSizes.some((size) => !size)) {\n                tableNode.colSizes.forEach((colSize) => {\n                  colSizes.push(colSize || initialTableWidth / colCount);\n                });\n              }\n              if (colSizes.length > 0) {\n                editor.tf.setNodes<TTableElement>({ colSizes }, { at: path });\n\n                return;\n              }\n            }\n          }\n        }\n        if (n.type === editor.getType(BaseTableRowPlugin)) {\n          const parentEntry = editor.api.parent(path);\n\n          if (parentEntry?.[0].type !== type) {\n            editor.tf.unwrapNodes({\n              at: path,\n            });\n\n            return;\n          }\n        }\n        if (getCellTypes(editor).includes(n.type)) {\n          const node = n as TTableCellElement;\n          const cellIndices = getOption('cellIndices', node.id as string);\n\n          if (node.id && !cellIndices) {\n            computeCellIndices(editor, {\n              all: true,\n              cellNode: node,\n            });\n          }\n\n          const { children } = node;\n          const parentEntry = editor.api.parent(path);\n\n          if (parentEntry?.[0].type !== editor.getType(BaseTableRowPlugin)) {\n            editor.tf.unwrapNodes({\n              at: path,\n            });\n\n            return;\n          }\n          if (TextApi.isText(children[0])) {\n            editor.tf.wrapNodes(editor.api.create.block({}, path), {\n              at: path,\n              children: true,\n            });\n\n            return;\n          }\n        }\n      }\n\n      normalizeNode([n, path]);\n    },\n  },\n});\n","import type { OverrideEditor, TElement } from '@udecode/plate';\n\nimport type { TableConfig, TTableCellElement, TTableElement } from '.';\n\nimport { BaseTableCellHeaderPlugin, BaseTablePlugin } from './BaseTablePlugin';\nimport { getTableGridAbove } from './queries';\n\nexport const withSetFragmentDataTable: OverrideEditor<TableConfig> = ({\n  api,\n  editor,\n  plugin,\n  tf: { setFragmentData },\n}) => ({\n  transforms: {\n    setFragmentData(data, originEvent) {\n      const tableEntry = getTableGridAbove(editor, {\n        format: 'table',\n      })?.[0];\n      const selectedCellEntries = getTableGridAbove(editor, {\n        format: 'cell',\n      });\n\n      const initialSelection = editor.selection;\n\n      if (!tableEntry || !initialSelection) {\n        setFragmentData(data, originEvent);\n\n        return;\n      }\n\n      const [tableNode, tablePath] = tableEntry;\n      const tableRows = tableNode.children as TElement[];\n      tableNode.children = tableNode.children.filter(\n        (v) => (v as TTableCellElement).children.length > 0\n      );\n\n      let textCsv = '';\n      let textTsv = '';\n\n      const divElement = document.createElement('div');\n      const tableElement = document.createElement('table');\n\n      /**\n       * Cover single cell copy | cut operation. In this case, copy cell content\n       * instead of table structure.\n       */\n      if (\n        tableEntry &&\n        initialSelection &&\n        selectedCellEntries.length === 1 &&\n        (originEvent === 'copy' || originEvent === 'cut')\n      ) {\n        setFragmentData(data);\n\n        return;\n      }\n\n      editor.tf.withoutNormalizing(() => {\n        tableRows.forEach((row) => {\n          const rowCells = row.children as TTableCellElement[];\n          const cellStrings: string[] = [];\n          const rowElement =\n            row.type === editor.getType(BaseTableCellHeaderPlugin)\n              ? document.createElement('th')\n              : document.createElement('tr');\n\n          rowCells.forEach((cell) => {\n            // need to clean data before every iteration\n            data.clearData();\n\n            const cellPath = editor.api.findPath(cell)!;\n\n            // select cell by cell\n            editor.tf.select({\n              anchor: editor.api.start(cellPath)!,\n              focus: editor.api.end(cellPath)!,\n            });\n\n            // set data from selection\n            setFragmentData(data);\n\n            // get plain text\n            cellStrings.push(data.getData('text/plain'));\n\n            const cellElement = document.createElement('td');\n\n            const colSpan = api.table.getColSpan(cell);\n            cellElement.colSpan = colSpan;\n            const rowSpan = api.table.getRowSpan(cell);\n            cellElement.rowSpan = rowSpan;\n\n            cellElement.innerHTML = data.getData('text/html');\n            rowElement.append(cellElement);\n          });\n\n          tableElement.append(rowElement);\n\n          textCsv += `${cellStrings.join(',')}\\n`;\n          textTsv += `${cellStrings.join('\\t')}\\n`;\n        });\n\n        const _tableEntry = editor.api.node<TTableElement>({\n          at: tablePath,\n          match: { type: BaseTablePlugin.key },\n        });\n\n        if (_tableEntry != null && _tableEntry.length > 0) {\n          const realTable = _tableEntry[0];\n\n          if (realTable.attributes != null) {\n            Object.entries(realTable.attributes).forEach(([key, value]) => {\n              if (\n                value != null &&\n                plugin.node.dangerouslyAllowAttributes?.includes(key)\n              ) {\n                tableElement.setAttribute(key, String(value));\n              }\n            });\n          }\n        }\n\n        // select back original cells\n        editor.tf.select(initialSelection!);\n\n        divElement.append(tableElement);\n      });\n\n      data.setData('text/csv', textCsv);\n      data.setData('text/tsv', textTsv);\n      data.setData('text/plain', textTsv);\n      data.setData('text/html', divElement.innerHTML);\n\n      // set slate fragment\n      const selectedFragmentStr = JSON.stringify([tableNode]);\n      const encodedFragment = window.btoa(\n        encodeURIComponent(selectedFragmentStr)\n      );\n      data.setData('application/x-slate-fragment', encodedFragment);\n    },\n  },\n});\n","import type { OverrideEditor } from '@udecode/plate';\n\nimport type { TableConfig } from './BaseTablePlugin';\n\nimport { withApplyTable } from './withApplyTable';\nimport { withDeleteTable } from './withDeleteTable';\nimport { withGetFragmentTable } from './withGetFragmentTable';\nimport { withInsertFragmentTable } from './withInsertFragmentTable';\nimport { withInsertTextTable } from './withInsertTextTable';\nimport { withMarkTable } from './withMarkTable';\nimport { withNormalizeTable } from './withNormalizeTable';\nimport { withSetFragmentDataTable } from './withSetFragmentDataTable';\n\nexport const withTable: OverrideEditor<TableConfig> = (ctx) => {\n  const mark = withMarkTable(ctx);\n\n  return {\n    api: {\n      // getFragment\n      ...withGetFragmentTable(ctx).api,\n      ...mark.api,\n    },\n    transforms: {\n      // normalize\n      ...withNormalizeTable(ctx).transforms,\n      // delete\n      ...withDeleteTable(ctx).transforms,\n      // insertFragment\n      ...withInsertFragmentTable(ctx).transforms,\n      // insertText\n      ...withInsertTextTable(ctx).transforms,\n      // apply\n      ...withApplyTable(ctx).transforms,\n      // setFragmentData\n      ...withSetFragmentDataTable(ctx).transforms,\n      // addMark, removeMark\n      ...mark.transforms,\n    },\n  };\n};\n","import {\n  type SlateEditor,\n  type TElement,\n  getEditorPlugin,\n} from '@udecode/plate';\n\nimport type { TTableElement } from '../types';\n\nimport { type TableConfig, BaseTableRowPlugin } from '../BaseTablePlugin';\nimport { deleteTableMergeColumn } from '../merge/deleteColumn';\nimport { deleteColumnWhenExpanded } from '../merge/deleteColumnWhenExpanded';\nimport { getCellTypes } from '../utils';\n\nexport const deleteColumn = (editor: SlateEditor) => {\n  const { getOptions, type } = getEditorPlugin<TableConfig>(editor, {\n    key: 'table',\n  });\n  const { disableMerge } = getOptions();\n\n  const tableEntry = editor.api.above<TTableElement>({\n    match: { type },\n  });\n\n  if (!tableEntry) return;\n\n  editor.tf.withoutNormalizing(() => {\n    if (!disableMerge) {\n      deleteTableMergeColumn(editor);\n\n      return;\n    }\n    if (editor.api.isExpanded())\n      return deleteColumnWhenExpanded(editor, tableEntry);\n\n    const tdEntry = editor.api.above({\n      match: { type: getCellTypes(editor) },\n    });\n    const trEntry = editor.api.above({\n      match: { type: editor.getType(BaseTableRowPlugin) },\n    });\n\n    if (\n      tdEntry &&\n      trEntry &&\n      tableEntry &&\n      // Cannot delete the last cell\n      trEntry[0].children.length > 1\n    ) {\n      const [tableNode, tablePath] = tableEntry;\n\n      const tdPath = tdEntry[1];\n      const colIndex = tdPath.at(-1)!;\n\n      const pathToDelete = tdPath.slice();\n      const replacePathPos = pathToDelete.length - 2;\n\n      tableNode.children.forEach((row, rowIdx) => {\n        pathToDelete[replacePathPos] = rowIdx;\n\n        // for tables containing rows of different lengths\n        // - don't delete if only one cell in row\n        // - don't delete if row doesn't have this cell\n        if (\n          (row.children as TElement[]).length === 1 ||\n          colIndex > (row.children as TElement[]).length - 1\n        )\n          return;\n\n        editor.tf.removeNodes({ at: pathToDelete });\n      });\n\n      const { colSizes } = tableNode;\n\n      if (colSizes) {\n        const newColSizes = [...colSizes];\n        newColSizes.splice(colIndex, 1);\n\n        editor.tf.setNodes<TTableElement>(\n          { colSizes: newColSizes },\n          { at: tablePath }\n        );\n      }\n    }\n  });\n\n  // computeCellIndices(editor, {\n  //   tableNode: tableEntry[0],\n  // });\n};\n","import {\n  type NodeEntry,\n  type PathRef,\n  type SlateEditor,\n  NodeApi,\n  RangeApi,\n} from '@udecode/plate';\n\nimport { type TTableCellElement, BaseTableRowPlugin } from '..';\nimport { getTableGridAbove } from '../queries';\n\nexport const deleteColumnWhenExpanded = (\n  editor: SlateEditor,\n  tableEntry: NodeEntry<TTableCellElement>\n) => {\n  const [start, end] = RangeApi.edges(editor.selection!);\n  const firstRow = NodeApi.child(tableEntry[0], 0) as TTableCellElement;\n  const lastRow = NodeApi.child(\n    tableEntry[0],\n    tableEntry[0].children.length - 1\n  ) as TTableCellElement;\n\n  const firstSelectionRow = editor.api.above({\n    at: start,\n    match: (n) => n.type === BaseTableRowPlugin.key,\n  });\n\n  const lastSelectionRow = editor.api.above({\n    at: end,\n    match: (n) => n.type === BaseTableRowPlugin.key,\n  });\n\n  if (!firstSelectionRow || !lastSelectionRow) return;\n  if (\n    firstRow.id === firstSelectionRow[0].id &&\n    lastSelectionRow[0].id === lastRow.id\n  )\n    deleteSelection(editor);\n};\n\nconst deleteSelection = (editor: SlateEditor) => {\n  const cells = getTableGridAbove(editor, {\n    format: 'cell',\n  }) as NodeEntry<TTableCellElement>[];\n\n  const pathRefs: PathRef[] = [];\n\n  cells.forEach(([_cell, cellPath]) => {\n    pathRefs.push(editor.api.pathRef(cellPath));\n  });\n\n  pathRefs.forEach((pathRef) => {\n    editor.tf.removeNodes({ at: pathRef.unref()! });\n  });\n};\n","import { type SlateEditor, getEditorPlugin } from '@udecode/plate';\n\nimport { type TableConfig, type TTableElement, BaseTableRowPlugin } from '..';\nimport { deleteRowWhenExpanded } from '../merge';\nimport { deleteTableMergeRow } from '../merge/deleteRow';\n\nexport const deleteRow = (editor: SlateEditor) => {\n  const { getOptions, type } = getEditorPlugin<TableConfig>(editor, {\n    key: 'table',\n  });\n  const { disableMerge } = getOptions();\n\n  if (!disableMerge) {\n    return deleteTableMergeRow(editor);\n  }\n  if (\n    editor.api.some({\n      match: { type },\n    })\n  ) {\n    const currentTableItem = editor.api.above<TTableElement>({\n      match: { type },\n    });\n\n    if (!currentTableItem) return;\n    if (editor.api.isExpanded())\n      return deleteRowWhenExpanded(editor, currentTableItem);\n\n    const currentRowItem = editor.api.above({\n      match: { type: editor.getType(BaseTableRowPlugin) },\n    });\n\n    if (\n      currentRowItem &&\n      currentTableItem &&\n      // Cannot delete the last row\n      currentTableItem[0].children.length > 1\n    ) {\n      editor.tf.removeNodes({\n        at: currentRowItem[1],\n      });\n    }\n  }\n};\n","import { type SlateEditor, getEditorPlugin } from '@udecode/plate';\nimport cloneDeep from 'lodash/cloneDeep.js';\n\nimport type { TableConfig } from '../BaseTablePlugin';\n\nimport {\n  type TTableCellElement,\n  type TTableElement,\n  type TTableRowElement,\n  findCellByIndexes,\n  getCellIndices,\n  getCellTypes,\n  getTableColumnCount,\n} from '..';\nimport { deleteRowWhenExpanded } from './deleteRowWhenExpanded';\n\nexport const deleteTableMergeRow = (editor: SlateEditor) => {\n  const { api, tf, type } = getEditorPlugin<TableConfig>(editor, {\n    key: 'table',\n  });\n\n  if (\n    editor.api.some({\n      match: { type },\n    })\n  ) {\n    const currentTableItem = editor.api.above<TTableElement>({\n      match: { type },\n    });\n\n    if (!currentTableItem) return;\n    if (editor.api.isExpanded())\n      return deleteRowWhenExpanded(editor, currentTableItem);\n\n    const table = currentTableItem[0] as TTableElement;\n\n    const selectedCellEntry = editor.api.above({\n      match: { type: getCellTypes(editor) },\n    });\n\n    if (!selectedCellEntry) return;\n\n    const selectedCell = selectedCellEntry[0] as TTableCellElement;\n    const { row: deletingRowIndex } = getCellIndices(editor, selectedCell);\n    const rowsDeleteNumber = api.table.getRowSpan(selectedCell);\n    const endingRowIndex = deletingRowIndex + rowsDeleteNumber - 1;\n\n    const colNumber = getTableColumnCount(table);\n    const affectedCellsSet = new Set();\n    // iterating by columns is important here to keep the order of affected cells\n    Array.from({ length: colNumber }, (_, i) => i).forEach((cI) => {\n      return Array.from({ length: rowsDeleteNumber }, (_, i) => i).forEach(\n        (rI) => {\n          const rowIndex = deletingRowIndex + rI;\n          const found = findCellByIndexes(editor, table, rowIndex, cI);\n          affectedCellsSet.add(found);\n        }\n      );\n    });\n    const affectedCells = Array.from(affectedCellsSet) as TTableCellElement[];\n\n    const { moveToNextRowCells, squizeRowSpanCells } = affectedCells.reduce<{\n      moveToNextRowCells: TTableCellElement[];\n      squizeRowSpanCells: TTableCellElement[];\n    }>(\n      (acc, cur) => {\n        if (!cur) return acc;\n\n        const currentCell = cur as TTableCellElement;\n        const { row: curRowIndex } = getCellIndices(editor, currentCell);\n        const curRowSpan = api.table.getRowSpan(currentCell);\n\n        // if (!curRowIndex || !curRowSpan) return acc;\n\n        if (curRowIndex < deletingRowIndex && curRowSpan > 1) {\n          acc.squizeRowSpanCells.push(currentCell);\n        } else if (\n          curRowSpan > 1 &&\n          curRowIndex + curRowSpan - 1 > endingRowIndex\n        ) {\n          acc.moveToNextRowCells.push(currentCell);\n        }\n\n        return acc;\n      },\n      { moveToNextRowCells: [], squizeRowSpanCells: [] }\n    );\n\n    const nextRowIndex = deletingRowIndex + rowsDeleteNumber;\n    const nextRow = table.children[nextRowIndex] as\n      | TTableCellElement\n      | undefined;\n\n    if (nextRow === undefined && deletingRowIndex === 0) {\n      tf.remove.table();\n\n      return;\n    }\n    if (nextRow) {\n      for (let index = 0; index < moveToNextRowCells.length; index++) {\n        const curRowCell = moveToNextRowCells[index] as TTableCellElement;\n        const { col: curRowCellColIndex, row: curRowCellRowIndex } =\n          getCellIndices(editor, curRowCell);\n        const curRowCellRowSpan = api.table.getRowSpan(curRowCell);\n\n        // search for anchor cell where to place current cell\n        const startingCellIndex = nextRow.children.findIndex((curC) => {\n          const cell = curC as TTableCellElement;\n          const { col: curColIndex } = getCellIndices(editor, cell);\n\n          return curColIndex >= curRowCellColIndex;\n        });\n\n        if (startingCellIndex === -1) {\n          const startingCell = nextRow.children.at(-1) as TTableCellElement;\n          const startingCellPath = editor.api.findPath(startingCell)!;\n          const tablePath = startingCellPath.slice(0, -2);\n          const colPath = startingCellPath.at(-1)! + index + 1;\n          const nextRowStartCellPath = [...tablePath, nextRowIndex, colPath];\n\n          const rowsNumberAffected = endingRowIndex - curRowCellRowIndex + 1;\n          const rowSpan = curRowCellRowSpan - rowsNumberAffected;\n          const newCell = cloneDeep({ ...curRowCell, rowSpan });\n\n          if (newCell.attributes?.rowspan) {\n            newCell.attributes.rowspan = rowSpan.toString();\n          }\n\n          editor.tf.insertNodes(newCell, {\n            at: nextRowStartCellPath,\n          });\n\n          continue;\n        }\n\n        const startingCell = nextRow.children[\n          startingCellIndex\n        ] as TTableCellElement;\n        const { col: startingColIndex } = getCellIndices(editor, startingCell);\n\n        // consider already inserted cell by adding index each time to the col path\n        let incrementBy = index;\n\n        if (startingColIndex < curRowCellColIndex) {\n          // place current cell after starting cell, if placing cell col index is grather than col index of starting cell\n          incrementBy += 1;\n        }\n\n        const startingCellPath = editor.api.findPath(startingCell)!;\n        const tablePath = startingCellPath.slice(0, -2);\n        const colPath = startingCellPath.at(-1)!;\n\n        const nextRowStartCellPath = [\n          ...tablePath,\n          nextRowIndex,\n          colPath + incrementBy,\n        ];\n\n        const rowsNumberAffected = endingRowIndex - curRowCellRowIndex + 1;\n        const rowSpan = curRowCellRowSpan - rowsNumberAffected;\n        const newCell = cloneDeep({ ...curRowCell, rowSpan });\n\n        if (newCell.attributes?.rowspan) {\n          newCell.attributes.rowspan = rowSpan.toString();\n        }\n\n        editor.tf.insertNodes(newCell, {\n          at: nextRowStartCellPath,\n        });\n      }\n    }\n\n    squizeRowSpanCells.forEach((cur) => {\n      const curRowCell = cur as TTableCellElement;\n      const { row: curRowCellRowIndex } = getCellIndices(editor, curRowCell);\n      const curRowCellRowSpan = api.table.getRowSpan(curRowCell);\n\n      const curCellPath = editor.api.findPath(curRowCell)!;\n\n      const curCellEndingRowIndex = Math.min(\n        curRowCellRowIndex + curRowCellRowSpan - 1,\n        endingRowIndex\n      );\n      const rowsNumberAffected = curCellEndingRowIndex - deletingRowIndex + 1;\n      const rowSpan = curRowCellRowSpan - rowsNumberAffected;\n      const newCell = cloneDeep({ ...curRowCell, rowSpan });\n\n      if (newCell.attributes?.rowspan) {\n        newCell.attributes.rowspan = rowSpan.toString();\n      }\n\n      editor.tf.setNodes<TTableCellElement>(newCell, { at: curCellPath });\n    });\n\n    const rowToDelete = table.children[deletingRowIndex] as TTableRowElement;\n    const rowPath = editor.api.findPath(rowToDelete);\n    Array.from({ length: rowsDeleteNumber }).forEach(() => {\n      editor.tf.removeNodes({\n        at: rowPath,\n      });\n    });\n  }\n};\n","import {\n  type NodeEntry,\n  type PathRef,\n  type SlateEditor,\n  getEditorPlugin,\n} from '@udecode/plate';\n\nimport {\n  type TTableCellElement,\n  BaseTablePlugin,\n  getCellRowIndexByPath,\n  getTableMergedColumnCount,\n} from '..';\nimport { getTableGridAbove } from '../queries';\n\nexport const deleteRowWhenExpanded = (\n  editor: SlateEditor,\n  [table, tablePath]: NodeEntry<TTableCellElement>\n) => {\n  const { api } = getEditorPlugin(editor, BaseTablePlugin);\n  const columnCount = getTableMergedColumnCount(table);\n\n  const cells = getTableGridAbove(editor, {\n    format: 'cell',\n  }) as NodeEntry<TTableCellElement>[];\n\n  const firsRowIndex = getCellRowIndexByPath(cells[0][1]);\n\n  if (firsRowIndex === null) return;\n\n  let acrossColumn = 0;\n  let lastRowIndex = -1;\n  let rowSpanCarry = 0;\n  let acrossRow = 0;\n\n  cells.forEach(([cell, cellPath]) => {\n    if (cellPath.at(-2) === firsRowIndex) {\n      acrossColumn += cell.colSpan ?? 1;\n    }\n\n    const currentRowIndex = getCellRowIndexByPath(cellPath);\n\n    if (lastRowIndex !== currentRowIndex) {\n      if (rowSpanCarry !== 0) {\n        rowSpanCarry--;\n\n        return;\n      }\n\n      const rowSpan = api.table.getRowSpan(cell);\n\n      rowSpanCarry = rowSpan && rowSpan > 1 ? rowSpan - 1 : 0;\n      acrossRow += rowSpan ?? 1;\n    }\n\n    lastRowIndex = currentRowIndex;\n  });\n\n  if (acrossColumn === columnCount) {\n    const pathRefs: PathRef[] = [];\n\n    for (let i = firsRowIndex; i < firsRowIndex + acrossRow; i++) {\n      const removedPath = tablePath.concat(i);\n      pathRefs.push(editor.api.pathRef(removedPath));\n    }\n\n    pathRefs.forEach((item) => {\n      editor.tf.removeNodes({ at: item.unref()! });\n    });\n  }\n};\n","import type { SlateEditor } from '@udecode/plate';\n\nimport { BaseTablePlugin } from '../BaseTablePlugin';\n\nexport const deleteTable = (editor: SlateEditor) => {\n  if (\n    editor.api.some({\n      match: { type: editor.getType(BaseTablePlugin) },\n    })\n  ) {\n    const tableItem = editor.api.above({\n      match: { type: editor.getType(BaseTablePlugin) },\n    });\n\n    if (tableItem) {\n      editor.tf.removeNodes({\n        at: tableItem[1],\n      });\n    }\n  }\n};\n","import {\n  type InsertNodesOptions,\n  type SlateEditor,\n  PathApi,\n} from '@udecode/plate';\n\nimport type { GetEmptyTableNodeOptions } from '../api/getEmptyTableNode';\nimport type { TTableElement } from '../types';\n\nimport { type TableConfig, BaseTablePlugin } from '../BaseTablePlugin';\n\n/**\n * Insert table. If selection in table and no 'at' specified, insert after\n * current table. Select start of new table.\n */\nexport const insertTable = (\n  editor: SlateEditor,\n  { colCount = 2, header, rowCount = 2 }: GetEmptyTableNodeOptions = {},\n  { select: shouldSelect, ...options }: InsertNodesOptions = {}\n) => {\n  const { api } = editor.getPlugin<TableConfig>({ key: 'table' });\n  const type = editor.getType(BaseTablePlugin);\n\n  editor.tf.withoutNormalizing(() => {\n    const newTable = api.create.table({\n      colCount,\n      header,\n      rowCount,\n    });\n\n    if (!options.at) {\n      const currentTableEntry = editor.api.block({\n        match: { type },\n      });\n\n      if (currentTableEntry) {\n        // Insert after current table\n        const [, tablePath] = currentTableEntry;\n        const insertPath = PathApi.next(tablePath);\n\n        editor.tf.insertNodes<TTableElement>(newTable, {\n          at: insertPath,\n          ...(options as any),\n        });\n\n        if (editor.selection) {\n          editor.tf.select(editor.api.start(insertPath)!);\n        }\n\n        return;\n      }\n    }\n\n    // Use specified path or insert at current selection\n    editor.tf.insertNodes<TTableElement>(newTable, {\n      nextBlock: !options.at,\n      select: shouldSelect,\n      ...(options as any),\n    });\n\n    if (shouldSelect) {\n      const tableEntry = editor.api.node({\n        at: options.at,\n        match: { type },\n      });\n\n      if (!tableEntry) return;\n\n      editor.tf.select(editor.api.start(tableEntry[1])!);\n    }\n  });\n};\n","import {\n  type Path,\n  type SlateEditor,\n  type TElement,\n  getEditorPlugin,\n  NodeApi,\n  PathApi,\n} from '@udecode/plate';\n\nimport type { TTableElement } from '../types';\n\nimport { BaseTableCellHeaderPlugin, BaseTablePlugin } from '../BaseTablePlugin';\nimport { insertTableMergeColumn } from '../merge/insertTableColumn';\nimport { getCellTypes } from '../utils/index';\n\nexport const insertTableColumn = (\n  editor: SlateEditor,\n  options: {\n    /** Exact path of the cell to insert the column at. Will overrule `fromCell`. */\n    at?: Path;\n    /** Insert the column before the current column instead of after */\n    before?: boolean;\n    /** Path of the cell to insert the column from. */\n    fromCell?: Path;\n    header?: boolean;\n    select?: boolean;\n  } = {}\n) => {\n  const { api, getOptions, type } = getEditorPlugin(editor, BaseTablePlugin);\n\n  const { disableMerge, initialTableWidth, minColumnWidth } = getOptions();\n\n  if (!disableMerge) {\n    return insertTableMergeColumn(editor, options);\n  }\n\n  const { before, header, select: shouldSelect } = options;\n  let { at, fromCell } = options;\n\n  if (at && !fromCell) {\n    const table = NodeApi.get<TTableElement>(editor, at);\n\n    if (table?.type === editor.getType(BaseTablePlugin)) {\n      fromCell = NodeApi.lastChild(editor, at.concat([0]))![1];\n      at = undefined;\n    }\n  }\n\n  const cellEntry = editor.api.block({\n    at: fromCell,\n    match: { type: getCellTypes(editor) },\n  });\n\n  if (!cellEntry) return;\n\n  const [, cellPath] = cellEntry;\n\n  const tableEntry = editor.api.block<TTableElement>({\n    above: true,\n    at: cellPath,\n    match: { type },\n  });\n\n  if (!tableEntry) return;\n\n  const [tableNode, tablePath] = tableEntry;\n\n  let nextCellPath: Path;\n  let nextColIndex: number;\n\n  if (PathApi.isPath(at)) {\n    nextCellPath = at;\n    nextColIndex = at.at(-1)!;\n  } else {\n    nextCellPath = before ? cellPath : PathApi.next(cellPath);\n    nextColIndex = before ? cellPath.at(-1)! : cellPath.at(-1)! + 1;\n  }\n\n  const currentRowIndex = cellPath.at(-2);\n\n  editor.tf.withoutNormalizing(() => {\n    // for each row, insert a new cell\n    tableNode.children.forEach((row, rowIndex) => {\n      const insertCellPath = [...nextCellPath];\n\n      if (PathApi.isPath(at)) {\n        insertCellPath[at.length - 2] = rowIndex;\n      } else {\n        insertCellPath[cellPath.length - 2] = rowIndex;\n      }\n\n      const isHeaderRow =\n        header === undefined\n          ? (row as TElement).children.every(\n              (c) => c.type === editor.getType(BaseTableCellHeaderPlugin)\n            )\n          : header;\n\n      editor.tf.insertNodes(\n        api.create.tableCell({\n          header: isHeaderRow,\n        }),\n        {\n          at: insertCellPath,\n          select: shouldSelect && rowIndex === currentRowIndex,\n        }\n      );\n    });\n\n    const { colSizes } = tableNode;\n\n    if (colSizes) {\n      let newColSizes = [\n        ...colSizes.slice(0, nextColIndex),\n        0,\n        ...colSizes.slice(nextColIndex),\n      ];\n\n      if (initialTableWidth) {\n        newColSizes[nextColIndex] =\n          colSizes[nextColIndex] ??\n          colSizes[nextColIndex - 1] ??\n          initialTableWidth / colSizes.length;\n\n        const oldTotal = colSizes.reduce((a, b) => a + b, 0);\n        const newTotal = newColSizes.reduce((a, b) => a + b, 0);\n        const maxTotal = Math.max(oldTotal, initialTableWidth);\n\n        if (newTotal > maxTotal) {\n          const factor = maxTotal / newTotal;\n          newColSizes = newColSizes.map((size) =>\n            Math.max(minColumnWidth ?? 0, Math.floor(size * factor))\n          );\n        }\n      }\n\n      editor.tf.setNodes<TTableElement>(\n        {\n          colSizes: newColSizes,\n        },\n        {\n          at: tablePath,\n        }\n      );\n    }\n  });\n};\n","import {\n  type Path,\n  type SlateEditor,\n  getEditorPlugin,\n  NodeApi,\n  PathApi,\n} from '@udecode/plate';\nimport cloneDeep from 'lodash/cloneDeep.js';\n\nimport type {\n  TTableCellElement,\n  TTableElement,\n  TTableRowElement,\n} from '../types';\n\nimport { BaseTablePlugin } from '../BaseTablePlugin';\nimport { getCellTypes } from '../utils';\nimport { getCellIndices } from '../utils/getCellIndices';\nimport { findCellByIndexes } from './findCellByIndexes';\nimport { getCellPath } from './getCellPath';\n\nexport const insertTableMergeColumn = (\n  editor: SlateEditor,\n  {\n    at,\n    before,\n    fromCell,\n    header,\n    select: shouldSelect,\n  }: {\n    /** Exact path of the cell to insert the column at. Will overrule `fromCell`. */\n    at?: Path;\n    /** Insert the column before the current column instead of after */\n    before?: boolean;\n    /** Path of the cell to insert the column from. */\n    fromCell?: Path;\n    header?: boolean;\n    select?: boolean;\n  } = {}\n) => {\n  const { api, getOptions, type } = getEditorPlugin(editor, BaseTablePlugin);\n  const { initialTableWidth, minColumnWidth } = getOptions();\n\n  if (at && !fromCell) {\n    const table = NodeApi.get<TTableElement>(editor, at);\n\n    if (table?.type === editor.getType(BaseTablePlugin)) {\n      fromCell = NodeApi.lastChild(editor, at.concat([0]))![1];\n      at = undefined;\n    }\n  }\n\n  const cellEntry = fromCell\n    ? editor.api.node<TTableCellElement>({\n        at: fromCell,\n        match: { type: getCellTypes(editor) },\n      })\n    : editor.api.block<TTableCellElement>({\n        match: { type: getCellTypes(editor) },\n      });\n\n  if (!cellEntry) return;\n\n  const [, cellPath] = cellEntry;\n  const cell = cellEntry[0];\n\n  const tableEntry = editor.api.block<TTableElement>({\n    above: true,\n    at: cellPath,\n    match: { type },\n  });\n\n  if (!tableEntry) return;\n\n  const [tableNode, tablePath] = tableEntry;\n\n  const { col: cellColIndex } = getCellIndices(editor, cell);\n  const cellColSpan = api.table.getColSpan(cell);\n\n  let nextColIndex: number;\n  let checkingColIndex: number;\n\n  if (PathApi.isPath(at)) {\n    nextColIndex = cellColIndex;\n    checkingColIndex = cellColIndex - 1;\n  } else {\n    nextColIndex = before ? cellColIndex : cellColIndex + cellColSpan;\n    checkingColIndex = before ? cellColIndex : cellColIndex + cellColSpan - 1;\n  }\n\n  const rowNumber = tableNode.children.length;\n  const firstCol = nextColIndex <= 0;\n\n  let placementCorrection = before ? 0 : 1;\n\n  if (firstCol) {\n    checkingColIndex = 0;\n    placementCorrection = 0;\n  }\n\n  const affectedCellsSet = new Set();\n  Array.from({ length: rowNumber }, (_, i) => i).forEach((rI) => {\n    const found = findCellByIndexes(editor, tableNode, rI, checkingColIndex);\n\n    if (found) {\n      affectedCellsSet.add(found);\n    }\n  });\n  const affectedCells = Array.from(affectedCellsSet) as TTableCellElement[];\n\n  affectedCells.forEach((curCell) => {\n    const { col: curColIndex, row: curRowIndex } = getCellIndices(\n      editor,\n      curCell\n    );\n\n    const curRowSpan = api.table.getRowSpan(curCell);\n    const curColSpan = api.table.getColSpan(curCell);\n\n    const currentCellPath = getCellPath(\n      editor,\n      tableEntry,\n      curRowIndex,\n      curColIndex\n    );\n\n    const endCurI = curColIndex + curColSpan - 1;\n\n    if (endCurI >= nextColIndex && !firstCol && !before) {\n      const colSpan = curColSpan + 1;\n      const newCell = cloneDeep({ ...curCell, colSpan });\n\n      if (newCell.attributes?.colspan) {\n        newCell.attributes.colspan = colSpan.toString();\n      }\n\n      editor.tf.setNodes<TTableCellElement>(newCell, { at: currentCellPath });\n    } else {\n      const curRowPath = currentCellPath.slice(0, -1);\n      const curColPath = currentCellPath.at(-1)!;\n      const placementPath = [\n        ...curRowPath,\n        before ? curColPath : curColPath + placementCorrection,\n      ];\n\n      const row = editor.api.parent(currentCellPath)!;\n      const rowElement = row[0] as TTableRowElement;\n      const emptyCell = {\n        ...api.create.tableCell({ header, row: rowElement }),\n        colSpan: 1,\n        rowSpan: curRowSpan,\n      };\n      editor.tf.insertNodes(emptyCell, {\n        at: placementPath,\n        select: shouldSelect,\n      });\n    }\n  });\n\n  editor.tf.withoutNormalizing(() => {\n    const { colSizes } = tableNode;\n\n    if (colSizes) {\n      let newColSizes = [\n        ...colSizes.slice(0, nextColIndex),\n        0,\n        ...colSizes.slice(nextColIndex),\n      ];\n\n      if (initialTableWidth) {\n        newColSizes[nextColIndex] =\n          colSizes[nextColIndex] ??\n          colSizes[nextColIndex - 1] ??\n          initialTableWidth / colSizes.length;\n\n        const oldTotal = colSizes.reduce((a, b) => a + b, 0);\n        const newTotal = newColSizes.reduce((a, b) => a + b, 0);\n        const maxTotal = Math.max(oldTotal, initialTableWidth);\n\n        if (newTotal > maxTotal) {\n          const factor = maxTotal / newTotal;\n          newColSizes = newColSizes.map((size) =>\n            Math.max(minColumnWidth ?? 0, Math.floor(size * factor))\n          );\n        }\n      }\n\n      editor.tf.setNodes<TTableElement>(\n        {\n          colSizes: newColSizes,\n        },\n        {\n          at: tablePath,\n        }\n      );\n    }\n  });\n};\n","import type { NodeEntry, SlateEditor } from '@udecode/plate';\n\nimport type {\n  TTableCellElement,\n  TTableElement,\n  TTableRowElement,\n} from '../types';\n\nimport { getCellIndices } from '../utils/getCellIndices';\n\nexport const getCellPath = (\n  editor: SlateEditor,\n  tableEntry: NodeEntry<TTableElement>,\n  curRowIndex: number,\n  curColIndex: number\n) => {\n  const [tableNode, tablePath] = tableEntry;\n\n  const rowElem = tableNode.children[curRowIndex] as TTableRowElement;\n  const foundColIndex = rowElem.children.findIndex((c) => {\n    const cE = c as TTableCellElement;\n    const { col: colIndex } = getCellIndices(editor, cE);\n\n    return colIndex === curColIndex;\n  });\n\n  return tablePath.concat([curRowIndex, foundColIndex]);\n};\n","import {\n  type Path,\n  type SlateEditor,\n  type TElement,\n  getEditorPlugin,\n  NodeApi,\n  PathApi,\n} from '@udecode/plate';\n\nimport type { TTableElement } from '../types';\n\nimport {\n  BaseTableCellHeaderPlugin,\n  BaseTablePlugin,\n  BaseTableRowPlugin,\n} from '../BaseTablePlugin';\nimport { insertTableMergeRow } from '../merge/insertTableRow';\nimport { getCellTypes } from '../utils/index';\n\nexport const insertTableRow = (\n  editor: SlateEditor,\n  options: {\n    /**\n     * Exact path of the row to insert the column at. Pass the table path to\n     * insert at the end of the table. Will overrule `fromRow`.\n     */\n    at?: Path;\n    /** Insert the row before the current row instead of after */\n    before?: boolean;\n    fromRow?: Path;\n    header?: boolean;\n    select?: boolean;\n  } = {}\n) => {\n  const { api, getOptions, type } = getEditorPlugin(editor, BaseTablePlugin);\n\n  const { disableMerge } = getOptions();\n\n  if (!disableMerge) {\n    return insertTableMergeRow(editor, options);\n  }\n\n  const { before, header, select: shouldSelect } = options;\n  let { at, fromRow } = options;\n\n  if (at && !fromRow) {\n    const table = NodeApi.get<TTableElement>(editor, at);\n\n    if (table?.type === editor.getType(BaseTablePlugin)) {\n      fromRow = NodeApi.lastChild(editor, at)![1];\n      at = undefined;\n    }\n  }\n\n  const trEntry = editor.api.block({\n    at: fromRow,\n    match: { type: editor.getType(BaseTableRowPlugin) },\n  });\n\n  if (!trEntry) return;\n\n  const [trNode, trPath] = trEntry;\n\n  const tableEntry = editor.api.block({\n    above: true,\n    at: trPath,\n    match: { type },\n  });\n\n  if (!tableEntry) return;\n\n  const getEmptyRowNode = () => ({\n    children: (trNode.children as TElement[]).map((_, i) => {\n      const hasSingleRow = tableEntry[0].children.length === 1;\n      const isHeaderColumn =\n        !hasSingleRow &&\n        (tableEntry[0].children as TElement[]).every(\n          (n) =>\n            n.children[i].type === editor.getType(BaseTableCellHeaderPlugin)\n        );\n\n      return api.create.tableCell({\n        header: header ?? isHeaderColumn,\n      });\n    }),\n    type: editor.getType(BaseTableRowPlugin),\n  });\n\n  editor.tf.withoutNormalizing(() => {\n    editor.tf.insertNodes(getEmptyRowNode(), {\n      at: PathApi.isPath(at) ? at : before ? trPath : PathApi.next(trPath),\n    });\n  });\n\n  if (shouldSelect) {\n    const cellEntry = editor.api.block({\n      match: { type: getCellTypes(editor) },\n    });\n\n    if (!cellEntry) return;\n\n    const [, nextCellPath] = cellEntry;\n\n    if (PathApi.isPath(at)) {\n      nextCellPath[nextCellPath.length - 2] = at.at(-2)!;\n    } else {\n      nextCellPath[nextCellPath.length - 2] = before\n        ? nextCellPath.at(-2)!\n        : nextCellPath.at(-2)! + 1;\n    }\n\n    editor.tf.select(nextCellPath);\n  }\n};\n","import {\n  type Path,\n  type SlateEditor,\n  getEditorPlugin,\n  NodeApi,\n  PathApi,\n} from '@udecode/plate';\nimport cloneDeep from 'lodash/cloneDeep.js';\n\nimport type {\n  TTableCellElement,\n  TTableElement,\n  TTableRowElement,\n} from '../types';\n\nimport { BaseTablePlugin, BaseTableRowPlugin } from '../BaseTablePlugin';\nimport { getTableColumnCount } from '../queries';\nimport { getCellTypes } from '../utils';\nimport { getCellIndices } from '../utils/getCellIndices';\nimport { findCellByIndexes } from './findCellByIndexes';\nimport { getCellPath } from './getCellPath';\n\nexport const insertTableMergeRow = (\n  editor: SlateEditor,\n  {\n    at,\n    before,\n    fromRow,\n    header,\n    select: shouldSelect,\n  }: {\n    /** Exact path of the row to insert the column at. Will overrule `fromRow`. */\n    at?: Path;\n    /** Insert the row before the current row instead of after */\n    before?: boolean;\n    fromRow?: Path;\n    header?: boolean;\n    select?: boolean;\n  } = {}\n) => {\n  const { api, type } = getEditorPlugin(editor, BaseTablePlugin);\n\n  if (at && !fromRow) {\n    const table = NodeApi.get<TTableElement>(editor, at);\n\n    if (table?.type === editor.getType(BaseTablePlugin)) {\n      fromRow = NodeApi.lastChild(editor, at)![1];\n      at = undefined;\n    }\n  }\n\n  const trEntry = editor.api.block({\n    at: fromRow,\n    match: { type: editor.getType(BaseTableRowPlugin) },\n  });\n\n  if (!trEntry) return;\n\n  const [, trPath] = trEntry;\n\n  const tableEntry = editor.api.block<TTableElement>({\n    above: true,\n    at: trPath,\n    match: { type },\n  });\n\n  if (!tableEntry) return;\n\n  const tableNode = tableEntry[0] as TTableElement;\n\n  const cellEntry = editor.api.node({\n    at: fromRow,\n    match: { type: getCellTypes(editor) },\n  });\n\n  if (!cellEntry) return;\n\n  const [cellNode, cellPath] = cellEntry;\n  const cellElement = cellNode as TTableCellElement;\n  const cellRowSpan = api.table.getRowSpan(cellElement);\n  const { row: cellRowIndex } = getCellIndices(editor, cellElement);\n\n  const rowPath = cellPath.at(-2)!;\n  const tablePath = cellPath.slice(0, -2)!;\n\n  let nextRowIndex: number;\n  let checkingRowIndex: number;\n  let nextRowPath: number[];\n\n  if (PathApi.isPath(at)) {\n    nextRowIndex = at.at(-1)!;\n    checkingRowIndex = cellRowIndex - 1;\n    nextRowPath = at;\n  } else {\n    nextRowIndex = before ? cellRowIndex : cellRowIndex + cellRowSpan;\n    checkingRowIndex = before\n      ? cellRowIndex - 1\n      : cellRowIndex + cellRowSpan - 1;\n    nextRowPath = [...tablePath, before ? rowPath : rowPath + cellRowSpan];\n  }\n\n  const firstRow = nextRowIndex === 0;\n\n  if (firstRow) {\n    checkingRowIndex = 0;\n  }\n\n  const colCount = getTableColumnCount(tableNode);\n  const affectedCellsSet = new Set();\n  Array.from({ length: colCount }, (_, i) => i).forEach((cI) => {\n    const found = findCellByIndexes(editor, tableNode, checkingRowIndex, cI);\n\n    if (found) {\n      affectedCellsSet.add(found);\n    }\n  });\n  const affectedCells = Array.from(affectedCellsSet) as TTableCellElement[];\n\n  const newRowChildren: TTableCellElement[] = [];\n  affectedCells.forEach((cur) => {\n    if (!cur) return;\n\n    const curCell = cur as TTableCellElement;\n    const { col: curColIndex, row: curRowIndex } = getCellIndices(\n      editor,\n      curCell\n    );\n\n    const curRowSpan = api.table.getRowSpan(curCell);\n    const curColSpan = api.table.getColSpan(curCell);\n    const currentCellPath = getCellPath(\n      editor,\n      tableEntry,\n      curRowIndex,\n      curColIndex\n    );\n\n    const endCurI = curRowIndex + curRowSpan - 1;\n\n    if (endCurI >= nextRowIndex && !firstRow) {\n      const rowSpan = curRowSpan + 1;\n      const newCell = cloneDeep({ ...curCell, rowSpan });\n\n      if (newCell.attributes?.rowspan) {\n        newCell.attributes.rowspan = rowSpan.toString();\n      }\n\n      // make higher\n      editor.tf.setNodes<TTableCellElement>(newCell, { at: currentCellPath });\n    } else {\n      // add new\n      const row = editor.api.parent(currentCellPath)!;\n      const rowElement = row[0] as TTableRowElement;\n      const emptyCell = api.create.tableCell({ header, row: rowElement });\n\n      newRowChildren.push({\n        ...emptyCell,\n        colSpan: curColSpan,\n        rowSpan: 1,\n      });\n    }\n  });\n\n  editor.tf.withoutNormalizing(() => {\n    editor.tf.insertNodes(\n      {\n        children: newRowChildren,\n        type: editor.getType(BaseTableRowPlugin),\n      },\n      {\n        at: nextRowPath,\n        select: false,\n      }\n    );\n\n    if (shouldSelect) {\n      const cellEntry = editor.api.node({\n        at: nextRowPath,\n        match: { type: getCellTypes(editor) },\n      });\n\n      if (cellEntry) {\n        const [, nextCellPath] = cellEntry;\n        editor.tf.select(nextCellPath);\n      }\n    }\n  });\n};\n","import {\n  type Path,\n  type SetNodesOptions,\n  type SlateEditor,\n  ElementApi,\n} from '@udecode/plate';\n\nimport type { BorderDirection, BorderStyle, TTableCellElement } from '../types';\n\nimport { getLeftTableCell } from '../queries/getLeftTableCell';\nimport { getTopTableCell } from '../queries/getTopTableCell';\nimport { getCellTypes } from '../utils/index';\n\nexport const setBorderSize = (\n  editor: SlateEditor,\n  size: number,\n  {\n    at,\n    border = 'all',\n  }: {\n    at?: Path;\n    border?: BorderDirection | 'all';\n  } = {}\n) => {\n  const cellEntry = editor.api.node<TTableCellElement>({\n    at,\n    match: { type: getCellTypes(editor) },\n  });\n\n  if (!cellEntry) return;\n\n  const [cellNode, cellPath] = cellEntry;\n\n  const cellIndex = cellPath.at(-1);\n  const rowIndex = cellPath.at(-2);\n\n  // Default hidden border style\n  const borderStyle: BorderStyle = {\n    size,\n  };\n\n  const setNodesOptions: SetNodesOptions = {\n    match: (n) =>\n      ElementApi.isElement(n) && getCellTypes(editor).includes(n.type),\n  };\n\n  if (border === 'top') {\n    const isFirstRow = rowIndex === 0;\n\n    if (isFirstRow) {\n      const newBorders: TTableCellElement['borders'] = {\n        ...cellNode.borders,\n        top: borderStyle,\n      };\n\n      editor.tf.setNodes<TTableCellElement>(\n        { borders: newBorders },\n        {\n          at: cellPath,\n          ...setNodesOptions,\n        }\n      );\n\n      return;\n    }\n\n    const cellAboveEntry = getTopTableCell(editor, { at: cellPath });\n\n    if (!cellAboveEntry) return;\n\n    const [cellAboveNode, cellAbovePath] = cellAboveEntry;\n\n    const newBorders: TTableCellElement['borders'] = {\n      ...cellAboveNode.borders,\n      bottom: borderStyle,\n    };\n\n    // Update the bottom border of the cell above\n    editor.tf.setNodes<TTableCellElement>(\n      { borders: newBorders },\n      {\n        at: cellAbovePath,\n        ...setNodesOptions,\n      }\n    );\n  } else if (border === 'bottom') {\n    const newBorders: TTableCellElement['borders'] = {\n      ...cellNode.borders,\n      bottom: borderStyle,\n    };\n\n    // Update the bottom border of the current cell\n    editor.tf.setNodes<TTableCellElement>(\n      { borders: newBorders },\n      {\n        at: cellPath,\n        ...setNodesOptions,\n      }\n    );\n  }\n  if (border === 'left') {\n    const isFirstCell = cellIndex === 0;\n\n    if (isFirstCell) {\n      const newBorders: TTableCellElement['borders'] = {\n        ...cellNode.borders,\n        left: borderStyle,\n      };\n\n      editor.tf.setNodes<TTableCellElement>(\n        { borders: newBorders },\n        {\n          at: cellPath,\n          ...setNodesOptions,\n        }\n      );\n\n      return;\n    }\n\n    const prevCellEntry = getLeftTableCell(editor, { at: cellPath });\n\n    if (!prevCellEntry) return;\n\n    const [prevCellNode, prevCellPath] = prevCellEntry;\n\n    const newBorders: TTableCellElement['borders'] = {\n      ...prevCellNode.borders,\n      right: borderStyle,\n    };\n\n    // Update the bottom border of the cell above\n    editor.tf.setNodes<TTableCellElement>(\n      { borders: newBorders },\n      {\n        at: prevCellPath,\n        ...setNodesOptions,\n      }\n    );\n  } else if (border === 'right') {\n    const newBorders: TTableCellElement['borders'] = {\n      ...cellNode.borders,\n      right: borderStyle,\n    };\n\n    // Update the right border of the current cell\n    editor.tf.setNodes<TTableCellElement>(\n      { borders: newBorders },\n      {\n        at: cellPath,\n        ...setNodesOptions,\n      }\n    );\n  }\n  if (border === 'all') {\n    editor.tf.withoutNormalizing(() => {\n      setBorderSize(editor, size, { at, border: 'top' });\n      setBorderSize(editor, size, { at, border: 'bottom' });\n      setBorderSize(editor, size, { at, border: 'left' });\n      setBorderSize(editor, size, { at, border: 'right' });\n    });\n  }\n};\n","import type { EditorAboveOptions, SlateEditor } from '@udecode/plate';\n\nimport type { TTableElement } from '../types';\n\nimport { BaseTablePlugin } from '../BaseTablePlugin';\nimport { getTableColumnCount } from '../queries/getTableColumnCount';\n\nexport const setTableColSize = (\n  editor: SlateEditor,\n  { colIndex, width }: { colIndex: number; width: number },\n  options: EditorAboveOptions = {}\n) => {\n  const table = editor.api.node<TTableElement>({\n    match: { type: BaseTablePlugin.key },\n    ...options,\n  });\n\n  if (!table) return;\n\n  const [tableNode, tablePath] = table;\n\n  const colSizes = tableNode.colSizes\n    ? [...tableNode.colSizes]\n    : Array.from({ length: getTableColumnCount(tableNode) }).fill(0);\n\n  colSizes[colIndex] = width;\n\n  editor.tf.setNodes<TTableElement>({ colSizes }, { at: tablePath });\n};\n","import type { EditorAboveOptions, SlateEditor } from '@udecode/plate';\n\nimport type { TTableElement } from '../types';\n\nimport { BaseTablePlugin } from '../BaseTablePlugin';\n\nexport const setTableMarginLeft = (\n  editor: SlateEditor,\n  { marginLeft }: { marginLeft: number },\n  options: EditorAboveOptions = {}\n) => {\n  const table = editor.api.node<TTableElement>({\n    match: { type: BaseTablePlugin.key },\n    ...options,\n  });\n\n  if (!table) return;\n\n  const [, tablePath] = table;\n\n  editor.tf.setNodes<TTableElement>({ marginLeft }, { at: tablePath });\n};\n","import type { EditorAboveOptions, SlateEditor } from '@udecode/plate';\n\nimport type { TTableElement, TTableRowElement } from '../types';\n\nimport { BaseTablePlugin } from '../BaseTablePlugin';\n\nexport const setTableRowSize = (\n  editor: SlateEditor,\n  { height, rowIndex }: { height: number; rowIndex: number },\n  options: EditorAboveOptions = {}\n) => {\n  const table = editor.api.node<TTableElement>({\n    match: { type: BaseTablePlugin.key },\n    ...options,\n  });\n\n  if (!table) return;\n\n  const [, tablePath] = table;\n  const tableRowPath = [...tablePath, rowIndex];\n\n  editor.tf.setNodes<TTableRowElement>({ size: height }, { at: tableRowPath });\n};\n","import type { TElement } from '@udecode/plate';\n\nimport { getColSpan } from '../queries';\n\nexport const getTableMergedColumnCount = (tableNode: TElement) => {\n  return (tableNode.children as TElement[])?.[0]?.children?.reduce(\n    (prev, cur) => prev + (getColSpan(cur as any) ?? 1),\n    0\n  );\n};\n","import type {\n  TTableCellElement,\n  TTableElement,\n  TTableRowElement,\n} from '../types';\n\nimport { getColSpan } from '../queries';\nimport { getRowSpan } from '../queries/getRowSpan';\n\nconst allEqual = (arr: number[]) => arr.every((val) => val === arr[0]);\n\n/**\n * Checks if the given table is rectangular, meaning all rows have the same\n * effective number of cells, considering colspan and rowspan.\n */\nexport const isTableRectangular = (table?: TTableElement) => {\n  const arr: number[] = [];\n  table?.children?.forEach((row, rI) => {\n    const rowEl = row as TTableRowElement;\n\n    rowEl.children?.forEach((cell) => {\n      const cellElem = cell as TTableCellElement;\n\n      Array.from({\n        length: getRowSpan(cellElem) || 1,\n      } as ArrayLike<number>).forEach((_, i) => {\n        if (!arr[rI + i]) {\n          arr[rI + i] = 0;\n        }\n\n        arr[rI + i] += getColSpan(cellElem);\n      });\n    });\n  });\n\n  return allEqual(arr);\n};\n","import {\n  type Descendant,\n  type NodeEntry,\n  type SlateEditor,\n  getEditorPlugin,\n} from '@udecode/plate';\nimport cloneDeep from 'lodash/cloneDeep.js';\n\nimport { type TTableCellElement, getCellIndices } from '..';\nimport { BaseTableCellHeaderPlugin, BaseTablePlugin } from '../BaseTablePlugin';\nimport { getTableGridAbove } from '../queries';\n\n/** Merges multiple selected cells into one. */\nexport const mergeTableCells = (editor: SlateEditor) => {\n  const { api } = getEditorPlugin(editor, BaseTablePlugin);\n\n  const cellEntries = getTableGridAbove(editor, {\n    format: 'cell',\n  }) as NodeEntry<TTableCellElement>[];\n\n  editor.tf.withoutNormalizing(() => {\n    // calculate the colSpan which is the number of horizontal cells that a cell should span.\n    let colSpan = 0;\n\n    for (const entry of cellEntries) {\n      const [cell, path] = entry;\n\n      const rowIndex = path.at(-2)!;\n\n      // count only those cells that are in the first selected row.\n      if (rowIndex === cellEntries[0][1].at(-2)!) {\n        const cellColSpan = api.table.getColSpan(cell);\n        colSpan += cellColSpan;\n      }\n    }\n\n    // calculate the rowSpan which is the number of vertical cells that a cell should span.\n    let rowSpan = 0;\n    const { col } = getCellIndices(editor, cellEntries[0][0]);\n    cellEntries.forEach((entry) => {\n      const cell = entry[0];\n      const { col: curCol } = getCellIndices(editor, cell);\n\n      if (col === curCol) {\n        rowSpan += api.table.getRowSpan(cell);\n      }\n    });\n\n    // This will store the content of all cells we are merging\n    const mergingCellChildren: Descendant[] = [];\n\n    for (const cellEntry of cellEntries) {\n      const [el] = cellEntry;\n\n      const cellChildren = api.table.getCellChildren!(el);\n\n      if (\n        cellChildren.length !== 1 ||\n        !editor.api.isEmpty(cellChildren[0] as any)\n      ) {\n        mergingCellChildren.push(...cloneDeep(cellChildren));\n      }\n    }\n\n    // Create a hash map where keys are col paths,\n    // and values are an array of all paths with that column\n    const cols: Record<string, number[][]> = {};\n\n    cellEntries.forEach(([_entry, path]) => {\n      const rowIndex = path.at(-2)!;\n\n      if (cols[rowIndex]) {\n        cols[rowIndex].push(path);\n      } else {\n        cols[rowIndex] = [path];\n      }\n    });\n\n    // removes multiple cells with on same path.\n    // once cell removed, next cell in the row will settle down on that path\n    Object.values(cols).forEach((paths) => {\n      paths?.forEach(() => {\n        editor.tf.removeNodes({ at: paths[0] });\n      });\n    });\n\n    // Create a new cell to replace the merged cells, with\n    // calculated colSpan and rowSpan attributes and combined content\n    const mergedCell = {\n      ...api.create.tableCell({\n        children: mergingCellChildren,\n        header:\n          cellEntries[0][0].type === editor.getType(BaseTableCellHeaderPlugin),\n      }),\n      colSpan,\n      rowSpan,\n    };\n\n    // insert the new merged cell in place of the first cell in the selection\n    editor.tf.insertNodes(mergedCell, { at: cellEntries[0][1] });\n  });\n\n  editor.tf.select(editor.api.end(cellEntries[0][1])!);\n};\n","import {\n  type Descendant,\n  type Path,\n  type SlateEditor,\n  getEditorPlugin,\n} from '@udecode/plate';\n\nimport {\n  type TTableCellElement,\n  type TTableRowElement,\n  getCellIndices,\n} from '..';\nimport {\n  BaseTableCellHeaderPlugin,\n  BaseTablePlugin,\n  BaseTableRowPlugin,\n} from '../BaseTablePlugin';\nimport { getTableGridAbove } from '../queries';\n\nexport const splitTableCell = (editor: SlateEditor) => {\n  const { api } = getEditorPlugin(editor, BaseTablePlugin);\n  const tableRowType = editor.getType(BaseTableRowPlugin);\n\n  const cellEntries = getTableGridAbove(editor, { format: 'cell' });\n  const [[cellElem, path]] = cellEntries;\n\n  editor.tf.withoutNormalizing(() => {\n    // creating new object per iteration is essential here\n    const createEmptyCell = (children?: Descendant[]) => {\n      return {\n        ...api.create.tableCell({\n          children,\n          header: cellElem.type === editor.getType(BaseTableCellHeaderPlugin),\n        }),\n        colSpan: 1,\n        rowSpan: 1,\n      };\n    };\n\n    const tablePath = path.slice(0, -2);\n\n    const cellPath = path.slice(-2);\n    const [rowPath, colPath] = cellPath;\n    const colSpan = api.table.getColSpan(cellElem);\n    const rowSpan = api.table.getRowSpan(cellElem);\n\n    // Generate an array of column paths from the colspan\n    const colPaths: number[] = [];\n\n    for (let i = 0; i < colSpan; i++) {\n      colPaths.push(colPath + i);\n    }\n\n    const { col } = getCellIndices(editor, cellElem);\n\n    // Remove the original merged cell from the editor\n    editor.tf.removeNodes({ at: path });\n\n    const getClosestColPathForRow = (row: number, targetCol: number) => {\n      const rowEntry = editor.api.node({\n        at: [...tablePath, row],\n        match: { type: tableRowType },\n      });\n\n      if (!rowEntry) {\n        return 0;\n      }\n\n      const rowEl = rowEntry[0] as TTableRowElement;\n      let closestColPath: Path = [];\n      let smallestDiff = Number.POSITIVE_INFINITY;\n      let isDirectionLeft = false;\n\n      rowEl.children.forEach((cell) => {\n        const cellElement = cell as TTableCellElement;\n        const { col: cellCol } = getCellIndices(editor, cellElement);\n\n        const diff = Math.abs(cellCol - targetCol);\n\n        if (diff < smallestDiff) {\n          smallestDiff = diff;\n          closestColPath = editor.api.findPath(cellElement)!;\n          isDirectionLeft = cellCol < targetCol;\n        }\n      });\n\n      if (closestColPath.length > 0) {\n        const lastIndex = closestColPath.at(-1)!;\n\n        if (isDirectionLeft) {\n          return lastIndex + 1;\n        }\n\n        return lastIndex;\n      }\n\n      return 1;\n    };\n\n    // Generate an array of cell paths from the row and col spans and then insert empty cells at those paths\n    for (let i = 0; i < rowSpan; i++) {\n      const currentRowPath = rowPath + i;\n      const pathForNextRows = getClosestColPathForRow(currentRowPath, col);\n      const newRowChildren: TTableRowElement[] = [];\n      const _rowPath = [...tablePath, currentRowPath];\n      const rowEntry = editor.api.node({\n        at: _rowPath,\n        match: { type: tableRowType },\n      });\n\n      for (let j = 0; j < colPaths.length; j++) {\n        const cellChildren = api.table.getCellChildren!(cellElem);\n\n        const cellToInsert =\n          i === 0 && j === 0\n            ? createEmptyCell(cellChildren)\n            : createEmptyCell();\n\n        // if row exists, insert into it, otherwise insert row\n        if (rowEntry) {\n          const currentColPath = i === 0 ? colPaths[j] : pathForNextRows;\n          const pathForNewCell = [...tablePath, currentRowPath, currentColPath];\n\n          editor.tf.insertNodes(cellToInsert, { at: pathForNewCell });\n        } else {\n          newRowChildren.push(cellToInsert);\n        }\n      }\n\n      if (!rowEntry) {\n        editor.tf.insertNodes(\n          {\n            children: newRowChildren,\n            type: editor.getType(BaseTableRowPlugin),\n          },\n          { at: _rowPath }\n        );\n      }\n    }\n  });\n\n  editor.tf.select(editor.api.end(path)!);\n};\n","import type { KeyboardHandler } from '@udecode/plate/react';\n\nimport { type TElement, Hotkeys, isHotkey } from '@udecode/plate';\n\nimport {\n  type TableConfig,\n  getCellTypes,\n  getNextTableCell,\n  getPreviousTableCell,\n  getTableEntries,\n  KEY_SHIFT_EDGES,\n  moveSelectionFromCell,\n} from '../lib';\n\nexport const onKeyDownTable: KeyboardHandler<TableConfig> = ({\n  editor,\n  event,\n  type,\n}) => {\n  if (event.defaultPrevented) return;\n\n  const compositeKeyCode = 229;\n\n  if (\n    // This exception only occurs when IME composition is triggered, and can be identified by this keycode\n    event.which === compositeKeyCode &&\n    editor.selection &&\n    editor.api.isExpanded()\n  ) {\n    // fix the exception of inputting Chinese when selecting multiple cells\n    const tdEntries = Array.from(\n      editor.api.nodes({\n        at: editor.selection,\n        match: { type: getCellTypes(editor) },\n      })\n    );\n\n    if (tdEntries.length > 1) {\n      editor.tf.collapse({\n        edge: 'end',\n      });\n\n      return;\n    }\n  }\n\n  const isKeyDown: any = {\n    'shift+down': isHotkey('shift+down', event),\n    'shift+left': isHotkey('shift+left', event),\n    'shift+right': isHotkey('shift+right', event),\n    'shift+up': isHotkey('shift+up', event),\n  };\n\n  Object.keys(isKeyDown).forEach((key) => {\n    if (\n      isKeyDown[key] && // if many cells are selected\n      moveSelectionFromCell(editor, {\n        edge: (KEY_SHIFT_EDGES as any)[key],\n        reverse: key === 'shift+up',\n      })\n    ) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  });\n\n  const isTab = Hotkeys.isTab(editor, event);\n  const isUntab = Hotkeys.isUntab(editor, event);\n\n  if (isTab || isUntab) {\n    const entries = getTableEntries(editor);\n\n    if (!entries) return;\n\n    const { cell, row } = entries;\n    const [, cellPath] = cell;\n\n    if (isUntab) {\n      // move left with shift+tab\n      const previousCell = getPreviousTableCell(editor, cell, cellPath, row);\n\n      if (previousCell) {\n        const [, previousCellPath] = previousCell;\n        editor.tf.select(previousCellPath);\n      }\n    } else if (isTab) {\n      // move right with tab\n      const nextCell = getNextTableCell(editor, cell, cellPath, row);\n\n      if (nextCell) {\n        const [, nextCellPath] = nextCell;\n        editor.tf.select(nextCellPath);\n      }\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n  }\n  if (isHotkey('mod+a', event)) {\n    const res = editor.api.above<TElement>({ match: { type } });\n\n    if (!res) return;\n\n    const [, tablePath] = res;\n\n    // select the whole table\n    editor.tf.select(tablePath);\n\n    event.preventDefault();\n    event.stopPropagation();\n  }\n};\n","import type { SlateEditor, TElement } from '@udecode/plate';\n\nimport {\n  type BorderDirection,\n  type TTableCellElement,\n  getCellIndices,\n  getCellTypes,\n  getColSpan,\n  getLeftTableCell,\n  getRowSpan,\n  getSelectedCellsBorders,\n  getSelectedCellsBoundingBox,\n  getTopTableCell,\n  isSelectedCellBorder,\n  setBorderSize,\n} from '../../../lib';\n\n/** Helper: sets one cell's specific border(s) to `size`. */\nfunction setCellBorderSize(\n  editor: SlateEditor,\n  cell: TElement,\n  directions: BorderDirection[] | 'all',\n  size: number\n) {\n  const at = editor.api.findPath(cell);\n\n  if (!at) return;\n  if (directions === 'all') {\n    setBorderSize(editor, size, { at, border: 'all' });\n  } else {\n    for (const dir of directions) {\n      setBorderSize(editor, size, { at, border: dir });\n    }\n  }\n}\n\n/**\n * Toggle logic for `'none'`, `'outer'`, `'top'|'bottom'|'left'|'right'`.\n * `'none'` toggles no borders ↔ all borders, `'outer'` toggles the bounding\n * rectangle's outer edges on/off, `'top'|'bottom'|'left'|'right'` toggles only\n * that side of the bounding rect.\n */\nexport function setSelectedCellsBorder(\n  editor: SlateEditor,\n  {\n    border,\n    cells,\n  }: {\n    border: BorderDirection | 'none' | 'outer';\n    cells: TTableCellElement[];\n  }\n) {\n  if (cells.length === 0) return;\n  // 1) none => toggle all edges vs none\n  if (border === 'none') {\n    const { none: allNone } = getSelectedCellsBorders(editor, cells);\n    const newSize = allNone ? 1 : 0;\n\n    for (const cell of cells) {\n      const cellPath = editor.api.findPath(cell);\n\n      if (!cellPath) continue;\n\n      const { col, row } = getCellIndices(editor, cell);\n      const edges: BorderDirection[] = [];\n\n      // For first row or first column cells, we set their top/left borders\n      if (row === 0) edges.push('top');\n      if (col === 0) edges.push('left');\n\n      // Always set bottom and right borders\n      edges.push('bottom', 'right');\n\n      // For non-first row/column cells, set borders on adjacent cells\n      if (row > 0) {\n        const cellAboveEntry = getTopTableCell(editor, { at: cellPath });\n\n        if (cellAboveEntry) {\n          const [cellAbove] = cellAboveEntry;\n          setCellBorderSize(editor, cellAbove, ['bottom'], newSize);\n        }\n      }\n      if (col > 0) {\n        const prevCellEntry = getLeftTableCell(editor, { at: cellPath });\n\n        if (prevCellEntry) {\n          const [prevCell] = prevCellEntry;\n          setCellBorderSize(editor, prevCell, ['right'], newSize);\n        }\n      }\n      if (edges.length > 0) {\n        setCellBorderSize(editor, cell, edges, newSize);\n      }\n    }\n\n    return;\n  }\n  // 2) outer => bounding rectangle edges only\n  if (border === 'outer') {\n    const { outer: allOut } = getSelectedCellsBorders(editor, cells);\n    const newSize = allOut ? 0 : 1;\n\n    const { maxCol, maxRow, minCol, minRow } = getSelectedCellsBoundingBox(\n      editor,\n      cells\n    );\n\n    for (const cell of cells) {\n      const { col, row } = getCellIndices(editor, cell);\n      const cSpan = getColSpan(cell);\n      const rSpan = getRowSpan(cell);\n\n      for (let rr = row; rr < row + rSpan; rr++) {\n        for (let cc = col; cc < col + cSpan; cc++) {\n          const edges: BorderDirection[] = [];\n\n          if (rr === minRow) edges.push('top');\n          if (rr === maxRow) edges.push('bottom');\n          if (cc === minCol) edges.push('left');\n          if (cc === maxCol) edges.push('right');\n          if (edges.length > 0) {\n            setCellBorderSize(editor, cell, edges, newSize);\n          }\n        }\n      }\n    }\n\n    return;\n  }\n\n  // 3) single side => bounding rectangle but only that side\n  const allSet = isSelectedCellBorder(editor, cells, border);\n  const newSize = allSet ? 0 : 1;\n\n  // bounding box\n  const { maxCol, maxRow, minCol, minRow } = getSelectedCellsBoundingBox(\n    editor,\n    cells\n  );\n\n  for (const cell of cells) {\n    const { col, row } = getCellIndices(editor, cell);\n    const cSpan = getColSpan(cell);\n    const rSpan = getRowSpan(cell);\n    const cellPath = editor.api.findPath(cell);\n\n    if (!cellPath) continue;\n\n    const edges: BorderDirection[] = [];\n\n    if (border === 'top' && row === minRow) {\n      const isFirstRow = row === 0;\n\n      if (isFirstRow) {\n        edges.push('top');\n      } else {\n        const cellAboveEntry = getTopTableCell(editor, { at: cellPath });\n\n        if (cellAboveEntry) {\n          const [cellAbove] = cellAboveEntry;\n          setCellBorderSize(editor, cellAbove, ['bottom'], newSize);\n        }\n      }\n    }\n    if (border === 'bottom' && row + rSpan - 1 === maxRow) {\n      edges.push('bottom');\n    }\n    if (border === 'left' && col === minCol) {\n      const isFirstCell = col === 0;\n\n      if (isFirstCell) {\n        edges.push('left');\n      } else {\n        const prevCellEntry = getLeftTableCell(editor, { at: cellPath });\n\n        if (prevCellEntry) {\n          const [prevCell] = prevCellEntry;\n          setCellBorderSize(editor, prevCell, ['right'], newSize);\n        }\n      }\n    }\n    if (border === 'right' && col + cSpan - 1 === maxCol) {\n      edges.push('right');\n    }\n    if (edges.length > 0) {\n      setCellBorderSize(editor, cell, edges, newSize);\n    }\n  }\n}\n\n/**\n * Returns a function that sets borders on the selection with toggling logic. If\n * selection has one or many cells, it's the same approach: we read the bounding\n * rectangle, then decide which edges to flip on/off.\n */\nexport const getOnSelectTableBorderFactory =\n  (editor: SlateEditor, selectedCells: TElement[] | null) =>\n  (border: BorderDirection | 'none' | 'outer') =>\n  () => {\n    if (!selectedCells || selectedCells.length === 0) {\n      const cell = editor.api.block({ match: { type: getCellTypes(editor) } });\n\n      if (cell) {\n        selectedCells = [cell[0]];\n      } else {\n        return;\n      }\n    }\n\n    // Convert them to TTableCellElement\n    const cellElems = selectedCells.map((v) => v as TTableCellElement);\n    setSelectedCellsBorder(editor, { border, cells: cellElems });\n  };\n","/**\n * Rounds a cell size to the nearest step, or returns the size if the step is\n * not set.\n */\nexport const roundCellSizeToStep = (size: number, step?: number) => {\n  return step ? Math.round(size / step) * step : size;\n};\n","import type { TElement } from '@udecode/plate';\n\nimport { usePluginOption } from '@udecode/plate/react';\n\nimport { TablePlugin } from '../../TablePlugin';\n\nexport const useIsCellSelected = (element: TElement) => {\n  const selectedCells = usePluginOption(TablePlugin, 'selectedCells');\n\n  return !!selectedCells?.includes(element);\n};\n","import {\n  useEditorPlugin,\n  useEditorSelector,\n  useElement,\n  usePluginOption,\n} from '@udecode/plate/react';\n\nimport type { TTableElement } from '../../../lib';\n\nimport {\n  type TableBorderStates,\n  getSelectedCellsBorders,\n} from '../../../lib/queries/getSelectedCellsBorders';\nimport { TablePlugin } from '../../TablePlugin';\nimport { getOnSelectTableBorderFactory } from './getOnSelectTableBorderFactory';\n\nexport const useTableBordersDropdownMenuContentState = ({\n  element: el,\n}: {\n  element?: TTableElement;\n} = {}) => {\n  const { editor } = useEditorPlugin(TablePlugin);\n  const element = useElement() ?? el;\n  const selectedCells = usePluginOption(TablePlugin, 'selectedCells');\n  const borderStates = useEditorSelector<TableBorderStates>(\n    (editor) => getSelectedCellsBorders(editor, selectedCells),\n    [selectedCells, element]\n  );\n\n  return {\n    getOnSelectTableBorder: getOnSelectTableBorderFactory(\n      editor,\n      selectedCells\n    ),\n    hasBottomBorder: borderStates.bottom,\n    hasLeftBorder: borderStates.left,\n    hasNoBorders: borderStates.none,\n    hasOuterBorders: borderStates.outer,\n    hasRightBorder: borderStates.right,\n    hasTopBorder: borderStates.top,\n  };\n};\n","import React from 'react';\n\nimport { useEditorPlugin, useElement } from '@udecode/plate/react';\n\nimport { type TTableCellElement, getTableCellBorders } from '../../../lib';\nimport { useCellIndices } from '../../hooks/useCellIndices';\nimport { TablePlugin } from '../../TablePlugin';\n\nexport function useTableCellBorders({\n  element: el,\n}: {\n  element?: TTableCellElement;\n} = {}) {\n  const { editor } = useEditorPlugin(TablePlugin);\n  const element = useElement<TTableCellElement>() ?? el;\n  const cellIndices = useCellIndices();\n\n  return React.useMemo(() => {\n    return getTableCellBorders(editor, { cellIndices, element });\n  }, [editor, element, cellIndices]);\n}\n","import React from 'react';\n\nimport {\n  useEditorPlugin,\n  useElement,\n  usePluginOption,\n} from '@udecode/plate/react';\n\nimport { type TTableCellElement, computeCellIndices } from '../../lib';\nimport { TablePlugin } from '../TablePlugin';\n\nexport const useCellIndices = () => {\n  const { editor } = useEditorPlugin(TablePlugin);\n  const element = useElement<TTableCellElement>();\n  const cellIndices = usePluginOption(TablePlugin, 'cellIndices', element.id!);\n\n  return React.useMemo(() => {\n    if (!cellIndices) {\n      return (\n        computeCellIndices(editor, {\n          cellNode: element,\n        }) ?? { col: 0, row: 0 }\n      );\n    }\n\n    return cellIndices ?? { col: 0, row: 0 };\n  }, [cellIndices, editor, element]);\n};\n","import React from 'react';\n\nimport {\n  useEditorPlugin,\n  useElement,\n  usePluginOption,\n} from '@udecode/plate/react';\n\nimport type { BorderStylesDefault, TTableCellElement } from '../../../lib';\n\nimport { useCellIndices } from '../../hooks/useCellIndices';\nimport { useTableValue } from '../../stores';\nimport { TablePlugin } from '../../TablePlugin';\nimport { useIsCellSelected } from './useIsCellSelected';\nimport { useTableCellBorders } from './useTableCellBorders';\nimport { useTableCellSize } from './useTableCellSize';\n\nexport type TableCellElementState = {\n  borders: BorderStylesDefault;\n  colIndex: number;\n  colSpan: number;\n  isSelectingCell: boolean;\n  minHeight: number | undefined;\n  rowIndex: number;\n  selected: boolean;\n  width: number | string;\n};\n\nexport const useTableCellElement = (): TableCellElementState => {\n  const { api, setOption } = useEditorPlugin(TablePlugin);\n  const element = useElement<TTableCellElement>();\n  const isCellSelected = useIsCellSelected(element);\n  const selectedCells = usePluginOption(TablePlugin, 'selectedCells');\n\n  // Sync element transforms with selected cells\n  React.useEffect(() => {\n    if (selectedCells?.some((v) => v.id === element.id && element !== v)) {\n      setOption(\n        'selectedCells',\n        selectedCells.map((v) => (v.id === element.id ? element : v))\n      );\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [element]);\n\n  const rowSizeOverrides = useTableValue('rowSizeOverrides');\n  const { minHeight, width } = useTableCellSize({ element });\n  const borders = useTableCellBorders({ element });\n\n  /**\n   * Row size: if rowSpan > 1, we might look up the rowSize for the bottom row\n   * or you can do something simpler if row-spanning is unusual in your app.\n   */\n  const { col, row } = useCellIndices();\n  const colSpan = api.table.getColSpan(element);\n  const rowSpan = api.table.getRowSpan(element);\n  const endingRowIndex = row + rowSpan - 1;\n  const endingColIndex = col + colSpan - 1;\n\n  return {\n    borders,\n    colIndex: endingColIndex,\n    colSpan,\n    isSelectingCell: !!selectedCells,\n    minHeight: rowSizeOverrides.get?.(endingRowIndex) ?? minHeight,\n    rowIndex: endingRowIndex,\n    selected: isCellSelected,\n    width,\n  };\n};\n","import React from 'react';\n\nimport { atom, createAtomStore } from '@udecode/plate/react';\n\nimport type { TableStoreSizeOverrides } from '../../lib';\n\nexport const {\n  TableProvider,\n  tableStore,\n  useTableSet,\n  useTableState,\n  useTableStore,\n  useTableValue,\n} = createAtomStore(\n  {\n    colSizeOverrides: atom(new Map() as TableStoreSizeOverrides),\n    marginLeftOverride: null as number | null,\n    rowSizeOverrides: atom(new Map() as TableStoreSizeOverrides),\n  },\n  { name: 'table' as const }\n);\n\nconst useOverrideSizeFactory = (\n  setOverrides: (\n    fn: (overrides: TableStoreSizeOverrides) => TableStoreSizeOverrides\n  ) => void\n) =>\n  React.useCallback(\n    (index: number, size: number | null) => {\n      setOverrides((overrides) => {\n        const newOverrides = new Map(overrides);\n\n        if (size === null) {\n          newOverrides.delete(index);\n        } else {\n          newOverrides.set(index, size);\n        }\n\n        return newOverrides;\n      });\n    },\n    [setOverrides]\n  );\n\nexport const useOverrideColSize = () => {\n  const setColSizeOverrides = useTableSet('colSizeOverrides');\n\n  return useOverrideSizeFactory(setColSizeOverrides);\n};\n\nexport const useOverrideRowSize = () => {\n  const setRowSizeOverrides = useTableSet('rowSizeOverrides');\n\n  return useOverrideSizeFactory(setRowSizeOverrides);\n};\n\nexport const useOverrideMarginLeft = () => useTableSet('marginLeftOverride');\n","import React from 'react';\n\nimport type { NodeEntry } from '@udecode/plate';\n\nimport {\n  useEditorPlugin,\n  useElement,\n  useElementSelector,\n} from '@udecode/plate/react';\n\nimport type { TTableCellElement, TTableRowElement } from '../../../lib';\n\nimport { useCellIndices } from '../../hooks/useCellIndices';\nimport { TablePlugin, TableRowPlugin } from '../../TablePlugin';\nimport { useTableColSizes } from '../TableElement';\n\nexport function useTableCellSize({\n  element: el,\n}: {\n  element?: TTableCellElement;\n} = {}) {\n  const { api } = useEditorPlugin(TablePlugin);\n\n  const element = useElement() ?? el;\n  const colSizes = useTableColSizes();\n  const cellIndices = useCellIndices();\n  const rowSize = useElementSelector(\n    ([node]: NodeEntry<TTableRowElement>) => node.size,\n    [],\n    {\n      key: TableRowPlugin.key,\n    }\n  );\n\n  return React.useMemo(\n    () => api.table.getCellSize({ cellIndices, colSizes, element, rowSize }),\n    [api.table, cellIndices, colSizes, element, rowSize]\n  );\n}\n","import React from 'react';\n\nimport {\n  useEditorPlugin,\n  useEditorRef,\n  usePluginOption,\n  useReadOnly,\n  useSelected,\n} from '@udecode/plate/react';\n\nimport { getTableGridAbove } from '../../../lib';\nimport { TablePlugin } from '../../TablePlugin';\n\n/**\n * Many grid cells above and diff -> set No many grid cells above and diff ->\n * unset No selection -> unset\n */\nexport const useSelectedCells = () => {\n  const readOnly = useReadOnly();\n  const selected = useSelected();\n  const editor = useEditorRef();\n\n  const { setOption } = useEditorPlugin(TablePlugin);\n  const selectedCells = usePluginOption(TablePlugin, 'selectedCells');\n\n  React.useEffect(() => {\n    if (!selected || readOnly) {\n      setOption('selectedCells', null);\n      setOption('selectedTables', null);\n    }\n  }, [selected, editor, readOnly, setOption]);\n\n  React.useEffect(() => {\n    if (readOnly) return;\n\n    const tableEntries = getTableGridAbove(editor, { format: 'table' });\n    const cellEntries = getTableGridAbove(editor, { format: 'cell' });\n\n    if (cellEntries?.length > 1) {\n      const cells = cellEntries.map((entry) => entry[0]);\n      const tables = tableEntries.map((entry) => entry[0]);\n\n      if (JSON.stringify(cells) !== JSON.stringify(selectedCells)) {\n        setOption('selectedCells', cells);\n        setOption('selectedTables', tables);\n      }\n    } else if (selectedCells) {\n      setOption('selectedCells', null);\n      setOption('selectedTables', null);\n    }\n  }, [editor, editor.selection, readOnly, selectedCells, setOption]);\n};\n","import { PathApi } from '@udecode/plate';\nimport { useElementSelector } from '@udecode/plate/react';\n\nimport { getTableOverriddenColSizes } from '../../../lib';\nimport { useTableValue } from '../../stores';\nimport { TablePlugin } from '../../TablePlugin';\n\n/**\n * Returns colSizes with overrides applied. Unset node.colSizes if `colCount`\n * updates to 1.\n */\nexport const useTableColSizes = ({\n  disableOverrides = false,\n  transformColSizes,\n}: {\n  disableOverrides?: boolean;\n  transformColSizes?: (colSizes: number[]) => number[];\n} = {}): number[] => {\n  const colSizeOverrides = useTableValue('colSizeOverrides');\n\n  const overriddenColSizes = useElementSelector(\n    ([tableNode]) => {\n      const colSizes = getTableOverriddenColSizes(\n        tableNode,\n        disableOverrides ? undefined : colSizeOverrides\n      );\n\n      if (transformColSizes) {\n        return transformColSizes(colSizes);\n      }\n\n      return colSizes;\n    },\n    [disableOverrides, colSizeOverrides, transformColSizes],\n    {\n      key: TablePlugin.key,\n      equalityFn: (a, b) => !!a && !!b && PathApi.equals(a, b),\n    }\n  );\n\n  return overriddenColSizes;\n};\n","import {\n  useEditorPlugin,\n  useElement,\n  usePluginOption,\n} from '@udecode/plate/react';\n\nimport type { TTableElement } from '../../../lib';\n\nimport { useTableValue } from '../../stores';\nimport { TablePlugin } from '../../TablePlugin';\nimport { useSelectedCells } from './useSelectedCells';\n\nexport const useTableElement = () => {\n  const { editor, getOptions } = useEditorPlugin(TablePlugin);\n\n  const { disableMarginLeft } = getOptions();\n\n  const element = useElement<TTableElement>();\n  const selectedCells = usePluginOption(TablePlugin, 'selectedCells');\n  const marginLeftOverride = useTableValue('marginLeftOverride');\n\n  const marginLeft = disableMarginLeft\n    ? 0\n    : (marginLeftOverride ?? element.marginLeft ?? 0);\n\n  useSelectedCells();\n\n  return {\n    isSelectingCell: !!selectedCells,\n    marginLeft,\n    props: {\n      onMouseDown: () => {\n        // until cell dnd is supported, we collapse the selection on mouse down\n        if (selectedCells) {\n          editor.tf.collapse();\n        }\n      },\n    },\n  };\n};\n","import React from 'react';\n\nimport {\n  type ResizeEvent,\n  type ResizeHandle,\n  resizeLengthClampStatic,\n} from '@udecode/plate-resizable';\nimport {\n  useEditorPlugin,\n  useElement,\n  useElementSelector,\n} from '@udecode/plate/react';\n\nimport type { TableCellElementState } from './useTableCellElement';\n\nimport {\n  type TTableElement,\n  setTableColSize,\n  setTableMarginLeft,\n  setTableRowSize,\n} from '../../../lib';\nimport {\n  useOverrideColSize,\n  useOverrideMarginLeft,\n  useOverrideRowSize,\n} from '../../stores';\nimport { TablePlugin } from '../../TablePlugin';\nimport { useTableColSizes } from '../TableElement/useTableColSizes';\nimport { roundCellSizeToStep } from './roundCellSizeToStep';\n\nexport type TableCellElementResizableOptions = {\n  /** Resize by step instead of by pixel. */\n  step?: number;\n  /** Overrides for X and Y axes. */\n  stepX?: number;\n  stepY?: number;\n} & Pick<TableCellElementState, 'colIndex' | 'colSpan' | 'rowIndex'>;\n\nexport const useTableCellElementResizable = ({\n  colIndex,\n  colSpan,\n  rowIndex,\n  step,\n  stepX = step,\n  stepY = step,\n}: TableCellElementResizableOptions): {\n  bottomProps: React.ComponentPropsWithoutRef<typeof ResizeHandle>;\n  hiddenLeft: boolean;\n  leftProps: React.ComponentPropsWithoutRef<typeof ResizeHandle>;\n  rightProps: React.ComponentPropsWithoutRef<typeof ResizeHandle>;\n} => {\n  const { editor, getOptions } = useEditorPlugin(TablePlugin);\n  const element = useElement();\n  const { disableMarginLeft, minColumnWidth = 0 } = getOptions();\n\n  const initialWidth = useElementSelector(\n    ([node]) =>\n      colSpan > 1 ? (node as TTableElement).colSizes?.[colIndex] : undefined,\n    [colSpan, colIndex],\n    { key: TablePlugin.key }\n  );\n  const marginLeft = useElementSelector(\n    ([node]) => (node as TTableElement).marginLeft ?? 0,\n    [],\n    { key: TablePlugin.key }\n  );\n\n  const colSizesWithoutOverrides = useTableColSizes({ disableOverrides: true });\n  const colSizesWithoutOverridesRef = React.useRef(colSizesWithoutOverrides);\n  React.useEffect(() => {\n    colSizesWithoutOverridesRef.current = colSizesWithoutOverrides;\n  }, [colSizesWithoutOverrides]);\n\n  const overrideColSize = useOverrideColSize();\n  const overrideRowSize = useOverrideRowSize();\n  const overrideMarginLeft = useOverrideMarginLeft();\n\n  const setColSize = React.useCallback(\n    (colIndex: number, width: number) => {\n      setTableColSize(editor, { colIndex, width }, { at: element });\n\n      // Prevent flickering\n      setTimeout(() => overrideColSize(colIndex, null), 0);\n    },\n    [editor, element, overrideColSize]\n  );\n\n  const setRowSize = React.useCallback(\n    (rowIndex: number, height: number) => {\n      setTableRowSize(editor, { height, rowIndex }, { at: element });\n\n      // Prevent flickering\n      setTimeout(() => overrideRowSize(rowIndex, null), 0);\n    },\n    [editor, element, overrideRowSize]\n  );\n\n  const setMarginLeft = React.useCallback(\n    (marginLeft: number) => {\n      setTableMarginLeft(editor, { marginLeft }, { at: element });\n\n      // Prevent flickering\n      setTimeout(() => overrideMarginLeft(null), 0);\n    },\n    [editor, element, overrideMarginLeft]\n  );\n\n  const handleResizeRight = React.useCallback(\n    ({ delta, finished, initialSize: currentInitial }: ResizeEvent) => {\n      const nextInitial = colSizesWithoutOverridesRef.current[colIndex + 1];\n\n      const complement = (width: number) =>\n        currentInitial + nextInitial - width;\n\n      const currentNew = roundCellSizeToStep(\n        resizeLengthClampStatic(currentInitial + delta, {\n          max: nextInitial ? complement(minColumnWidth) : undefined,\n          min: minColumnWidth,\n        }),\n        stepX\n      );\n\n      const nextNew = nextInitial ? complement(currentNew) : undefined;\n\n      const fn = finished ? setColSize : overrideColSize;\n      fn(colIndex, currentNew);\n\n      if (nextNew) fn(colIndex + 1, nextNew);\n    },\n    [colIndex, minColumnWidth, overrideColSize, setColSize, stepX]\n  );\n\n  const handleResizeBottom = React.useCallback(\n    (event: ResizeEvent) => {\n      const newHeight = roundCellSizeToStep(\n        event.initialSize + event.delta,\n        stepY\n      );\n\n      if (event.finished) {\n        setRowSize(rowIndex, newHeight);\n      } else {\n        overrideRowSize(rowIndex, newHeight);\n      }\n    },\n    [overrideRowSize, rowIndex, setRowSize, stepY]\n  );\n\n  const handleResizeLeft = React.useCallback(\n    (event: ResizeEvent) => {\n      const initial = colSizesWithoutOverridesRef.current[colIndex];\n\n      const complement = (width: number) => initial + marginLeft - width;\n\n      const newMargin = roundCellSizeToStep(\n        resizeLengthClampStatic(marginLeft + event.delta, {\n          max: complement(minColumnWidth),\n          min: 0,\n        }),\n        stepX\n      );\n\n      const newWidth = complement(newMargin);\n\n      if (event.finished) {\n        setMarginLeft(newMargin);\n        setColSize(colIndex, newWidth);\n      } else {\n        overrideMarginLeft(newMargin);\n        overrideColSize(colIndex, newWidth);\n      }\n    },\n    [\n      colIndex,\n      marginLeft,\n      minColumnWidth,\n      overrideColSize,\n      overrideMarginLeft,\n      setColSize,\n      setMarginLeft,\n      stepX,\n    ]\n  );\n\n  const hasLeftHandle = colIndex === 0 && !disableMarginLeft;\n\n  return {\n    bottomProps: React.useMemo(\n      () => ({\n        options: {\n          direction: 'bottom',\n          onResize: handleResizeBottom,\n        },\n      }),\n      [handleResizeBottom]\n    ),\n    hiddenLeft: !hasLeftHandle,\n    leftProps: React.useMemo(\n      () => ({\n        options: {\n          direction: 'left',\n          onResize: handleResizeLeft,\n        },\n      }),\n      [handleResizeLeft]\n    ),\n    rightProps: React.useMemo(\n      () => ({\n        options: {\n          direction: 'right',\n          initialSize: initialWidth,\n          onResize: handleResizeRight,\n        },\n      }),\n      [initialWidth, handleResizeRight]\n    ),\n  };\n};\n","/* eslint-disable react-hooks/rules-of-hooks */\nimport {\n  useEditorPlugin,\n  useEditorSelector,\n  usePluginOption,\n  useReadOnly,\n} from '@udecode/plate/react';\n\nimport {\n  type TTableCellElement,\n  getTableGridAbove,\n  isTableRectangular,\n} from '../../lib';\nimport { TablePlugin } from '../TablePlugin';\n\nexport const useTableMergeState = () => {\n  const { api, getOptions } = useEditorPlugin(TablePlugin);\n\n  const { disableMerge } = getOptions();\n\n  if (disableMerge) return { canMerge: false, canSplit: false };\n\n  const readOnly = useReadOnly();\n  const someTable = useEditorSelector(\n    (editor) => editor.api.some({ match: { type: TablePlugin.key } }),\n    []\n  );\n  const selectionExpanded = useEditorSelector(\n    (editor) => editor.api.isExpanded(),\n    []\n  );\n\n  const collapsed = !readOnly && someTable && !selectionExpanded;\n  const selectedTables = usePluginOption(TablePlugin, 'selectedTables');\n  const selectedTable = selectedTables?.[0];\n\n  const selectedCellEntries = useEditorSelector(\n    (editor) =>\n      getTableGridAbove(editor, {\n        format: 'cell',\n      }),\n    []\n  );\n\n  if (!selectedCellEntries) return { canMerge: false, canSplit: false };\n\n  const canMerge =\n    !readOnly &&\n    someTable &&\n    selectionExpanded &&\n    selectedCellEntries.length > 1 &&\n    isTableRectangular(selectedTable);\n\n  const canSplit =\n    collapsed &&\n    selectedCellEntries.length === 1 &&\n    (api.table.getColSpan(selectedCellEntries[0][0] as TTableCellElement) > 1 ||\n      api.table.getRowSpan(selectedCellEntries[0][0] as TTableCellElement) > 1);\n\n  return { canMerge, canSplit };\n};\n"],"mappings":"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","names":["getEditorPlugin","cloneDeep","getEditorPlugin","getEditorPlugin","NodeApi","getEditorPlugin","getEditorPlugin","NodeApi","NodeApi","NodeApi","PathApi","PathApi","PathApi","PathApi","PathApi","PathApi","PathApi","PathApi","PathApi","PathApi","getEditorPlugin","getEditorPlugin","TextApi","TextApi","getEditorPlugin","NodeApi","RangeApi","RangeApi","NodeApi","getEditorPlugin","getEditorPlugin","getEditorPlugin","cloneDeep","getEditorPlugin","getEditorPlugin","getEditorPlugin","startingCell","startingCellPath","tablePath","colPath","nextRowStartCellPath","rowsNumberAffected","rowSpan","newCell","cloneDeep","getEditorPlugin","PathApi","PathApi","getEditorPlugin","NodeApi","PathApi","getEditorPlugin","NodeApi","PathApi","cloneDeep","getEditorPlugin","NodeApi","PathApi","cloneDeep","getEditorPlugin","NodeApi","PathApi","getEditorPlugin","NodeApi","PathApi","getEditorPlugin","NodeApi","PathApi","cloneDeep","getEditorPlugin","NodeApi","PathApi","cloneDeep","cellEntry","getEditorPlugin","NodeApi","getEmptyRowNode","PathApi","ElementApi","ElementApi","newBorders","getEditorPlugin","cloneDeep","getEditorPlugin","cloneDeep","getEditorPlugin","cloneDeep","getEditorPlugin","getEditorPlugin","isHotkey","isHotkey","newSize","maxCol","maxRow","minCol","minRow","usePluginOption","usePluginOption","editor","React","useEditorPlugin","useElement","useEditorPlugin","useElement","usePluginOption","useEditorPlugin","useElement","usePluginOption","useEditorPlugin","useElement","React","React","useEditorPlugin","useElement","usePluginOption","React","React","useEditorPlugin","useElement","useElementSelector","React","useEditorPlugin","usePluginOption","useEditorPlugin","usePluginOption","React","PathApi","PathApi","useEditorPlugin","useElement","usePluginOption","useEditorPlugin","useElement","usePluginOption","useEditorPlugin","useElement","useElementSelector","React","useEditorPlugin","useElement","usePluginOption","React","React","useEditorPlugin","useElement","useElementSelector","useEditorPlugin","useElement","useElementSelector","React","colIndex","rowIndex","marginLeft","useEditorPlugin","useEditorSelector","usePluginOption","useReadOnly","useEditorPlugin","useReadOnly","useEditorSelector","usePluginOption"]}