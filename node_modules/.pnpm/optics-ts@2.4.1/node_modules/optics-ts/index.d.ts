import { ElemType, Eq, IfElse, Nth, DottedPath, TuplePath, RequireString, Simplify } from './utils.js';
import { Adapt, Apply, Choice, Compose, DisallowTypeChange, ElemUnion, Elems, HKT, Id, Index, PartsOf, Plant, Prop, Optional, SetNth, SetDottedPath, SetTuplePath, Union } from './hkt.js';
export { Apply, Compose, Eq, HKT };
export type Removable = true | undefined;
export interface Params<T extends HKT, R extends Removable = undefined> {
    readonly _T: T;
    readonly _R: R;
}
export type OpticParams = Params<any, any>;
export type NextParams<C extends OpticParams, T extends HKT, R extends Removable = undefined> = Params<Compose<C['_T'], T>, R>;
export type NextComposeParams<C1 extends OpticParams, C2 extends OpticParams> = Params<Compose<C1['_T'], C2['_T']>, C2['_R']>;
export type OpticFor<S> = Equivalence<S, Params<DisallowTypeChange<S>>, S>;
export type OpticFor_<S> = Equivalence<S, Params<Id>, S>;
export interface Equivalence<S, T extends OpticParams, A> {
    readonly _tag: 'Equivalence';
    readonly _removable: T['_R'];
    compose<T2 extends OpticParams, A2>(optic: Equivalence<A, T2, A2>): Equivalence<S, NextComposeParams<T, T2>, A2>;
    compose<T2 extends OpticParams, A2>(optic: Iso<A, T2, A2>): Iso<S, NextComposeParams<T, T2>, A2>;
    iso<U>(there: (a: A) => U, back: (u: U) => A): Iso<S, NextParams<T, Adapt<A, U>>, U>;
    indexed(): Iso<S, NextParams<T, Index>, [number, ElemType<A>][]>;
    compose<T2 extends OpticParams, A2>(optic: Lens<A, T2, A2>): Lens<S, NextComposeParams<T, T2>, A2>;
    lens<U>(view: (a: A) => U, update: (a: A, v: U) => A): Lens<S, NextParams<T, Adapt<A, U>>, U>;
    prop<K extends keyof A>(key: K): Lens<S, NextParams<T, Prop<A, K>>, A[K]>;
    path<K extends keyof any>(path: K): Lens<S, NextParams<T, SetDottedPath<A, K>>, DottedPath<A, K>>;
    path<K extends (keyof any)[]>(...path: K): Lens<S, NextParams<T, SetTuplePath<A, K>>, TuplePath<A, K>>;
    nth<N extends number>(n: N): Lens<S, NextParams<T, SetNth<A, N>>, Nth<A, N>>;
    pick<K extends keyof A>(keys: K[]): Lens<S, NextParams<T, Plant<A, K>>, Pick<A, K>>;
    filter<B extends ElemType<A>>(predicate: (item: ElemType<A>) => item is B): Lens<S, NextParams<T, Union<A>>, B[]>;
    filter(predicate: (item: ElemType<A>) => boolean): Lens<S, NextParams<T, Union<A>>, A>;
    valueOr<B>(defaultValue: B): Lens<S, NextParams<T, Id>, Exclude<A, undefined> | B>;
    partsOf<U extends OpticParams, B>(traversal: Traversal<A, U, B>): Lens<S, NextParams<T, PartsOf<U['_T'], A>>, B[]>;
    partsOf<U extends OpticParams, B>(makeTraversal: (o: OpticFor_<A>) => Traversal<A, U, B>): Lens<S, NextParams<T, PartsOf<U['_T'], A>>, B[]>;
    reread(read: (value: A) => A): Lens<S, NextParams<T, DisallowTypeChange<A>>, A>;
    rewrite(write: (value: A) => A): Lens<S, NextParams<T, DisallowTypeChange<A>>, A>;
    compose<T2 extends OpticParams, A2>(optic: Prism<A, T2, A2>): Prism<S, NextComposeParams<T, T2>, A2>;
    optional(): Prism<S, NextParams<T, Optional>, Exclude<A, undefined>>;
    guard_<F extends HKT>(): <U extends A>(g: (a: A) => a is U) => Prism<S, NextParams<T, F>, U>;
    guard<U extends A>(g: (a: A) => a is U): Prism<S, NextParams<T, Choice<A, U>>, U>;
    find(predicate: (item: ElemType<A>) => boolean): Prism<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>;
    when(predicate: (item: A) => boolean): Prism<S, NextParams<T, Union<A>>, A>;
    at(i: number): IfElse<Eq<A, string>, Prism<S, NextParams<T, DisallowTypeChange<string>, true>, string>, Prism<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>>;
    head(): IfElse<Eq<A, string>, Prism<S, NextParams<T, DisallowTypeChange<string>, true>, string>, Prism<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>>;
    index(i: number): IfElse<Eq<A, string>, Prism<S, NextParams<T, DisallowTypeChange<string>, true>, string>, Prism<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>>;
    compose<T2 extends OpticParams, A2>(optic: Traversal<A, T2, A2>): Traversal<S, NextComposeParams<T, T2>, A2>;
    elems(): Traversal<S, NextParams<T, Elems>, ElemType<A>>;
    chars(): RequireString<A, Traversal<S, NextParams<T, DisallowTypeChange<string>>, string>>;
    words(): RequireString<A, Traversal<S, NextParams<T, DisallowTypeChange<string>>, string>>;
    compose<A2>(optic: Getter<A, A2>): Getter<S, A2>;
    to<B>(f: (a: A) => B): Getter<S, B>;
    compose<A2>(optic: AffineFold<A, A2>): AffineFold<S, A2>;
    compose<A2>(optic: Fold<A, A2>): Fold<S, A2>;
    compose<T2 extends OpticParams, A2>(optic: Setter<A, T2, A2>): Setter<S, NextComposeParams<T, T2>, A2>;
    prependTo(): Setter<S, NextParams<T, ElemUnion<A>>, ElemType<A>>;
    appendTo(): Setter<S, NextParams<T, ElemUnion<A>>, ElemType<A>>;
}
export interface Iso<S, T extends OpticParams, A> {
    readonly _tag: 'Iso';
    readonly _removable: T['_R'];
    compose<T2 extends OpticParams, A2>(optic: Equivalence<A, T2, A2>): Iso<S, NextComposeParams<T, T2>, A2>;
    compose<T2 extends OpticParams, A2>(optic: Iso<A, T2, A2>): Iso<S, NextComposeParams<T, T2>, A2>;
    iso<U>(there: (a: A) => U, back: (u: U) => A): Iso<S, NextParams<T, Adapt<A, U>>, U>;
    indexed(): Iso<S, NextParams<T, Index>, [number, ElemType<A>][]>;
    compose<T2 extends OpticParams, A2>(optic: Lens<A, T2, A2>): Lens<S, NextComposeParams<T, T2>, A2>;
    lens<U>(view: (a: A) => U, update: (a: A, v: U) => A): Lens<S, NextParams<T, Adapt<A, U>>, U>;
    prop<K extends keyof A>(key: K): Lens<S, NextParams<T, Prop<A, K>>, A[K]>;
    path<K extends keyof any>(path: K): Lens<S, NextParams<T, SetDottedPath<A, K>>, DottedPath<A, K>>;
    path<K extends (keyof any)[]>(...path: K): Lens<S, NextParams<T, SetTuplePath<A, K>>, TuplePath<A, K>>;
    nth<N extends number>(n: N): Lens<S, NextParams<T, SetNth<A, N>>, Nth<A, N>>;
    pick<K extends keyof A>(keys: K[]): Lens<S, NextParams<T, Plant<A, K>>, Pick<A, K>>;
    filter<B extends ElemType<A>>(predicate: (item: ElemType<A>) => item is B): Lens<S, NextParams<T, Union<A>>, B[]>;
    filter(predicate: (item: ElemType<A>) => boolean): Lens<S, NextParams<T, Union<A>>, A>;
    valueOr<B>(defaultValue: B): Lens<S, NextParams<T, Id>, Exclude<A, undefined> | B>;
    partsOf<U extends OpticParams, B>(traversal: Traversal<A, U, B>): Lens<S, NextParams<T, PartsOf<U['_T'], A>>, B[]>;
    partsOf<U extends OpticParams, B>(makeTraversal: (o: OpticFor_<A>) => Traversal<A, U, B>): Lens<S, NextParams<T, PartsOf<U['_T'], A>>, B[]>;
    reread(read: (value: A) => A): Lens<S, NextParams<T, DisallowTypeChange<A>>, A>;
    rewrite(write: (value: A) => A): Lens<S, NextParams<T, DisallowTypeChange<A>>, A>;
    compose<T2 extends OpticParams, A2>(optic: Prism<A, T2, A2>): Prism<S, NextComposeParams<T, T2>, A2>;
    optional(): Prism<S, NextParams<T, Optional>, Exclude<A, undefined>>;
    guard_<F extends HKT>(): <U extends A>(g: (a: A) => a is U) => Prism<S, NextParams<T, F>, U>;
    guard<U extends A>(g: (a: A) => a is U): Prism<S, NextParams<T, Choice<A, U>>, U>;
    find(predicate: (item: ElemType<A>) => boolean): Prism<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>;
    when(predicate: (item: A) => boolean): Prism<S, NextParams<T, Union<A>>, A>;
    at(i: number): IfElse<Eq<A, string>, Prism<S, NextParams<T, DisallowTypeChange<string>, true>, string>, Prism<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>>;
    head(): IfElse<Eq<A, string>, Prism<S, NextParams<T, DisallowTypeChange<string>, true>, string>, Prism<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>>;
    index(i: number): IfElse<Eq<A, string>, Prism<S, NextParams<T, DisallowTypeChange<string>, true>, string>, Prism<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>>;
    compose<T2 extends OpticParams, A2>(optic: Traversal<A, T2, A2>): Traversal<S, NextComposeParams<T, T2>, A2>;
    elems(): Traversal<S, NextParams<T, Elems>, ElemType<A>>;
    chars(): RequireString<A, Traversal<S, NextParams<T, DisallowTypeChange<string>>, string>>;
    words(): RequireString<A, Traversal<S, NextParams<T, DisallowTypeChange<string>>, string>>;
    compose<A2>(optic: Getter<A, A2>): Getter<S, A2>;
    to<B>(f: (a: A) => B): Getter<S, B>;
    compose<A2>(optic: AffineFold<A, A2>): AffineFold<S, A2>;
    compose<A2>(optic: Fold<A, A2>): Fold<S, A2>;
    compose<T2 extends OpticParams, A2>(optic: Setter<A, T2, A2>): Setter<S, NextComposeParams<T, T2>, A2>;
    prependTo(): Setter<S, NextParams<T, ElemUnion<A>>, ElemType<A>>;
    appendTo(): Setter<S, NextParams<T, ElemUnion<A>>, ElemType<A>>;
}
export interface Lens<S, T extends OpticParams, A> {
    readonly _tag: 'Lens';
    readonly _removable: T['_R'];
    compose<T2 extends OpticParams, A2>(optic: Equivalence<A, T2, A2>): Lens<S, NextComposeParams<T, T2>, A2>;
    compose<T2 extends OpticParams, A2>(optic: Iso<A, T2, A2>): Lens<S, NextComposeParams<T, T2>, A2>;
    iso<U>(there: (a: A) => U, back: (u: U) => A): Lens<S, NextParams<T, Adapt<A, U>>, U>;
    indexed(): Lens<S, NextParams<T, Index>, [number, ElemType<A>][]>;
    compose<T2 extends OpticParams, A2>(optic: Lens<A, T2, A2>): Lens<S, NextComposeParams<T, T2>, A2>;
    lens<U>(view: (a: A) => U, update: (a: A, v: U) => A): Lens<S, NextParams<T, Adapt<A, U>>, U>;
    prop<K extends keyof A>(key: K): Lens<S, NextParams<T, Prop<A, K>>, A[K]>;
    path<K extends keyof any>(path: K): Lens<S, NextParams<T, SetDottedPath<A, K>>, DottedPath<A, K>>;
    path<K extends (keyof any)[]>(...path: K): Lens<S, NextParams<T, SetTuplePath<A, K>>, TuplePath<A, K>>;
    nth<N extends number>(n: N): Lens<S, NextParams<T, SetNth<A, N>>, Nth<A, N>>;
    pick<K extends keyof A>(keys: K[]): Lens<S, NextParams<T, Plant<A, K>>, Pick<A, K>>;
    filter<B extends ElemType<A>>(predicate: (item: ElemType<A>) => item is B): Lens<S, NextParams<T, Union<A>>, B[]>;
    filter(predicate: (item: ElemType<A>) => boolean): Lens<S, NextParams<T, Union<A>>, A>;
    valueOr<B>(defaultValue: B): Lens<S, NextParams<T, Id>, Exclude<A, undefined> | B>;
    partsOf<U extends OpticParams, B>(traversal: Traversal<A, U, B>): Lens<S, NextParams<T, PartsOf<U['_T'], A>>, B[]>;
    partsOf<U extends OpticParams, B>(makeTraversal: (o: OpticFor_<A>) => Traversal<A, U, B>): Lens<S, NextParams<T, PartsOf<U['_T'], A>>, B[]>;
    reread(read: (value: A) => A): Lens<S, NextParams<T, DisallowTypeChange<A>>, A>;
    rewrite(write: (value: A) => A): Lens<S, NextParams<T, DisallowTypeChange<A>>, A>;
    compose<T2 extends OpticParams, A2>(optic: Prism<A, T2, A2>): Prism<S, NextComposeParams<T, T2>, A2>;
    optional(): Prism<S, NextParams<T, Optional>, Exclude<A, undefined>>;
    guard_<F extends HKT>(): <U extends A>(g: (a: A) => a is U) => Prism<S, NextParams<T, F>, U>;
    guard<U extends A>(g: (a: A) => a is U): Prism<S, NextParams<T, Choice<A, U>>, U>;
    find(predicate: (item: ElemType<A>) => boolean): Prism<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>;
    when(predicate: (item: A) => boolean): Prism<S, NextParams<T, Union<A>>, A>;
    at(i: number): IfElse<Eq<A, string>, Prism<S, NextParams<T, DisallowTypeChange<string>, true>, string>, Prism<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>>;
    head(): IfElse<Eq<A, string>, Prism<S, NextParams<T, DisallowTypeChange<string>, true>, string>, Prism<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>>;
    index(i: number): IfElse<Eq<A, string>, Prism<S, NextParams<T, DisallowTypeChange<string>, true>, string>, Prism<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>>;
    compose<T2 extends OpticParams, A2>(optic: Traversal<A, T2, A2>): Traversal<S, NextComposeParams<T, T2>, A2>;
    elems(): Traversal<S, NextParams<T, Elems>, ElemType<A>>;
    chars(): RequireString<A, Traversal<S, NextParams<T, DisallowTypeChange<string>>, string>>;
    words(): RequireString<A, Traversal<S, NextParams<T, DisallowTypeChange<string>>, string>>;
    compose<A2>(optic: Getter<A, A2>): Getter<S, A2>;
    to<B>(f: (a: A) => B): Getter<S, B>;
    compose<A2>(optic: AffineFold<A, A2>): AffineFold<S, A2>;
    compose<A2>(optic: Fold<A, A2>): Fold<S, A2>;
    compose<T2 extends OpticParams, A2>(optic: Setter<A, T2, A2>): Setter<S, NextComposeParams<T, T2>, A2>;
    prependTo(): Setter<S, NextParams<T, ElemUnion<A>>, ElemType<A>>;
    appendTo(): Setter<S, NextParams<T, ElemUnion<A>>, ElemType<A>>;
}
export interface Prism<S, T extends OpticParams, A> {
    readonly _tag: 'Prism';
    readonly _removable: T['_R'];
    compose<T2 extends OpticParams, A2>(optic: Equivalence<A, T2, A2>): Prism<S, NextComposeParams<T, T2>, A2>;
    compose<T2 extends OpticParams, A2>(optic: Iso<A, T2, A2>): Prism<S, NextComposeParams<T, T2>, A2>;
    iso<U>(there: (a: A) => U, back: (u: U) => A): Prism<S, NextParams<T, Adapt<A, U>>, U>;
    indexed(): Prism<S, NextParams<T, Index>, [number, ElemType<A>][]>;
    compose<T2 extends OpticParams, A2>(optic: Lens<A, T2, A2>): Prism<S, NextComposeParams<T, T2>, A2>;
    lens<U>(view: (a: A) => U, update: (a: A, v: U) => A): Prism<S, NextParams<T, Adapt<A, U>>, U>;
    prop<K extends keyof A>(key: K): Prism<S, NextParams<T, Prop<A, K>>, A[K]>;
    path<K extends keyof any>(path: K): Prism<S, NextParams<T, SetDottedPath<A, K>>, DottedPath<A, K>>;
    path<K extends (keyof any)[]>(...path: K): Prism<S, NextParams<T, SetTuplePath<A, K>>, TuplePath<A, K>>;
    nth<N extends number>(n: N): Prism<S, NextParams<T, SetNth<A, N>>, Nth<A, N>>;
    pick<K extends keyof A>(keys: K[]): Prism<S, NextParams<T, Plant<A, K>>, Pick<A, K>>;
    filter<B extends ElemType<A>>(predicate: (item: ElemType<A>) => item is B): Prism<S, NextParams<T, Union<A>>, B[]>;
    filter(predicate: (item: ElemType<A>) => boolean): Prism<S, NextParams<T, Union<A>>, A>;
    valueOr<B>(defaultValue: B): Prism<S, NextParams<T, Id>, Exclude<A, undefined> | B>;
    partsOf<U extends OpticParams, B>(traversal: Traversal<A, U, B>): Prism<S, NextParams<T, PartsOf<U['_T'], A>>, B[]>;
    partsOf<U extends OpticParams, B>(makeTraversal: (o: OpticFor_<A>) => Traversal<A, U, B>): Prism<S, NextParams<T, PartsOf<U['_T'], A>>, B[]>;
    reread(read: (value: A) => A): Prism<S, NextParams<T, DisallowTypeChange<A>>, A>;
    rewrite(write: (value: A) => A): Prism<S, NextParams<T, DisallowTypeChange<A>>, A>;
    compose<T2 extends OpticParams, A2>(optic: Prism<A, T2, A2>): Prism<S, NextComposeParams<T, T2>, A2>;
    optional(): Prism<S, NextParams<T, Optional>, Exclude<A, undefined>>;
    guard_<F extends HKT>(): <U extends A>(g: (a: A) => a is U) => Prism<S, NextParams<T, F>, U>;
    guard<U extends A>(g: (a: A) => a is U): Prism<S, NextParams<T, Choice<A, U>>, U>;
    find(predicate: (item: ElemType<A>) => boolean): Prism<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>;
    when(predicate: (item: A) => boolean): Prism<S, NextParams<T, Union<A>>, A>;
    at(i: number): IfElse<Eq<A, string>, Prism<S, NextParams<T, DisallowTypeChange<string>, true>, string>, Prism<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>>;
    head(): IfElse<Eq<A, string>, Prism<S, NextParams<T, DisallowTypeChange<string>, true>, string>, Prism<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>>;
    index(i: number): IfElse<Eq<A, string>, Prism<S, NextParams<T, DisallowTypeChange<string>, true>, string>, Prism<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>>;
    compose<T2 extends OpticParams, A2>(optic: Traversal<A, T2, A2>): Traversal<S, NextComposeParams<T, T2>, A2>;
    elems(): Traversal<S, NextParams<T, Elems>, ElemType<A>>;
    chars(): RequireString<A, Traversal<S, NextParams<T, DisallowTypeChange<string>>, string>>;
    words(): RequireString<A, Traversal<S, NextParams<T, DisallowTypeChange<string>>, string>>;
    compose<A2>(optic: Getter<A, A2>): AffineFold<S, A2>;
    to<B>(f: (a: A) => B): AffineFold<S, B>;
    compose<A2>(optic: AffineFold<A, A2>): AffineFold<S, A2>;
    compose<A2>(optic: Fold<A, A2>): Fold<S, A2>;
    compose<T2 extends OpticParams, A2>(optic: Setter<A, T2, A2>): Setter<S, NextComposeParams<T, T2>, A2>;
    prependTo(): Setter<S, NextParams<T, ElemUnion<A>>, ElemType<A>>;
    appendTo(): Setter<S, NextParams<T, ElemUnion<A>>, ElemType<A>>;
}
export interface Traversal<S, T extends OpticParams, A> {
    readonly _tag: 'Traversal';
    readonly _removable: T['_R'];
    compose<T2 extends OpticParams, A2>(optic: Equivalence<A, T2, A2>): Traversal<S, NextComposeParams<T, T2>, A2>;
    compose<T2 extends OpticParams, A2>(optic: Iso<A, T2, A2>): Traversal<S, NextComposeParams<T, T2>, A2>;
    iso<U>(there: (a: A) => U, back: (u: U) => A): Traversal<S, NextParams<T, Adapt<A, U>>, U>;
    indexed(): Traversal<S, NextParams<T, Index>, [number, ElemType<A>][]>;
    compose<T2 extends OpticParams, A2>(optic: Lens<A, T2, A2>): Traversal<S, NextComposeParams<T, T2>, A2>;
    lens<U>(view: (a: A) => U, update: (a: A, v: U) => A): Traversal<S, NextParams<T, Adapt<A, U>>, U>;
    prop<K extends keyof A>(key: K): Traversal<S, NextParams<T, Prop<A, K>>, A[K]>;
    path<K extends keyof any>(path: K): Traversal<S, NextParams<T, SetDottedPath<A, K>>, DottedPath<A, K>>;
    path<K extends (keyof any)[]>(...path: K): Traversal<S, NextParams<T, SetTuplePath<A, K>>, TuplePath<A, K>>;
    nth<N extends number>(n: N): Traversal<S, NextParams<T, SetNth<A, N>>, Nth<A, N>>;
    pick<K extends keyof A>(keys: K[]): Traversal<S, NextParams<T, Plant<A, K>>, Pick<A, K>>;
    filter<B extends ElemType<A>>(predicate: (item: ElemType<A>) => item is B): Traversal<S, NextParams<T, Union<A>>, B[]>;
    filter(predicate: (item: ElemType<A>) => boolean): Traversal<S, NextParams<T, Union<A>>, A>;
    valueOr<B>(defaultValue: B): Traversal<S, NextParams<T, Id>, Exclude<A, undefined> | B>;
    partsOf<U extends OpticParams, B>(traversal: Traversal<A, U, B>): Traversal<S, NextParams<T, PartsOf<U['_T'], A>>, B[]>;
    partsOf<U extends OpticParams, B>(makeTraversal: (o: OpticFor_<A>) => Traversal<A, U, B>): Traversal<S, NextParams<T, PartsOf<U['_T'], A>>, B[]>;
    reread(read: (value: A) => A): Traversal<S, NextParams<T, DisallowTypeChange<A>>, A>;
    rewrite(write: (value: A) => A): Traversal<S, NextParams<T, DisallowTypeChange<A>>, A>;
    compose<T2 extends OpticParams, A2>(optic: Prism<A, T2, A2>): Traversal<S, NextComposeParams<T, T2>, A2>;
    optional(): Traversal<S, NextParams<T, Optional>, Exclude<A, undefined>>;
    guard_<F extends HKT>(): <U extends A>(g: (a: A) => a is U) => Traversal<S, NextParams<T, F>, U>;
    guard<U extends A>(g: (a: A) => a is U): Traversal<S, NextParams<T, Choice<A, U>>, U>;
    find(predicate: (item: ElemType<A>) => boolean): Traversal<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>;
    when(predicate: (item: A) => boolean): Traversal<S, NextParams<T, Union<A>>, A>;
    at(i: number): IfElse<Eq<A, string>, Traversal<S, NextParams<T, DisallowTypeChange<string>, true>, string>, Traversal<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>>;
    head(): IfElse<Eq<A, string>, Traversal<S, NextParams<T, DisallowTypeChange<string>, true>, string>, Traversal<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>>;
    index(i: number): IfElse<Eq<A, string>, Traversal<S, NextParams<T, DisallowTypeChange<string>, true>, string>, Traversal<S, NextParams<T, ElemUnion<A>, true>, ElemType<A>>>;
    compose<T2 extends OpticParams, A2>(optic: Traversal<A, T2, A2>): Traversal<S, NextComposeParams<T, T2>, A2>;
    elems(): Traversal<S, NextParams<T, Elems>, ElemType<A>>;
    chars(): RequireString<A, Traversal<S, NextParams<T, DisallowTypeChange<string>>, string>>;
    words(): RequireString<A, Traversal<S, NextParams<T, DisallowTypeChange<string>>, string>>;
    compose<A2>(optic: Getter<A, A2>): Fold<S, A2>;
    to<B>(f: (a: A) => B): Fold<S, B>;
    compose<A2>(optic: AffineFold<A, A2>): Fold<S, A2>;
    compose<A2>(optic: Fold<A, A2>): Fold<S, A2>;
    compose<T2 extends OpticParams, A2>(optic: Setter<A, T2, A2>): Setter<S, NextComposeParams<T, T2>, A2>;
    prependTo(): Setter<S, NextParams<T, ElemUnion<A>>, ElemType<A>>;
    appendTo(): Setter<S, NextParams<T, ElemUnion<A>>, ElemType<A>>;
}
export interface Getter<S, A> {
    readonly _tag: 'Getter';
    compose<T2 extends OpticParams, A2>(optic: Equivalence<A, T2, A2>): Getter<S, A2>;
    compose<T2 extends OpticParams, A2>(optic: Iso<A, T2, A2>): Getter<S, A2>;
    iso<U>(there: (a: A) => U, back: (u: U) => A): Getter<S, U>;
    indexed(): Getter<S, [number, ElemType<A>][]>;
    compose<T2 extends OpticParams, A2>(optic: Lens<A, T2, A2>): Getter<S, A2>;
    lens<U>(view: (a: A) => U, update: (a: A, v: U) => A): Getter<S, U>;
    prop<K extends keyof A>(key: K): Getter<S, A[K]>;
    path<K extends keyof any>(path: K): Getter<S, DottedPath<A, K>>;
    path<K extends (keyof any)[]>(...path: K): Getter<S, TuplePath<A, K>>;
    nth<N extends number>(n: N): Getter<S, Nth<A, N>>;
    pick<K extends keyof A>(keys: K[]): Getter<S, Pick<A, K>>;
    filter<B extends ElemType<A>>(predicate: (item: ElemType<A>) => item is B): Getter<S, B[]>;
    filter(predicate: (item: ElemType<A>) => boolean): Getter<S, A>;
    valueOr<B>(defaultValue: B): Getter<S, Exclude<A, undefined> | B>;
    partsOf<U extends OpticParams, B>(traversal: Traversal<A, U, B>): Getter<S, B[]>;
    partsOf<U extends OpticParams, B>(makeTraversal: (o: OpticFor_<A>) => Traversal<A, U, B>): Getter<S, B[]>;
    reread(read: (value: A) => A): Getter<S, A>;
    rewrite(write: (value: A) => A): Getter<S, A>;
    compose<T2 extends OpticParams, A2>(optic: Prism<A, T2, A2>): AffineFold<S, A2>;
    optional(): AffineFold<S, Exclude<A, undefined>>;
    guard_<F extends HKT>(): <U extends A>(g: (a: A) => a is U) => AffineFold<S, U>;
    guard<U extends A>(g: (a: A) => a is U): AffineFold<S, U>;
    find(predicate: (item: ElemType<A>) => boolean): AffineFold<S, ElemType<A>>;
    when(predicate: (item: A) => boolean): AffineFold<S, A>;
    at(i: number): IfElse<Eq<A, string>, AffineFold<S, string>, AffineFold<S, ElemType<A>>>;
    head(): IfElse<Eq<A, string>, AffineFold<S, string>, AffineFold<S, ElemType<A>>>;
    index(i: number): IfElse<Eq<A, string>, AffineFold<S, string>, AffineFold<S, ElemType<A>>>;
    compose<T2 extends OpticParams, A2>(optic: Traversal<A, T2, A2>): Fold<S, A2>;
    elems(): Fold<S, ElemType<A>>;
    chars(): RequireString<A, Fold<S, string>>;
    words(): RequireString<A, Fold<S, string>>;
    compose<A2>(optic: Getter<A, A2>): Getter<S, A2>;
    to<B>(f: (a: A) => B): Getter<S, B>;
    compose<A2>(optic: AffineFold<A, A2>): AffineFold<S, A2>;
    compose<A2>(optic: Fold<A, A2>): Fold<S, A2>;
}
export interface AffineFold<S, A> {
    readonly _tag: 'AffineFold';
    compose<T2 extends OpticParams, A2>(optic: Equivalence<A, T2, A2>): AffineFold<S, A2>;
    compose<T2 extends OpticParams, A2>(optic: Iso<A, T2, A2>): AffineFold<S, A2>;
    iso<U>(there: (a: A) => U, back: (u: U) => A): AffineFold<S, U>;
    indexed(): AffineFold<S, [number, ElemType<A>][]>;
    compose<T2 extends OpticParams, A2>(optic: Lens<A, T2, A2>): AffineFold<S, A2>;
    lens<U>(view: (a: A) => U, update: (a: A, v: U) => A): AffineFold<S, U>;
    prop<K extends keyof A>(key: K): AffineFold<S, A[K]>;
    path<K extends keyof any>(path: K): AffineFold<S, DottedPath<A, K>>;
    path<K extends (keyof any)[]>(...path: K): AffineFold<S, TuplePath<A, K>>;
    nth<N extends number>(n: N): AffineFold<S, Nth<A, N>>;
    pick<K extends keyof A>(keys: K[]): AffineFold<S, Pick<A, K>>;
    filter<B extends ElemType<A>>(predicate: (item: ElemType<A>) => item is B): AffineFold<S, B[]>;
    filter(predicate: (item: ElemType<A>) => boolean): AffineFold<S, A>;
    valueOr<B>(defaultValue: B): AffineFold<S, Exclude<A, undefined> | B>;
    partsOf<U extends OpticParams, B>(traversal: Traversal<A, U, B>): AffineFold<S, B[]>;
    partsOf<U extends OpticParams, B>(makeTraversal: (o: OpticFor_<A>) => Traversal<A, U, B>): AffineFold<S, B[]>;
    reread(read: (value: A) => A): AffineFold<S, A>;
    rewrite(write: (value: A) => A): AffineFold<S, A>;
    compose<T2 extends OpticParams, A2>(optic: Prism<A, T2, A2>): AffineFold<S, A2>;
    optional(): AffineFold<S, Exclude<A, undefined>>;
    guard_<F extends HKT>(): <U extends A>(g: (a: A) => a is U) => AffineFold<S, U>;
    guard<U extends A>(g: (a: A) => a is U): AffineFold<S, U>;
    find(predicate: (item: ElemType<A>) => boolean): AffineFold<S, ElemType<A>>;
    when(predicate: (item: A) => boolean): AffineFold<S, A>;
    at(i: number): IfElse<Eq<A, string>, AffineFold<S, string>, AffineFold<S, ElemType<A>>>;
    head(): IfElse<Eq<A, string>, AffineFold<S, string>, AffineFold<S, ElemType<A>>>;
    index(i: number): IfElse<Eq<A, string>, AffineFold<S, string>, AffineFold<S, ElemType<A>>>;
    compose<T2 extends OpticParams, A2>(optic: Traversal<A, T2, A2>): Fold<S, A2>;
    elems(): Fold<S, ElemType<A>>;
    chars(): RequireString<A, Fold<S, string>>;
    words(): RequireString<A, Fold<S, string>>;
    compose<A2>(optic: Getter<A, A2>): AffineFold<S, A2>;
    to<B>(f: (a: A) => B): AffineFold<S, B>;
    compose<A2>(optic: AffineFold<A, A2>): AffineFold<S, A2>;
    compose<A2>(optic: Fold<A, A2>): Fold<S, A2>;
}
export interface Fold<S, A> {
    readonly _tag: 'Fold';
    compose<T2 extends OpticParams, A2>(optic: Equivalence<A, T2, A2>): Fold<S, A2>;
    compose<T2 extends OpticParams, A2>(optic: Iso<A, T2, A2>): Fold<S, A2>;
    iso<U>(there: (a: A) => U, back: (u: U) => A): Fold<S, U>;
    indexed(): Fold<S, [number, ElemType<A>][]>;
    compose<T2 extends OpticParams, A2>(optic: Lens<A, T2, A2>): Fold<S, A2>;
    lens<U>(view: (a: A) => U, update: (a: A, v: U) => A): Fold<S, U>;
    prop<K extends keyof A>(key: K): Fold<S, A[K]>;
    path<K extends keyof any>(path: K): Fold<S, DottedPath<A, K>>;
    path<K extends (keyof any)[]>(...path: K): Fold<S, TuplePath<A, K>>;
    nth<N extends number>(n: N): Fold<S, Nth<A, N>>;
    pick<K extends keyof A>(keys: K[]): Fold<S, Pick<A, K>>;
    filter<B extends ElemType<A>>(predicate: (item: ElemType<A>) => item is B): Fold<S, B[]>;
    filter(predicate: (item: ElemType<A>) => boolean): Fold<S, A>;
    valueOr<B>(defaultValue: B): Fold<S, Exclude<A, undefined> | B>;
    partsOf<U extends OpticParams, B>(traversal: Traversal<A, U, B>): Fold<S, B[]>;
    partsOf<U extends OpticParams, B>(makeTraversal: (o: OpticFor_<A>) => Traversal<A, U, B>): Fold<S, B[]>;
    reread(read: (value: A) => A): Fold<S, A>;
    rewrite(write: (value: A) => A): Fold<S, A>;
    compose<T2 extends OpticParams, A2>(optic: Prism<A, T2, A2>): Fold<S, A2>;
    optional(): Fold<S, Exclude<A, undefined>>;
    guard_<F extends HKT>(): <U extends A>(g: (a: A) => a is U) => Fold<S, U>;
    guard<U extends A>(g: (a: A) => a is U): Fold<S, U>;
    find(predicate: (item: ElemType<A>) => boolean): Fold<S, ElemType<A>>;
    when(predicate: (item: A) => boolean): Fold<S, A>;
    at(i: number): IfElse<Eq<A, string>, Fold<S, string>, Fold<S, ElemType<A>>>;
    head(): IfElse<Eq<A, string>, Fold<S, string>, Fold<S, ElemType<A>>>;
    index(i: number): IfElse<Eq<A, string>, Fold<S, string>, Fold<S, ElemType<A>>>;
    compose<T2 extends OpticParams, A2>(optic: Traversal<A, T2, A2>): Fold<S, A2>;
    elems(): Fold<S, ElemType<A>>;
    chars(): RequireString<A, Fold<S, string>>;
    words(): RequireString<A, Fold<S, string>>;
    compose<A2>(optic: Getter<A, A2>): Fold<S, A2>;
    to<B>(f: (a: A) => B): Fold<S, B>;
    compose<A2>(optic: AffineFold<A, A2>): Fold<S, A2>;
    compose<A2>(optic: Fold<A, A2>): Fold<S, A2>;
}
export interface Setter<S, T extends OpticParams, A> {
    readonly _tag: 'Setter';
    readonly _removable: T['_R'];
}
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Equivalence<S, T, A>, optic2: Equivalence<A, T2, A2>): Equivalence<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Equivalence<S, T, A>, optic2: Iso<A, T2, A2>): Iso<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Equivalence<S, T, A>, optic2: Lens<A, T2, A2>): Lens<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Equivalence<S, T, A>, optic2: Prism<A, T2, A2>): Prism<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Equivalence<S, T, A>, optic2: Traversal<A, T2, A2>): Traversal<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, A2>(optic1: Equivalence<S, T, A>, optic2: Getter<A, A2>): Getter<S, A2>;
export declare function compose<S, T extends OpticParams, A, A2>(optic1: Equivalence<S, T, A>, optic2: AffineFold<A, A2>): AffineFold<S, A2>;
export declare function compose<S, T extends OpticParams, A, A2>(optic1: Equivalence<S, T, A>, optic2: Fold<A, A2>): Fold<S, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Equivalence<S, T, A>, optic2: Setter<A, T2, A2>): Setter<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Iso<S, T, A>, optic2: Equivalence<A, T2, A2>): Iso<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Iso<S, T, A>, optic2: Iso<A, T2, A2>): Iso<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Iso<S, T, A>, optic2: Lens<A, T2, A2>): Lens<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Iso<S, T, A>, optic2: Prism<A, T2, A2>): Prism<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Iso<S, T, A>, optic2: Traversal<A, T2, A2>): Traversal<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, A2>(optic1: Iso<S, T, A>, optic2: Getter<A, A2>): Getter<S, A2>;
export declare function compose<S, T extends OpticParams, A, A2>(optic1: Iso<S, T, A>, optic2: AffineFold<A, A2>): AffineFold<S, A2>;
export declare function compose<S, T extends OpticParams, A, A2>(optic1: Iso<S, T, A>, optic2: Fold<A, A2>): Fold<S, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Iso<S, T, A>, optic2: Setter<A, T2, A2>): Setter<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Lens<S, T, A>, optic2: Equivalence<A, T2, A2>): Lens<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Lens<S, T, A>, optic2: Iso<A, T2, A2>): Lens<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Lens<S, T, A>, optic2: Lens<A, T2, A2>): Lens<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Lens<S, T, A>, optic2: Prism<A, T2, A2>): Prism<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Lens<S, T, A>, optic2: Traversal<A, T2, A2>): Traversal<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, A2>(optic1: Lens<S, T, A>, optic2: Getter<A, A2>): Getter<S, A2>;
export declare function compose<S, T extends OpticParams, A, A2>(optic1: Lens<S, T, A>, optic2: AffineFold<A, A2>): AffineFold<S, A2>;
export declare function compose<S, T extends OpticParams, A, A2>(optic1: Lens<S, T, A>, optic2: Fold<A, A2>): Fold<S, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Lens<S, T, A>, optic2: Setter<A, T2, A2>): Setter<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Prism<S, T, A>, optic2: Equivalence<A, T2, A2>): Prism<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Prism<S, T, A>, optic2: Iso<A, T2, A2>): Prism<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Prism<S, T, A>, optic2: Lens<A, T2, A2>): Prism<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Prism<S, T, A>, optic2: Prism<A, T2, A2>): Prism<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Prism<S, T, A>, optic2: Traversal<A, T2, A2>): Traversal<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, A2>(optic1: Prism<S, T, A>, optic2: Getter<A, A2>): AffineFold<S, A2>;
export declare function compose<S, T extends OpticParams, A, A2>(optic1: Prism<S, T, A>, optic2: AffineFold<A, A2>): AffineFold<S, A2>;
export declare function compose<S, T extends OpticParams, A, A2>(optic1: Prism<S, T, A>, optic2: Fold<A, A2>): Fold<S, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Prism<S, T, A>, optic2: Setter<A, T2, A2>): Setter<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Traversal<S, T, A>, optic2: Equivalence<A, T2, A2>): Traversal<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Traversal<S, T, A>, optic2: Iso<A, T2, A2>): Traversal<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Traversal<S, T, A>, optic2: Lens<A, T2, A2>): Traversal<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Traversal<S, T, A>, optic2: Prism<A, T2, A2>): Traversal<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Traversal<S, T, A>, optic2: Traversal<A, T2, A2>): Traversal<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, T extends OpticParams, A, A2>(optic1: Traversal<S, T, A>, optic2: Getter<A, A2>): Fold<S, A2>;
export declare function compose<S, T extends OpticParams, A, A2>(optic1: Traversal<S, T, A>, optic2: AffineFold<A, A2>): Fold<S, A2>;
export declare function compose<S, T extends OpticParams, A, A2>(optic1: Traversal<S, T, A>, optic2: Fold<A, A2>): Fold<S, A2>;
export declare function compose<S, T extends OpticParams, A, T2 extends OpticParams, A2>(optic1: Traversal<S, T, A>, optic2: Setter<A, T2, A2>): Setter<S, NextComposeParams<T, T2>, A2>;
export declare function compose<S, A, T2 extends OpticParams, A2>(optic1: Getter<S, A>, optic2: Equivalence<A, T2, A2>): Getter<S, A2>;
export declare function compose<S, A, T2 extends OpticParams, A2>(optic1: Getter<S, A>, optic2: Iso<A, T2, A2>): Getter<S, A2>;
export declare function compose<S, A, T2 extends OpticParams, A2>(optic1: Getter<S, A>, optic2: Lens<A, T2, A2>): Getter<S, A2>;
export declare function compose<S, A, T2 extends OpticParams, A2>(optic1: Getter<S, A>, optic2: Prism<A, T2, A2>): AffineFold<S, A2>;
export declare function compose<S, A, T2 extends OpticParams, A2>(optic1: Getter<S, A>, optic2: Traversal<A, T2, A2>): Fold<S, A2>;
export declare function compose<S, A, A2>(optic1: Getter<S, A>, optic2: Getter<A, A2>): Getter<S, A2>;
export declare function compose<S, A, A2>(optic1: Getter<S, A>, optic2: AffineFold<A, A2>): AffineFold<S, A2>;
export declare function compose<S, A, A2>(optic1: Getter<S, A>, optic2: Fold<A, A2>): Fold<S, A2>;
export declare function compose<S, A, T2 extends OpticParams, A2>(optic1: AffineFold<S, A>, optic2: Equivalence<A, T2, A2>): AffineFold<S, A2>;
export declare function compose<S, A, T2 extends OpticParams, A2>(optic1: AffineFold<S, A>, optic2: Iso<A, T2, A2>): AffineFold<S, A2>;
export declare function compose<S, A, T2 extends OpticParams, A2>(optic1: AffineFold<S, A>, optic2: Lens<A, T2, A2>): AffineFold<S, A2>;
export declare function compose<S, A, T2 extends OpticParams, A2>(optic1: AffineFold<S, A>, optic2: Prism<A, T2, A2>): AffineFold<S, A2>;
export declare function compose<S, A, T2 extends OpticParams, A2>(optic1: AffineFold<S, A>, optic2: Traversal<A, T2, A2>): Fold<S, A2>;
export declare function compose<S, A, A2>(optic1: AffineFold<S, A>, optic2: Getter<A, A2>): AffineFold<S, A2>;
export declare function compose<S, A, A2>(optic1: AffineFold<S, A>, optic2: AffineFold<A, A2>): AffineFold<S, A2>;
export declare function compose<S, A, A2>(optic1: AffineFold<S, A>, optic2: Fold<A, A2>): Fold<S, A2>;
export declare function compose<S, A, T2 extends OpticParams, A2>(optic1: Fold<S, A>, optic2: Equivalence<A, T2, A2>): Fold<S, A2>;
export declare function compose<S, A, T2 extends OpticParams, A2>(optic1: Fold<S, A>, optic2: Iso<A, T2, A2>): Fold<S, A2>;
export declare function compose<S, A, T2 extends OpticParams, A2>(optic1: Fold<S, A>, optic2: Lens<A, T2, A2>): Fold<S, A2>;
export declare function compose<S, A, T2 extends OpticParams, A2>(optic1: Fold<S, A>, optic2: Prism<A, T2, A2>): Fold<S, A2>;
export declare function compose<S, A, T2 extends OpticParams, A2>(optic1: Fold<S, A>, optic2: Traversal<A, T2, A2>): Fold<S, A2>;
export declare function compose<S, A, A2>(optic1: Fold<S, A>, optic2: Getter<A, A2>): Fold<S, A2>;
export declare function compose<S, A, A2>(optic1: Fold<S, A>, optic2: AffineFold<A, A2>): Fold<S, A2>;
export declare function compose<S, A, A2>(optic1: Fold<S, A>, optic2: Fold<A, A2>): Fold<S, A2>;
export declare function optic<S>(): OpticFor<S>;
export declare function optic_<S>(): OpticFor_<S>;
export declare function get<S, A>(optic: Equivalence<S, any, A> | Iso<S, any, A> | Lens<S, any, A> | Getter<S, A>): (source: S) => A;
export declare function preview<S, A>(optic: Prism<S, any, A> | Traversal<S, any, A> | AffineFold<S, A> | Fold<S, A>): (source: S) => A | undefined;
export declare function collect<S, A>(optic: Prism<S, any, A> | Traversal<S, any, A> | Fold<S, A>): (source: S) => A[];
export declare function modify<S, T extends OpticParams, A>(optic: Equivalence<S, T, A> | Iso<S, T, A> | Lens<S, T, A> | Prism<S, T, A> | Traversal<S, T, A>): <B>(f: (a: A) => B) => (source: S) => Simplify<S, Apply<T['_T'], B>>;
export declare function set<S, T extends OpticParams, A>(optic: Equivalence<S, T, A> | Iso<S, T, A> | Lens<S, T, A> | Prism<S, T, A> | Traversal<S, T, A> | Setter<S, T, A>): <B>(value: B) => (source: S) => Simplify<S, Apply<T['_T'], B>>;
export declare function remove<S>(optic: Prism<S, Params<any, true>, any> | Traversal<S, Params<any, true>, any>): (source: S) => S;
export { pipe } from './standalone/pipe.js';
