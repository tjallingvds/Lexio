{"version":3,"sources":["../../src/react/IndentListPlugin.tsx","../../src/lib/BaseIndentListPlugin.ts","../../src/lib/renderIndentListBelowNodes.tsx","../../src/lib/types.ts","../../src/lib/withIndentList.ts","../../src/lib/normalizers/normalizeFirstIndentListStart.ts","../../src/lib/normalizers/normalizeIndentListNotIndented.ts","../../src/lib/normalizers/normalizeIndentListStart.ts","../../src/lib/queries/getNextIndentList.ts","../../src/lib/queries/getSiblingIndentList.ts","../../src/lib/queries/getPreviousIndentList.ts","../../src/lib/normalizers/withDeleteBackwardIndentList.ts","../../src/lib/transforms/indentList.ts","../../src/lib/transforms/outdentList.ts","../../src/lib/transforms/setIndentListNode.ts","../../src/lib/transforms/setIndentListNodes.ts","../../src/lib/transforms/setIndentListSiblingNodes.ts","../../src/lib/queries/getIndentListSiblings.ts","../../src/lib/transforms/toggleIndentList.ts","../../src/lib/queries/areEqListStyleType.ts","../../src/lib/transforms/toggleIndentListSet.ts","../../src/lib/transforms/toggleIndentListUnset.ts","../../src/lib/normalizers/withInsertBreakIndentList.ts","../../src/lib/withNormalizeIndentList.ts","../../src/lib/queries/someIndentList.ts","../../src/lib/queries/someIndentTodo.ts","../../src/react/onKeyDownIndentList.ts","../../src/react/hooks/useIndentListToolbarButton.ts","../../src/react/hooks/useIndentTodoListElement.ts","../../src/react/hooks/useIndentTodoToolbarButton.ts"],"sourcesContent":["import { toPlatePlugin } from '@udecode/plate/react';\n\nimport { type BaseIndentListConfig, BaseIndentListPlugin } from '../lib';\nimport { onKeyDownIndentList } from './onKeyDownIndentList';\n\nexport type IndentListConfig = BaseIndentListConfig;\n\n/** Enables support for indented lists with React-specific features. */\nexport const IndentListPlugin = toPlatePlugin(BaseIndentListPlugin, {\n  handlers: {\n    onKeyDown: onKeyDownIndentList,\n  },\n});\n","import {\n  type PluginConfig,\n  type SlateRenderElementProps,\n  type TElement,\n  BaseParagraphPlugin,\n  createTSlatePlugin,\n  HtmlPlugin,\n  isHtmlBlockElement,\n  postCleanHtml,\n  traverseHtmlElements,\n} from '@udecode/plate';\n\nimport type { GetSiblingIndentListOptions } from './queries/getSiblingIndentList';\nimport type { ListStyleType } from './types';\n\nimport { renderIndentListBelowNodes } from './renderIndentListBelowNodes';\nimport { withIndentList } from './withIndentList';\n\nexport const INDENT_LIST_KEYS = {\n  checked: 'checked',\n  listRestart: 'listRestart',\n  listStart: 'listStart',\n  todo: 'todo',\n} as const;\n\nexport type BaseIndentListConfig = PluginConfig<\n  'listStyleType',\n  {\n    getSiblingIndentListOptions?: GetSiblingIndentListOptions<TElement>;\n    listStyleTypes?: Record<\n      string,\n      {\n        type: string;\n        isOrdered?: boolean;\n        liComponent?: React.FC<SlateRenderElementProps>;\n        markerComponent?: React.FC<Omit<SlateRenderElementProps, 'children'>>;\n      }\n    >;\n    /** Map html element to list style type. */\n    getListStyleType?: (element: HTMLElement) => ListStyleType;\n  }\n>;\n\nexport const BaseIndentListPlugin = createTSlatePlugin<BaseIndentListConfig>({\n  key: 'listStyleType',\n  inject: {\n    plugins: {\n      [HtmlPlugin.key]: {\n        parser: {\n          transformData: ({ data }) => {\n            const document = new DOMParser().parseFromString(data, 'text/html');\n            const { body } = document;\n\n            traverseHtmlElements(body, (element) => {\n              if (element.tagName === 'LI') {\n                const { childNodes } = element;\n\n                // replace li block children (e.g. p) by their children\n                const liChildren: Node[] = [];\n                childNodes.forEach((child) => {\n                  if (isHtmlBlockElement(child as Element)) {\n                    liChildren.push(...child.childNodes);\n                  } else {\n                    liChildren.push(child);\n                  }\n                });\n\n                element.replaceChildren(...liChildren);\n\n                // TODO: recursive check on ul parents for indent\n\n                return false;\n              }\n\n              return true;\n            });\n\n            return postCleanHtml(body.innerHTML);\n          },\n        },\n      },\n    },\n  },\n  options: {\n    getListStyleType: (element) => element.style.listStyleType as ListStyleType,\n  },\n  parsers: {\n    html: {\n      deserializer: {\n        isElement: true,\n        rules: [\n          {\n            validNodeName: 'LI',\n          },\n        ],\n        parse: ({ editor, element, getOptions }) => {\n          return {\n            // gdoc uses aria-level attribute\n            indent: Number(element.getAttribute('aria-level')),\n            listStyleType: getOptions().getListStyleType?.(element),\n            type: editor.getType(BaseParagraphPlugin),\n          };\n        },\n      },\n    },\n  },\n  render: {\n    belowNodes: renderIndentListBelowNodes,\n  },\n}).overrideEditor(withIndentList);\n","import React from 'react';\n\nimport type {\n  RenderStaticNodeWrapper,\n  RenderStaticNodeWrapperFunction,\n  RenderStaticNodeWrapperProps,\n} from '@udecode/plate';\n\nimport { clsx } from 'clsx';\n\nimport {\n  type BaseIndentListConfig,\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../lib';\nimport { ULIST_STYLE_TYPES } from '../lib/types';\n\nexport const renderIndentListBelowNodes: RenderStaticNodeWrapper = (\n  injectProps: RenderStaticNodeWrapperProps<BaseIndentListConfig>\n): RenderStaticNodeWrapperFunction => {\n  const { element } = injectProps;\n\n  const listStyleType = element[BaseIndentListPlugin.key] as string;\n  const listStart = element[INDENT_LIST_KEYS.listStart] as number;\n\n  if (listStyleType) {\n    let className = clsx(`slate-${BaseIndentListPlugin.key}-${listStyleType}`);\n    const style: React.CSSProperties = {\n      listStyleType,\n      margin: 0,\n      padding: 0,\n      position: 'relative',\n    };\n\n    return ({ children, ...props }) => {\n      const { editor } = props;\n\n      const { listStyleTypes = {} } = editor.getOptions(BaseIndentListPlugin);\n\n      let listOptions = listStyleTypes[listStyleType];\n\n      let isOrdered = true;\n\n      if (listOptions) {\n        isOrdered = !!listOptions.isOrdered;\n      } else {\n        if (ULIST_STYLE_TYPES.includes(listStyleType as any)) {\n          isOrdered = false;\n        }\n\n        listOptions = {} as any;\n      }\n\n      className = isOrdered\n        ? clsx(className, 'slate-ol')\n        : clsx(className, 'slate-ul');\n\n      const List = isOrdered ? 'ol' : 'ul';\n\n      const { liComponent: Li, markerComponent: Marker = () => null } =\n        listOptions;\n\n      return (\n        <List className={className} style={style} start={listStart}>\n          <Marker {...props} />\n          {/* FIX: cursor position issue */}\n          {Li ? <Li {...props}>{children}</Li> : <li>{children}</li>}\n        </List>\n      );\n    };\n  }\n};\n","export enum ListStyleType {\n  ArabicIndic = 'arabic-indic',\n  Armenian = 'armenian',\n  Bengali = 'bengali',\n  Cambodian = 'cambodian',\n  Circle = 'circle',\n  CjkDecimal = 'cjk-decimal',\n  CjkEarthlyBranch = 'cjk-earthly-branch',\n  CjkHeavenlyStem = 'cjk-heavenly-stem',\n  Decimal = 'decimal',\n  DecimalLeadingZero = 'decimal-leading-zero',\n  Devanagari = 'devanagari',\n  Disc = 'disc',\n  DisclosureClosed = 'disclosure-closed',\n  DisclosureOpen = 'disclosure-open',\n  EthiopicNumeric = 'ethiopic-numeric',\n  Georgian = 'georgian',\n  Gujarati = 'gujarati',\n  Gurmukhi = 'gurmukhi',\n  Hebrew = 'hebrew',\n  Hiragana = 'hiragana',\n  HiraganaIroha = 'hiragana-iroha',\n  Inherit = 'inherit',\n  Initial = 'initial',\n  JapaneseFormal = 'japanese-formal',\n  JapaneseInformal = 'japanese-informal',\n  Kannada = 'kannada',\n  Katakana = 'katakana',\n  KatakanaIroha = 'katakana-iroha',\n  Khmer = 'khmer',\n  KoreanHangulFormal = 'korean-hangul-formal',\n  KoreanHanjaFormal = 'korean-hanja-formal',\n  KoreanHanjaInformal = 'korean-hanja-informal',\n  Lao = 'lao',\n  LowerAlpha = 'lower-alpha',\n  LowerArmenian = 'lower-armenian',\n  LowerGreek = 'lower-greek',\n  LowerLatin = 'lower-latin',\n  LowerRoman = 'lower-roman',\n  Malayalam = 'malayalam',\n  Mongolian = 'mongolian',\n  Myanmar = 'myanmar',\n  None = 'none',\n  Oriya = 'oriya',\n  Persian = 'persian',\n  SimpChineseFormal = 'simp-chinese-formal',\n  SimpChineseInformal = 'simp-chinese-informal',\n  Square = 'square',\n  Tamil = 'tamil',\n  Telugu = 'telugu',\n  Thai = 'thai',\n  Tibetan = 'tibetan',\n  TradChineseFormal = 'trad-chinese-formal',\n  TradChineseInformal = 'trad-chinese-informal',\n  UpperAlpha = 'upper-alpha',\n  UpperArmenian = 'upper-armenian',\n  UpperLatin = 'upper-latin',\n  UpperRoman = 'upper-roman',\n}\n\nexport const ULIST_STYLE_TYPES = [\n  ListStyleType.Disc,\n  ListStyleType.Circle,\n  ListStyleType.Square,\n  ListStyleType.DisclosureOpen,\n  ListStyleType.DisclosureClosed,\n] as const;\n","import {\n  type NodeEntry,\n  type OverrideEditor,\n  type Path,\n  type TElement,\n  type TNode,\n  PathApi,\n} from '@udecode/plate';\n\nimport {\n  type BaseIndentListConfig,\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from './BaseIndentListPlugin';\nimport {\n  withDeleteBackwardIndentList,\n  withInsertBreakIndentList,\n} from './normalizers';\nimport { normalizeIndentListStart } from './normalizers/normalizeIndentListStart';\nimport { getNextIndentList } from './queries/getNextIndentList';\nimport { getPreviousIndentList } from './queries/getPreviousIndentList';\nimport { ListStyleType } from './types';\nimport { withNormalizeIndentList } from './withNormalizeIndentList';\n\nexport const withIndentList: OverrideEditor<BaseIndentListConfig> = (ctx) => {\n  const {\n    editor,\n    getOptions,\n    tf: { apply },\n  } = ctx;\n\n  return {\n    transforms: {\n      ...withNormalizeIndentList(ctx).transforms,\n      ...withDeleteBackwardIndentList(ctx).transforms,\n      ...withInsertBreakIndentList(ctx).transforms,\n      apply(operation) {\n        const { getSiblingIndentListOptions } = getOptions();\n\n        /**\n         * If there is a previous indent list, the inserted indent list style\n         * type should be the same. Only for lower-roman and upper-roman as it\n         * overlaps with lower-alpha and upper-alpha.\n         */\n        if (operation.type === 'insert_node') {\n          const listStyleType = operation.node[BaseIndentListPlugin.key];\n\n          if (\n            listStyleType &&\n            ['lower-roman', 'upper-roman'].includes(\n              listStyleType as ListStyleType\n            )\n          ) {\n            const prevNodeEntry = getPreviousIndentList<TElement>(\n              editor,\n              [operation.node as TElement, operation.path],\n              {\n                breakOnEqIndentNeqListStyleType: false,\n                eqIndent: false,\n                ...getSiblingIndentListOptions,\n              }\n            );\n\n            if (prevNodeEntry) {\n              const prevListStyleType =\n                prevNodeEntry[0][BaseIndentListPlugin.key];\n\n              if (\n                prevListStyleType === ListStyleType.LowerAlpha &&\n                listStyleType === ListStyleType.LowerRoman\n              ) {\n                operation.node[BaseIndentListPlugin.key] =\n                  ListStyleType.LowerAlpha;\n              } else if (\n                prevListStyleType === ListStyleType.UpperAlpha &&\n                listStyleType === ListStyleType.UpperRoman\n              ) {\n                operation.node[BaseIndentListPlugin.key] =\n                  ListStyleType.UpperAlpha;\n              }\n            }\n          }\n        }\n\n        /**\n         * When inserting a line break, normalize listStart if the node has a\n         * listRestart property.\n         */\n        if (\n          operation.type === 'split_node' &&\n          (operation.properties as any)[BaseIndentListPlugin.key] &&\n          (operation.properties as any)[INDENT_LIST_KEYS.listRestart]\n        ) {\n          const listReStart = (operation.properties as any)[\n            INDENT_LIST_KEYS.listRestart\n          ];\n\n          (operation.properties as any)[INDENT_LIST_KEYS.listStart] =\n            listReStart + 1;\n          (operation.properties as any)[INDENT_LIST_KEYS.listRestart] =\n            undefined;\n        }\n\n        apply(operation);\n\n        // Normalize all list items affected by the operation\n        const affectedPaths: Path[] = [];\n\n        switch (operation.type) {\n          case 'insert_node':\n          case 'remove_node':\n          case 'set_node': {\n            affectedPaths.push(operation.path);\n            break;\n          }\n          case 'merge_node': {\n            affectedPaths.push(PathApi.previous(operation.path)!);\n            break;\n          }\n          case 'move_node': {\n            affectedPaths.push(operation.path, operation.newPath);\n            break;\n          }\n          case 'split_node': {\n            affectedPaths.push(operation.path, PathApi.next(operation.path));\n            break;\n          }\n        }\n\n        const isIndentListItem = (node: TNode) =>\n          BaseIndentListPlugin.key in node;\n\n        affectedPaths.forEach((affectedPath) => {\n          let entry = editor.api.node(affectedPath);\n          if (!entry) return;\n\n          /**\n           * Even if the affected node isn't a list item, the subsequent node\n           * might be, in which case we want to normalize that node instead.\n           */\n          if (!isIndentListItem(entry[0])) {\n            entry = editor.api.node(PathApi.next(affectedPath));\n          }\n\n          // Normalize the entire list from the affected node onwards\n          while (entry && isIndentListItem(entry[0])) {\n            const normalized = normalizeIndentListStart<TElement>(\n              editor,\n              entry as NodeEntry<TElement>,\n              getSiblingIndentListOptions\n            );\n\n            /**\n             * Break early since the subsequent list items will already have\n             * been normalized by the `apply` that modified the current node.\n             */\n            if (normalized) break;\n\n            entry = getNextIndentList<TElement>(\n              editor,\n              entry as NodeEntry<TElement>,\n              {\n                ...getSiblingIndentListOptions,\n                breakOnEqIndentNeqListStyleType: false,\n                breakOnLowerIndent: false,\n                eqIndent: false,\n              }\n            );\n          }\n        });\n      },\n    },\n  };\n};\n","import { type Editor, type NodeEntry, isDefined } from '@udecode/plate';\n\nimport { INDENT_LIST_KEYS } from '../BaseIndentListPlugin';\n\n/**\n * If there is no previous list item and node list start is defined, unset list\n * start (1).\n */\nexport const normalizeFirstIndentListStart = (\n  editor: Editor,\n  [node, path]: NodeEntry\n) => {\n  if (isDefined(node[INDENT_LIST_KEYS.listStart])) {\n    editor.tf.unsetNodes(INDENT_LIST_KEYS.listStart, { at: path });\n\n    return true;\n  }\n};\n","import { type Editor, type NodeEntry, isDefined } from '@udecode/plate';\nimport { BaseIndentPlugin } from '@udecode/plate-indent';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\n\n/** Unset IndentListPlugin.key, listStart if BaseIndentPlugin.key is not defined. */\nexport const normalizeIndentListNotIndented = (\n  editor: Editor,\n  [node, path]: NodeEntry\n) => {\n  if (\n    !isDefined(node[BaseIndentPlugin.key]) &&\n    (node[BaseIndentListPlugin.key] || node[INDENT_LIST_KEYS.listStart])\n  ) {\n    editor.tf.unsetNodes(\n      [BaseIndentListPlugin.key, INDENT_LIST_KEYS.listStart],\n      {\n        at: path,\n      }\n    );\n\n    return true;\n  }\n};\n","import {\n  type Editor,\n  type ElementEntryOf,\n  type ElementOf,\n  type NodeEntry,\n  NodeApi,\n} from '@udecode/plate';\n\nimport type { GetSiblingIndentListOptions } from '../queries/getSiblingIndentList';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport { getNextIndentList } from '../queries/getNextIndentList';\nimport { getPreviousIndentList } from '../queries/getPreviousIndentList';\nimport { normalizeFirstIndentListStart } from './normalizeFirstIndentListStart';\n\nexport const normalizeNextIndentListStart = (\n  editor: Editor,\n  entry: NodeEntry,\n  prevEntry?: NodeEntry\n) => {\n  const [node, path] = entry;\n  const [prevNode] = prevEntry ?? [null];\n\n  const prevListStart = (prevNode?.[INDENT_LIST_KEYS.listStart] as number) ?? 1;\n  const currListStart = (node[INDENT_LIST_KEYS.listStart] as number) ?? 1;\n  const restart = node[INDENT_LIST_KEYS.listRestart];\n  const listStart = restart == null ? prevListStart + 1 : restart;\n\n  if (currListStart !== listStart) {\n    editor.tf.setNodes(\n      { [INDENT_LIST_KEYS.listStart]: listStart },\n      { at: path }\n    );\n\n    return true;\n  }\n\n  return false;\n};\n\nexport const normalizeIndentListStart = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  entry: ElementEntryOf<E>,\n  options?: Partial<GetSiblingIndentListOptions<N, E>>\n) => {\n  return editor.tf.withoutNormalizing(() => {\n    const [node] = entry;\n    const listStyleType = (node as any)[BaseIndentListPlugin.key];\n\n    if (!listStyleType) return;\n\n    let normalized: boolean | undefined = false;\n\n    let prevEntry = getPreviousIndentList(editor, entry, options);\n\n    if (!prevEntry) {\n      normalized = normalizeFirstIndentListStart(editor, entry);\n\n      // if no prevEntry and not normalized, nothing happened: next should not be normalized\n      if (!normalized) return;\n    }\n\n    let normalizeNext = true;\n\n    let currEntry: ElementEntryOf<E> | undefined = entry;\n\n    // normalize next until current is not normalized\n    while (normalizeNext) {\n      normalizeNext =\n        normalizeNextIndentListStart(editor, currEntry, prevEntry) ||\n        normalized;\n\n      if (normalizeNext) normalized = true;\n\n      // get the node again after setNodes\n      prevEntry = [NodeApi.get<N>(editor, currEntry[1])!, currEntry[1]];\n      currEntry = getNextIndentList(editor, currEntry, options);\n\n      if (!currEntry) break;\n    }\n\n    return normalized;\n  });\n};\n","import {\n  type Editor,\n  type ElementEntryOf,\n  type ElementOf,\n  type NodeEntry,\n  NodeApi,\n  PathApi,\n} from '@udecode/plate';\n\nimport {\n  type GetSiblingIndentListOptions,\n  getSiblingIndentList,\n} from './getSiblingIndentList';\n\n/** Get the next indent list. */\nexport const getNextIndentList = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  entry: ElementEntryOf<E>,\n  options?: Partial<GetSiblingIndentListOptions<N, E>>\n): NodeEntry<N> | undefined => {\n  return getSiblingIndentList(editor, entry, {\n    getNextEntry: ([, currPath]) => {\n      const nextPath = PathApi.next(currPath);\n      const nextNode = NodeApi.get<N>(editor, nextPath);\n\n      if (!nextNode) return;\n\n      return [nextNode, nextPath];\n    },\n    ...options,\n    getPreviousEntry: undefined,\n  });\n};\n","import {\n  type Editor,\n  type ElementEntryOf,\n  type ElementOf,\n  type ElementOrTextOf,\n  type NodeEntry,\n  type TNode,\n  isDefined,\n} from '@udecode/plate';\nimport { BaseIndentPlugin } from '@udecode/plate-indent';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\n\nexport interface GetSiblingIndentListOptions<\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n> {\n  breakOnEqIndentNeqListStyleType?: boolean;\n  breakOnListRestart?: boolean;\n  breakOnLowerIndent?: boolean;\n  breakQuery?: (siblingNode: TNode, currentNode: TNode) => boolean | undefined;\n  getNextEntry?: (\n    entry: NodeEntry<ElementOrTextOf<E>>\n  ) => NodeEntry<N> | undefined;\n  getPreviousEntry?: (\n    entry: NodeEntry<ElementOrTextOf<E>>\n  ) => NodeEntry<N> | undefined;\n  /** Query to break lookup */\n  eqIndent?: boolean;\n  /** Query to validate lookup. If false, check the next sibling. */\n  query?: (siblingNode: TNode, currentNode: TNode) => boolean | undefined;\n}\n\n/**\n * Get the next sibling indent list node. Default query: the sibling node should\n * have the same listStyleType.\n */\nexport const getSiblingIndentList = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  [node, path]: ElementEntryOf<E>,\n  {\n    breakOnEqIndentNeqListStyleType = true,\n    breakOnListRestart = false,\n    breakOnLowerIndent = true,\n    breakQuery,\n    eqIndent = true,\n    getNextEntry,\n    getPreviousEntry,\n    query,\n  }: GetSiblingIndentListOptions<N, E>\n): NodeEntry<N> | undefined => {\n  if (!getPreviousEntry && !getNextEntry) return;\n\n  const getSiblingEntry = getNextEntry ?? getPreviousEntry!;\n\n  let nextEntry = getSiblingEntry([node, path]);\n\n  while (true) {\n    if (!nextEntry) return;\n\n    const [nextNode, nextPath] = nextEntry;\n\n    const indent = (node as any)[BaseIndentPlugin.key] as number;\n    const nextIndent = (nextNode as any)[BaseIndentPlugin.key] as number;\n\n    if (breakQuery?.(nextNode, node)) return;\n    if (!isDefined(nextIndent)) return;\n    if (breakOnListRestart) {\n      if (getPreviousEntry && (node as any)[INDENT_LIST_KEYS.listRestart]) {\n        return;\n      }\n      if (getNextEntry && (nextNode as any)[INDENT_LIST_KEYS.listRestart]) {\n        return;\n      }\n    }\n    if (breakOnLowerIndent && nextIndent < indent) return;\n    if (\n      breakOnEqIndentNeqListStyleType &&\n      nextIndent === indent &&\n      (nextNode as any)[BaseIndentListPlugin.key] !==\n        (node as any)[BaseIndentListPlugin.key]\n    )\n      return;\n\n    let valid = !query || query(nextNode, node);\n\n    if (valid) {\n      valid = !eqIndent || nextIndent === indent;\n\n      if (valid) return [nextNode, nextPath];\n    }\n\n    nextEntry = getSiblingEntry(nextEntry);\n  }\n};\n","import {\n  type Editor,\n  type ElementEntryOf,\n  type ElementOf,\n  type NodeEntry,\n  NodeApi,\n  PathApi,\n} from '@udecode/plate';\n\nimport {\n  type GetSiblingIndentListOptions,\n  getSiblingIndentList,\n} from './getSiblingIndentList';\n\n/** Get the previous indent list node. */\nexport const getPreviousIndentList = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  entry: ElementEntryOf<E>,\n  options?: Partial<GetSiblingIndentListOptions<N, E>>\n): NodeEntry<N> | undefined => {\n  return getSiblingIndentList(editor, entry, {\n    getPreviousEntry: ([, currPath]) => {\n      const prevPath = PathApi.previous(currPath);\n\n      if (!prevPath) return;\n\n      const prevNode = NodeApi.get<N>(editor, prevPath);\n\n      if (!prevNode) return;\n\n      return [prevNode, prevPath];\n    },\n    ...options,\n    getNextEntry: undefined,\n  });\n};\n","import { type OverrideEditor, isDefined, NodeApi } from '@udecode/plate';\n\nimport {\n  type BaseIndentListConfig,\n  BaseIndentListPlugin,\n} from '../BaseIndentListPlugin';\nimport { outdentList } from '../transforms';\n\nexport const withDeleteBackwardIndentList: OverrideEditor<\n  BaseIndentListConfig\n> = ({ editor, tf: { deleteBackward } }) => {\n  return {\n    transforms: {\n      deleteBackward(unit) {\n        const nodeEntry = editor.api.above();\n\n        if (!nodeEntry) return deleteBackward(unit);\n\n        const listNode = nodeEntry[0];\n\n        if (editor.api.isCollapsed() && NodeApi.string(listNode))\n          return deleteBackward(unit);\n        if (isDefined(listNode[BaseIndentListPlugin.key])) {\n          return outdentList(editor);\n        }\n\n        return deleteBackward(unit);\n      },\n    },\n  };\n};\n","import type { SlateEditor, TLocation } from '@udecode/plate';\n\nimport { setIndent } from '@udecode/plate-indent';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport { ListStyleType } from '../types';\n\nexport interface IndentListOptions {\n  at?: TLocation;\n  listStyleType?: ListStyleType | string;\n}\n\n/** Increase the indentation of the selected blocks. */\nexport const indentList = (\n  editor: SlateEditor,\n  { listStyleType = ListStyleType.Disc, ...options }: IndentListOptions = {}\n) => {\n  setIndent(editor, {\n    offset: 1,\n    setNodesProps: () => ({\n      [BaseIndentListPlugin.key]: listStyleType,\n    }),\n    ...options,\n  });\n};\n\nexport const indentTodo = (\n  editor: SlateEditor,\n  { listStyleType = ListStyleType.Disc, ...options }: IndentListOptions = {}\n) => {\n  setIndent(editor, {\n    offset: 1,\n    setNodesProps: () => ({\n      [BaseIndentListPlugin.key]: listStyleType,\n      [INDENT_LIST_KEYS.checked]: false,\n    }),\n    ...options,\n  });\n};\n","import type { SlateEditor } from '@udecode/plate';\n\nimport { setIndent } from '@udecode/plate-indent';\n\nimport type { IndentListOptions } from './indentList';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\n\n/** Decrease the indentation of the selected blocks. */\nexport const outdentList = (\n  editor: SlateEditor,\n  options: IndentListOptions = {}\n) => {\n  setIndent(editor, {\n    offset: -1,\n    unsetNodesProps: [BaseIndentListPlugin.key, INDENT_LIST_KEYS.checked],\n    ...options,\n  });\n};\n","import type { Editor, Path } from '@udecode/plate';\n\nimport { BaseIndentPlugin } from '@udecode/plate-indent';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport { ListStyleType } from '../types';\n\nexport const setIndentListNode = (\n  editor: Editor,\n  {\n    at,\n    indent = 0,\n    listStyleType = ListStyleType.Disc,\n  }: {\n    at: Path;\n    indent?: number;\n    listStyleType?: string;\n  }\n) => {\n  const newIndent = indent || indent + 1;\n\n  editor.tf.setNodes(\n    {\n      [BaseIndentListPlugin.key]: listStyleType,\n      [BaseIndentPlugin.key]: newIndent,\n    },\n    { at }\n  );\n};\n\nexport const setIndentTodoNode = (\n  editor: Editor,\n  {\n    at,\n    indent = 0,\n    listStyleType = INDENT_LIST_KEYS.todo,\n  }: {\n    at: Path;\n    indent?: number;\n    listStyleType?: string;\n  }\n) => {\n  const newIndent = indent || indent + 1;\n\n  editor.tf.setNodes(\n    {\n      [BaseIndentListPlugin.key]: listStyleType,\n      [BaseIndentPlugin.key]: newIndent,\n      [INDENT_LIST_KEYS.checked]: false,\n    },\n    { at }\n  );\n};\n","import type { Editor, NodeEntry } from '@udecode/plate';\n\nimport { BaseIndentPlugin } from '@udecode/plate-indent';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport { ListStyleType } from '../types';\nimport { setIndentListNode, setIndentTodoNode } from './setIndentListNode';\n\n/**\n * Set indent list to the given entries. Add indent if listStyleType was not\n * defined.\n */\nexport const setIndentListNodes = (\n  editor: Editor,\n  entries: NodeEntry[],\n  {\n    listStyleType = ListStyleType.Disc,\n  }: {\n    listStyleType?: string;\n  }\n) => {\n  editor.tf.withoutNormalizing(() => {\n    entries.forEach((entry) => {\n      const [node, path] = entry;\n\n      let indent = (node[BaseIndentPlugin.key] as number) ?? 0;\n      indent =\n        node[BaseIndentListPlugin.key] ||\n        node.hasOwnProperty(INDENT_LIST_KEYS.checked)\n          ? indent\n          : indent + 1;\n\n      if (listStyleType === 'todo') {\n        editor.tf.unsetNodes(BaseIndentListPlugin.key, { at: path });\n        setIndentTodoNode(editor, {\n          at: path,\n          indent,\n          listStyleType,\n        });\n\n        return;\n      }\n\n      editor.tf.unsetNodes(INDENT_LIST_KEYS.checked, { at: path });\n      setIndentListNode(editor, {\n        at: path,\n        indent,\n        listStyleType,\n      });\n    });\n  });\n};\n","import type { Editor, ElementEntryOf, ElementOf } from '@udecode/plate';\n\nimport { BaseIndentPlugin } from '@udecode/plate-indent';\n\nimport type { GetSiblingIndentListOptions } from '../queries/getSiblingIndentList';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport { getIndentListSiblings } from '../queries/getIndentListSiblings';\nimport { ListStyleType } from '../types';\nimport { setIndentListNode, setIndentTodoNode } from './setIndentListNode';\n\n/** Set indent list to entry + siblings. */\nexport const setIndentListSiblingNodes = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  entry: ElementEntryOf<E>,\n  {\n    getSiblingIndentListOptions,\n    listStyleType = ListStyleType.Disc,\n  }: {\n    getSiblingIndentListOptions?: GetSiblingIndentListOptions<N, E>;\n    listStyleType?: string;\n  }\n) => {\n  editor.tf.withoutNormalizing(() => {\n    const siblings = getIndentListSiblings(\n      editor,\n      entry,\n      getSiblingIndentListOptions\n    );\n\n    siblings.forEach(([node, path]) => {\n      if (listStyleType === INDENT_LIST_KEYS.todo) {\n        editor.tf.unsetNodes(BaseIndentListPlugin.key, { at: path });\n        setIndentTodoNode(editor, {\n          at: path,\n          indent: node[BaseIndentPlugin.key] as number,\n          listStyleType,\n        });\n      } else {\n        editor.tf.unsetNodes(INDENT_LIST_KEYS.checked, { at: path });\n        setIndentListNode(editor, {\n          at: path,\n          indent: node[BaseIndentPlugin.key] as number,\n          listStyleType,\n        });\n      }\n    });\n  });\n};\n","import type {\n  Editor,\n  ElementEntryOf,\n  ElementOf,\n  NodeEntry,\n  TElement,\n} from '@udecode/plate';\n\nimport type { GetSiblingIndentListOptions } from './getSiblingIndentList';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport { getNextIndentList } from './getNextIndentList';\nimport { getPreviousIndentList } from './getPreviousIndentList';\n\nexport interface GetIndentListSiblingsOptions<\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n> extends Partial<GetSiblingIndentListOptions<N, E>> {\n  current?: boolean;\n  next?: boolean;\n  previous?: boolean;\n}\n\nexport const getIndentListSiblings = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  entry: ElementEntryOf<E>,\n  {\n    current = true,\n    next = true,\n    previous = true,\n    ...options\n  }: GetIndentListSiblingsOptions<N, E> = {}\n) => {\n  const siblings: NodeEntry[] = [];\n\n  const node = entry[0] as TElement;\n\n  // if (!(node as any)[IndentListPlugin.key]) return siblings;\n  if (\n    !node[BaseIndentListPlugin.key] &&\n    !node.hasOwnProperty(INDENT_LIST_KEYS.checked)\n  ) {\n    return siblings;\n  }\n\n  let iterEntry = entry;\n\n  if (previous) {\n    while (true) {\n      const prevEntry = getPreviousIndentList<N, E>(editor, iterEntry, options);\n\n      if (!prevEntry) break;\n\n      siblings.push(prevEntry);\n\n      iterEntry = prevEntry;\n    }\n  }\n  if (current) {\n    siblings.push(entry);\n  }\n  if (next) {\n    iterEntry = entry;\n\n    while (true) {\n      const nextEntry = getNextIndentList(editor, iterEntry, options);\n\n      if (!nextEntry) break;\n\n      siblings.push(nextEntry);\n\n      iterEntry = nextEntry;\n    }\n  }\n\n  return siblings;\n};\n","import type {\n  ElementEntryOf,\n  ElementOf,\n  SlateEditor,\n  TElement,\n} from '@udecode/plate';\n\nimport { BaseIndentPlugin } from '@udecode/plate-indent';\n\nimport type { GetSiblingIndentListOptions } from '../queries';\nimport type { IndentListOptions } from './indentList';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport { areEqListStyleType } from '../queries/areEqListStyleType';\nimport { setIndentListNodes } from './setIndentListNodes';\nimport { setIndentListSiblingNodes } from './setIndentListSiblingNodes';\nimport { toggleIndentListSet } from './toggleIndentListSet';\nimport { toggleIndentListUnset } from './toggleIndentListUnset';\n\n/** Toggle indent list. */\nexport const toggleIndentList = <\n  N extends ElementOf<E>,\n  E extends SlateEditor = SlateEditor,\n>(\n  editor: E,\n  options: IndentListOptions,\n  getSiblingIndentListOptions?: GetSiblingIndentListOptions<N, E>\n) => {\n  const { listStyleType } = options;\n\n  const { getSiblingIndentListOptions: _getSiblingIndentListOptions } =\n    editor.getOptions(BaseIndentListPlugin);\n\n  if (editor.api.isCollapsed()) {\n    const entry = editor.api.block<TElement>();\n\n    if (!entry) return;\n    if (toggleIndentListSet(editor, entry, { listStyleType })) {\n      return;\n    }\n    if (toggleIndentListUnset(editor, entry, { listStyleType })) {\n      return;\n    }\n\n    setIndentListSiblingNodes(editor, entry as ElementEntryOf<E>, {\n      getSiblingIndentListOptions: {\n        ..._getSiblingIndentListOptions,\n        ...getSiblingIndentListOptions,\n      } as GetSiblingIndentListOptions<ElementOf<E>, E>,\n      listStyleType,\n    });\n\n    return;\n  }\n  if (editor.api.isExpanded()) {\n    const _entries = editor.api.nodes<TElement>({ block: true });\n    const entries = [..._entries];\n\n    const eqListStyleType = areEqListStyleType(editor, entries, {\n      listStyleType,\n    });\n\n    if (eqListStyleType) {\n      editor.tf.withoutNormalizing(() => {\n        entries.forEach((entry) => {\n          const [node, path] = entry;\n\n          const indent = node[BaseIndentPlugin.key] as number;\n\n          editor.tf.unsetNodes(BaseIndentListPlugin.key, { at: path });\n\n          if (indent > 1) {\n            editor.tf.setNodes(\n              { [BaseIndentPlugin.key]: indent - 1 },\n              { at: path }\n            );\n          } else {\n            editor.tf.unsetNodes(\n              [BaseIndentPlugin.key, INDENT_LIST_KEYS.checked],\n              {\n                at: path,\n              }\n            );\n          }\n          // setIndentListNode(editor, {\n          //   listStyleType,\n          //   indent: node[BaseIndentPlugin.key],\n          //   at: path,\n          // });\n        });\n      });\n\n      return;\n    }\n\n    setIndentListNodes(editor, entries, { listStyleType });\n  }\n};\n","import type { Editor, NodeEntry } from '@udecode/plate';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport { ListStyleType } from '../types';\n\nexport const areEqListStyleType = (\n  editor: Editor,\n  entries: NodeEntry[],\n  {\n    listStyleType = ListStyleType.Disc,\n  }: {\n    listStyleType?: string;\n  }\n) => {\n  let eqListStyleType = true;\n\n  for (const entry of entries) {\n    const [block] = entry;\n\n    if (listStyleType === INDENT_LIST_KEYS.todo) {\n      if (!block.hasOwnProperty(INDENT_LIST_KEYS.checked)) {\n        eqListStyleType = false;\n\n        break;\n      }\n\n      continue;\n    }\n    if (\n      !block[BaseIndentListPlugin.key] ||\n      block[BaseIndentListPlugin.key] !== listStyleType\n    ) {\n      eqListStyleType = false;\n\n      break;\n    }\n  }\n\n  return eqListStyleType;\n};\n","import type { Editor, NodeEntry } from '@udecode/plate';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport { ListStyleType } from '../types';\nimport { type IndentListOptions, indentList, indentTodo } from './indentList';\n\n/** Set indent list if not set. */\nexport const toggleIndentListSet = (\n  editor: Editor,\n  [node, _path]: NodeEntry,\n  { listStyleType = ListStyleType.Disc, ...options }: IndentListOptions\n) => {\n  if (\n    node.hasOwnProperty(INDENT_LIST_KEYS.checked) ||\n    node[BaseIndentListPlugin.key]\n  )\n    return;\n  if (listStyleType === 'todo') {\n    indentTodo(editor as any, {\n      listStyleType,\n      ...options,\n    });\n  } else {\n    indentList(editor as any, {\n      listStyleType,\n      ...options,\n    });\n  }\n\n  return true;\n};\n","import type { Editor, NodeEntry } from '@udecode/plate';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport { ListStyleType } from '../types';\nimport { outdentList } from './outdentList';\n\n/** Unset list style type if already set. */\nexport const toggleIndentListUnset = (\n  editor: Editor,\n  [node, path]: NodeEntry,\n  {\n    listStyleType = ListStyleType.Disc,\n  }: {\n    listStyleType?: string;\n  }\n) => {\n  if (\n    listStyleType === INDENT_LIST_KEYS.todo &&\n    node.hasOwnProperty(INDENT_LIST_KEYS.checked)\n  ) {\n    editor.tf.unsetNodes(INDENT_LIST_KEYS.checked, { at: path });\n    outdentList(editor as any, { listStyleType });\n\n    return true;\n  }\n  if (listStyleType === node[BaseIndentListPlugin.key]) {\n    editor.tf.unsetNodes([BaseIndentListPlugin.key], {\n      at: path,\n    });\n\n    outdentList(editor as any, { listStyleType });\n\n    return true;\n  }\n};\n","import { type OverrideEditor, type TElement, isDefined } from '@udecode/plate';\n\nimport {\n  type BaseIndentListConfig,\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\n\nexport const withInsertBreakIndentList: OverrideEditor<\n  BaseIndentListConfig\n> = ({ editor, tf: { insertBreak } }) => {\n  return {\n    transforms: {\n      insertBreak() {\n        const nodeEntry = editor.api.above();\n\n        if (!nodeEntry) return insertBreak();\n\n        const [node, path] = nodeEntry;\n\n        if (\n          !isDefined(node[BaseIndentListPlugin.key]) ||\n          node[BaseIndentListPlugin.key] !== INDENT_LIST_KEYS.todo ||\n          editor.api.isExpanded() ||\n          !editor.api.isEnd(editor.selection?.focus, path)\n        ) {\n          return insertBreak();\n        }\n\n        editor.tf.withoutNormalizing(() => {\n          insertBreak();\n\n          const newEntry = editor.api.above<TElement>();\n\n          if (newEntry) {\n            editor.tf.setNodes(\n              {\n                checked: false,\n              },\n              { at: newEntry[1] }\n            );\n          }\n        });\n      },\n    },\n  };\n};\n","import type { OverrideEditor, TElement } from '@udecode/plate';\n\nimport type { BaseIndentListConfig } from './BaseIndentListPlugin';\n\nimport { normalizeIndentListNotIndented } from './normalizers/normalizeIndentListNotIndented';\nimport { normalizeIndentListStart } from './normalizers/normalizeIndentListStart';\n\nexport const withNormalizeIndentList: OverrideEditor<BaseIndentListConfig> = ({\n  editor,\n  getOptions,\n  tf: { normalizeNode },\n}) => {\n  return {\n    transforms: {\n      normalizeNode([node, path]) {\n        const normalized = editor.tf.withoutNormalizing(() => {\n          if (normalizeIndentListNotIndented(editor, [node, path])) return true;\n          if (\n            normalizeIndentListStart(\n              editor,\n              [node as TElement, path],\n              getOptions().getSiblingIndentListOptions\n            )\n          )\n            return true;\n        });\n\n        if (normalized) return;\n\n        return normalizeNode([node, path]);\n      },\n    },\n  };\n};\n","import type { SlateEditor } from '@udecode/plate';\n\nimport { BaseIndentListPlugin, INDENT_LIST_KEYS } from '../../index';\n\nexport const someIndentList = (\n  editor: SlateEditor,\n  type: string[] | string\n) => {\n  return (\n    !!editor.selection &&\n    editor.api.some({\n      match: (n: any) => {\n        const isHasProperty = n.hasOwnProperty(INDENT_LIST_KEYS.checked);\n\n        if (isHasProperty) {\n          return false;\n        }\n\n        const list = n[BaseIndentListPlugin.key];\n\n        return Array.isArray(type) ? type.includes(list) : list === type;\n      },\n    })\n  );\n};\n","import type { SlateEditor } from '@udecode/plate';\n\nimport { BaseIndentListPlugin, INDENT_LIST_KEYS } from '../../index';\n\nexport const someIndentTodo = (editor: SlateEditor) => {\n  return editor.api.some({\n    at: editor.selection!,\n    match: (n) => {\n      const list = n[BaseIndentListPlugin.key];\n      const isHasProperty = n.hasOwnProperty(INDENT_LIST_KEYS.checked);\n\n      return n.type === 'p' && isHasProperty && list === INDENT_LIST_KEYS.todo;\n    },\n  });\n};\n","import type { KeyboardHandler } from '@udecode/plate/react';\n\nimport { type TElement, isHotkey } from '@udecode/plate';\n\nimport { outdentList } from '../lib';\nimport { type IndentListConfig, IndentListPlugin } from './IndentListPlugin';\n\nexport const onKeyDownIndentList: KeyboardHandler<IndentListConfig> = ({\n  editor,\n  event,\n}) => {\n  if (event.defaultPrevented) return;\n  if (!editor.selection) return;\n\n  const entry = editor.api.block();\n\n  if (!entry) return;\n\n  const node = entry[0] as TElement;\n\n  const listStyleType = node[IndentListPlugin.key] as string | undefined;\n\n  if (!listStyleType) return;\n  if (\n    isHotkey('Enter', event) &&\n    editor.api.isEmpty(editor.selection, { block: true }) &&\n    node.indent\n  ) {\n    outdentList(editor);\n    event.stopPropagation();\n    event.preventDefault();\n  }\n};\n","import { useEditorRef, useEditorSelector } from '@udecode/plate/react';\n\nimport { ListStyleType, toggleIndentList } from '../../index';\nimport { someIndentList } from '../../lib/queries/someIndentList';\n\nexport const useIndentListToolbarButtonState = ({\n  nodeType = ListStyleType.Disc,\n}: { nodeType?: string } = {}) => {\n  const pressed = useEditorSelector(\n    (editor) => someIndentList(editor, nodeType),\n    [nodeType]\n  );\n\n  return {\n    nodeType,\n    pressed,\n  };\n};\n\nexport const useIndentListToolbarButton = ({\n  nodeType,\n  pressed,\n}: ReturnType<typeof useIndentListToolbarButtonState>) => {\n  const editor = useEditorRef();\n\n  return {\n    props: {\n      pressed,\n      onClick: () => {\n        toggleIndentList(editor, {\n          listStyleType: nodeType,\n        });\n      },\n      onMouseDown: (e: React.MouseEvent<HTMLButtonElement>) => {\n        e.preventDefault();\n      },\n    },\n  };\n};\n","import type { TElement } from '@udecode/plate';\n\nimport { useEditorRef, useReadOnly } from '@udecode/plate/react';\n\nexport const useIndentTodoListElementState = ({\n  element,\n}: {\n  element: TElement;\n}) => {\n  const editor = useEditorRef();\n  const { checked } = element;\n  const readOnly = useReadOnly();\n\n  return {\n    checked,\n    editor,\n    element,\n    readOnly,\n  };\n};\n\nexport const useIndentTodoListElement = (\n  state: ReturnType<typeof useIndentTodoListElementState>\n) => {\n  const { checked, editor, element, readOnly } = state;\n\n  return {\n    checkboxProps: {\n      checked: !!checked,\n      onCheckedChange: (value: boolean) => {\n        if (readOnly) return;\n\n        const path = editor.api.findPath(element);\n\n        if (!path) return;\n\n        editor.tf.setNodes({ checked: value }, { at: path });\n      },\n      onMouseDown: (e: any) => {\n        e.preventDefault();\n      },\n    },\n  };\n};\n","import { useEditorRef, useEditorSelector } from '@udecode/plate/react';\n\nimport { ListStyleType, toggleIndentList } from '../../index';\nimport { someIndentTodo } from '../../lib/queries/someIndentTodo';\n\nexport const useIndentTodoToolBarButtonState = ({\n  nodeType = ListStyleType.Disc,\n}: { nodeType?: string } = {}) => {\n  const pressed = useEditorSelector(\n    (editor) => someIndentTodo(editor),\n    [nodeType]\n  );\n\n  return {\n    nodeType,\n    pressed,\n  };\n};\n\nexport const useIndentTodoToolBarButton = ({\n  nodeType,\n  pressed,\n}: ReturnType<typeof useIndentTodoToolBarButtonState>) => {\n  const editor = useEditorRef();\n\n  return {\n    props: {\n      pressed,\n      onClick: () => {\n        toggleIndentList(editor, {\n          listStyleType: nodeType,\n        });\n      },\n      onMouseDown: (e: React.MouseEvent<HTMLButtonElement>) => {\n        e.preventDefault();\n      },\n    },\n  };\n};\n"],"mappings":"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","names":["PathApi","isDefined","isDefined","NodeApi","isDefined","BaseIndentPlugin","BaseIndentPlugin","isDefined","NodeApi","PathApi","PathApi","NodeApi","NodeApi","isDefined","NodeApi","setIndent","setIndent","BaseIndentPlugin","BaseIndentPlugin","BaseIndentPlugin","BaseIndentPlugin","BaseIndentPlugin","BaseIndentPlugin","BaseIndentPlugin","BaseIndentPlugin","NodeApi","isDefined","isDefined","isDefined","PathApi","useEditorRef","useEditorRef","useEditorSelector","useEditorSelector","useEditorRef"]}