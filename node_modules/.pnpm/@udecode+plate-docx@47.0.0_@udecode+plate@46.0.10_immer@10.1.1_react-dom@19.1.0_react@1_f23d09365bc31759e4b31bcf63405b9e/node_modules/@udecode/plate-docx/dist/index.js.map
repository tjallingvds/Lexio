{"version":3,"sources":["../src/index.ts","../src/lib/DocxPlugin.ts","../src/lib/docx-cleaner/cleanDocx.ts","../src/lib/docx-cleaner/utils/cleanDocxBrComments.ts","../src/lib/docx-cleaner/utils/cleanDocxEmptyParagraphs.ts","../src/lib/docx-cleaner/utils/cleanDocxFootnotes.ts","../src/lib/docx-cleaner/utils/isDocxFootnote.ts","../src/lib/docx-cleaner/utils/cleanDocxImageElements.ts","../src/lib/docx-cleaner/utils/getRtfImageHex.ts","../src/lib/docx-cleaner/utils/getRtfImageMimeType.ts","../src/lib/docx-cleaner/utils/getRtfImageSpid.ts","../src/lib/docx-cleaner/utils/getRtfImagesByType.ts","../src/lib/docx-cleaner/utils/getRtfImagesMap.ts","../src/lib/docx-cleaner/utils/getVShapes.ts","../src/lib/docx-cleaner/utils/getVShapeSpid.ts","../src/lib/docx-cleaner/utils/cleanDocxListElements.ts","../src/lib/docx-cleaner/utils/cleanDocxListElementsToList.ts","../src/lib/docx-cleaner/utils/docxListToList.ts","../src/lib/docx-cleaner/utils/getDocxListContentHtml.ts","../src/lib/docx-cleaner/utils/getDocxListIndent.ts","../src/lib/docx-cleaner/utils/isDocxBookmark.ts","../src/lib/docx-cleaner/utils/isDocxList.ts","../src/lib/docx-cleaner/utils/isDocxOl.ts","../src/lib/docx-cleaner/utils/getDocxListNode.ts","../src/lib/docx-cleaner/utils/cleanDocxQuotes.ts","../src/lib/docx-cleaner/utils/generateSpaces.ts","../src/lib/docx-cleaner/utils/cleanDocxSpacerun.ts","../src/lib/docx-cleaner/utils/cleanDocxSpans.ts","../src/lib/docx-cleaner/utils/cleanDocxTabCount.ts","../src/lib/docx-cleaner/utils/getDocxIndent.ts","../src/lib/docx-cleaner/utils/getTextListStyleType.ts","../src/lib/docx-cleaner/utils/isDocxContent.ts"],"sourcesContent":["/**\n * @file Automatically generated by barrelsby.\n */\n\nexport * from './lib/index';\n","import {\n  type HtmlDeserializer,\n  type SlatePlugin,\n  createSlatePlugin,\n  HtmlPlugin,\n} from '@udecode/plate';\n\nimport { cleanDocx } from './docx-cleaner/cleanDocx';\nimport {\n  getDocxIndent,\n  getDocxTextIndent,\n} from './docx-cleaner/utils/getDocxIndent';\nimport { getDocxListContentHtml } from './docx-cleaner/utils/getDocxListContentHtml';\nimport { getDocxListIndent } from './docx-cleaner/utils/getDocxListIndent';\nimport { getTextListStyleType } from './docx-cleaner/utils/getTextListStyleType';\nimport { isDocxContent } from './docx-cleaner/utils/isDocxContent';\nimport { isDocxList } from './docx-cleaner/utils/isDocxList';\n\nconst parse: HtmlDeserializer['parse'] = ({ element, type }) => {\n  const node: any = { type };\n\n  if (isDocxList(element)) {\n    node.indent = getDocxListIndent(element);\n\n    const text = element.textContent ?? '';\n\n    node.listStyleType = getTextListStyleType(text) ?? 'disc';\n\n    element.innerHTML = getDocxListContentHtml(element);\n  } else {\n    const indent = getDocxIndent(element);\n\n    if (indent) {\n      node.indent = indent;\n    }\n\n    const textIndent = getDocxTextIndent(element);\n\n    if (textIndent) {\n      node.textIndent = textIndent;\n    }\n  }\n\n  return node;\n};\n\nexport const DocxPlugin = createSlatePlugin({\n  key: 'docx',\n  inject: {\n    plugins: {\n      [HtmlPlugin.key]: {\n        parser: {\n          transformData: ({ data, dataTransfer }) => {\n            const rtf = dataTransfer.getData('text/rtf');\n\n            return cleanDocx(data, rtf);\n          },\n        },\n      },\n    },\n  },\n  override: {\n    plugins: {\n      ...Object.fromEntries(\n        ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'].map((key) => [\n          key,\n          {\n            parsers: {\n              html: {\n                deserializer: {\n                  parse,\n                },\n              },\n            },\n          } satisfies Partial<SlatePlugin>,\n        ])\n      ),\n      img: {\n        parser: {\n          query: ({ dataTransfer }) => {\n            const data = dataTransfer.getData('text/html');\n            const { body } = new DOMParser().parseFromString(data, 'text/html');\n\n            return !isDocxContent(body);\n          },\n        },\n      },\n    },\n  },\n});\n","import {\n  cleanHtmlBrElements,\n  cleanHtmlEmptyElements,\n  cleanHtmlFontElements,\n  cleanHtmlLinkElements,\n  cleanHtmlTextNodes,\n  copyBlockMarksToSpanChild,\n  postCleanHtml,\n  preCleanHtml,\n} from '@udecode/plate';\n\nimport {\n  cleanDocxBrComments,\n  cleanDocxEmptyParagraphs,\n  cleanDocxFootnotes,\n  cleanDocxImageElements,\n  cleanDocxListElements,\n  cleanDocxQuotes,\n  cleanDocxSpans,\n  isDocxContent,\n} from './utils/index';\n\nexport const cleanDocx = (html: string, rtf: string): string => {\n  const document = new DOMParser().parseFromString(\n    preCleanHtml(html),\n    'text/html'\n  );\n  const { body } = document;\n\n  if (!rtf && !isDocxContent(body)) {\n    return html;\n  }\n\n  cleanDocxFootnotes(body);\n  cleanDocxImageElements(document, rtf, body);\n  cleanHtmlEmptyElements(body);\n  cleanDocxEmptyParagraphs(body);\n  cleanDocxQuotes(body);\n  cleanDocxSpans(body);\n  cleanHtmlTextNodes(body);\n  cleanDocxBrComments(body);\n  cleanHtmlBrElements(body);\n  cleanHtmlLinkElements(body);\n  cleanHtmlFontElements(body);\n  cleanDocxListElements(body);\n  copyBlockMarksToSpanChild(body);\n\n  // Prevent deserializeHtml from collapsing whitespace\n  const preformattedWrapper = document.createElement('div');\n  preformattedWrapper.style.whiteSpace = 'pre-wrap';\n  preformattedWrapper.innerHTML = body.innerHTML;\n\n  return postCleanHtml(preformattedWrapper.outerHTML);\n};\n","import {\n  isHtmlComment,\n  removeHtmlNodesBetweenComments,\n  traverseHtmlElements,\n} from '@udecode/plate';\n\n/** Remove HTML nodes between comments in the next sibling after BR. */\nexport const cleanDocxBrComments = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.tagName !== 'BR') {\n      return true;\n    }\n    if (\n      element.nextSibling &&\n      isHtmlComment(element.nextSibling) &&\n      element.nextSibling.data === '[if !supportLineBreakNewLine]'\n    ) {\n      removeHtmlNodesBetweenComments(\n        element.nextSibling,\n        '[if !supportLineBreakNewLine]',\n        '[endif]'\n      );\n    }\n\n    return false;\n  });\n};\n","import { NO_BREAK_SPACE, traverseHtmlElements } from '@udecode/plate';\n\nconst isHtmlOpEmpty = (element: Element): boolean =>\n  element.nodeName === 'O:P' && element.textContent === NO_BREAK_SPACE;\n\nconst isHtmlElementEmpty = (element: Element): boolean =>\n  element.children.length === 1 &&\n  element.firstElementChild !== null &&\n  (isHtmlOpEmpty(element.firstElementChild) ||\n    isHtmlElementEmpty(element.firstElementChild));\n\n/** Remove paragraph innerHTML if its child is 'O:P' with NO_BREAK_SPACE. */\nexport const cleanDocxEmptyParagraphs = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.tagName === 'P' && isHtmlElementEmpty(element)) {\n      element.innerHTML = '';\n    }\n\n    return true;\n  });\n};\n","import { traverseHtmlElements } from '@udecode/plate';\n\nimport { isDocxFootnote } from './isDocxFootnote';\n\n/** Gets \"4\" from \"[4]\", \"A\" from \"[A]\", etc. */\nconst extractFootnoteNumber = (footnote: Element): string => {\n  return (footnote.textContent || '').trim().replaceAll(/[[\\]]/g, '');\n};\n\n/** Replace docx footnotes with sup element. */\nexport const cleanDocxFootnotes = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (isDocxFootnote(element)) {\n      const footnoteReplacement = document.createElement('sup');\n      footnoteReplacement.textContent = extractFootnoteNumber(element);\n\n      if (element.parentElement) {\n        element.parentElement.replaceChild(footnoteReplacement, element);\n      }\n\n      return true;\n    }\n\n    return true;\n  });\n};\n","/** Is element a docx footnote. */\nexport const isDocxFootnote = (element: Element): boolean => {\n  return (\n    element.tagName === 'SPAN' &&\n    element.classList.contains('MsoFootnoteReference')\n  );\n};\n","import { hexToBase64, traverseHtmlElements } from '@udecode/plate';\nimport validator from 'validator';\n\nimport { getRtfImagesMap } from './getRtfImagesMap';\nimport { getVShapeSpid } from './getVShapeSpid';\n\n/** Clean docx image elements. */\nexport const cleanDocxImageElements = (\n  document: Document,\n  rtf: string,\n  rootNode: Node\n): void => {\n  if (!rtf) {\n    return;\n  }\n\n  traverseHtmlElements(rootNode, (element) => {\n    if (!['IMG', 'V:IMAGEDATA'].includes(element.tagName)) {\n      return true;\n    }\n    if (element.tagName === 'IMG') {\n      const src = element.getAttribute('src');\n\n      if (!src?.startsWith('file://')) {\n        return true;\n      }\n\n      const alt = element.getAttribute('alt');\n\n      if (\n        typeof alt === 'string' &&\n        validator.isURL(alt, { require_protocol: true })\n      ) {\n        element.setAttribute('src', alt);\n\n        return true;\n      }\n    }\n\n    const vShapeSpid = getVShapeSpid(document, element);\n\n    if (!vShapeSpid) {\n      return true;\n    }\n\n    const rtfImagesMap = getRtfImagesMap(rtf);\n    const rtfImage = rtfImagesMap[vShapeSpid];\n\n    if (!rtfImage) {\n      // We fould some kind of vshape (perhaps a drawing) that we don't know\n      // how to recover from RTF. So we just skip it.\n      element.remove();\n\n      return true;\n    }\n\n    const dataUri = `data:${rtfImage.mimeType};base64,${hexToBase64(\n      rtfImage.hex\n    )}`;\n\n    if (element.tagName === 'IMG') {\n      element.setAttribute('src', dataUri);\n    } else if (element.parentNode?.parentNode) {\n      const imageElement = document.createElement('img');\n      imageElement.setAttribute('src', dataUri);\n      element.parentNode.parentNode.replaceChild(\n        imageElement,\n        element.parentNode\n      );\n    }\n\n    return true;\n  });\n};\n","import { SPACE } from '@udecode/plate';\n\nexport const getRtfImageHex = (imageData: string): string | null => {\n  const [, bliptagData = ''] = imageData.split('bliptag');\n  const bracketSplit = bliptagData.split('}');\n\n  if (bracketSplit.length < 2) {\n    return null;\n  }\n\n  const [beforeBracket, afterBracket] = bracketSplit;\n\n  if (bracketSplit.length > 2 && beforeBracket.includes('blipuid')) {\n    return afterBracket.split(SPACE).join('');\n  }\n\n  const spaceSplit = beforeBracket.split(SPACE);\n\n  if (spaceSplit.length < 2) {\n    return null;\n  }\n\n  return spaceSplit.slice(1).join('');\n};\n","export const getRtfImageMimeType = (imageData: string): string | null => {\n  const [bliptagMeta] = imageData.split('bliptag');\n\n  if (bliptagMeta.includes('pngblip')) {\n    return 'image/png';\n  }\n  if (bliptagMeta.includes('jpegblip')) {\n    return 'image/jpeg';\n  }\n\n  return null;\n};\n","import { CARRIAGE_RETURN, LINE_FEED, SPACE } from '@udecode/plate';\n\nconst END_OF_ID_SEQUENCE_CHARACTERS = [\n  '\\\\',\n  '{',\n  CARRIAGE_RETURN,\n  LINE_FEED,\n  SPACE,\n];\n\nexport const getRtfImageSpid = (\n  imageData: string,\n  spidPrefix: string\n): string | null => {\n  const indexes = END_OF_ID_SEQUENCE_CHARACTERS.map((character) =>\n    imageData.indexOf(character)\n  );\n  const foundIndexes = indexes.filter((index) => index !== -1);\n  const idLength = Math.min(imageData.length, ...foundIndexes);\n  const id = imageData.slice(0, Math.max(0, idLength));\n\n  return id ? `${spidPrefix}${id}` : null;\n};\n","import type { RtfImage } from '../types';\n\nimport { getRtfImageHex } from './getRtfImageHex';\nimport { getRtfImageMimeType } from './getRtfImageMimeType';\nimport { getRtfImageSpid } from './getRtfImageSpid';\n\nexport const getRtfImagesByType = (\n  rtf: string,\n  spidPrefix: string,\n  type: string\n): RtfImage[] => {\n  const [, ...images] = rtf.split(type);\n\n  return images.reduce<RtfImage[]>((rtfImages, image) => {\n    const [, imageData = ''] = image.split('shplid');\n    const spid = getRtfImageSpid(imageData, spidPrefix);\n    const mimeType = getRtfImageMimeType(imageData);\n    const hex = getRtfImageHex(imageData);\n\n    if (spid && mimeType && hex) {\n      rtfImages.push({ hex, mimeType, spid });\n    }\n\n    return rtfImages;\n  }, []);\n};\n","import type { RtfImagesMap } from '../types';\n\nimport { getRtfImagesByType } from './getRtfImagesByType';\n\nexport const getRtfImagesMap = (rtf: string): RtfImagesMap => {\n  const rtfImagesMap: RtfImagesMap = {};\n\n  const shppictRtfImages = getRtfImagesByType(rtf, 'i', String.raw`\\shppict`);\n\n  for (const shppictRtfImage of shppictRtfImages) {\n    rtfImagesMap[shppictRtfImage.spid] = shppictRtfImage;\n  }\n\n  const shpRtfImages = getRtfImagesByType(rtf, 's', String.raw`\\shp`);\n\n  for (const shpRtfImage of shpRtfImages) {\n    rtfImagesMap[shpRtfImage.spid] = shpRtfImage;\n  }\n\n  return rtfImagesMap;\n};\n","import { getHtmlComments } from '@udecode/plate';\n\nexport const getVShapes = (document: Document): Record<string, string> => {\n  const comments = getHtmlComments(document);\n\n  return comments.reduce<Record<string, string>>((vShapesMap, comment) => {\n    try {\n      const xmlDocument = new DOMParser().parseFromString(comment, 'text/html');\n      const vShapes = Array.from(xmlDocument.querySelectorAll('V:SHAPE'));\n\n      vShapes.forEach((vShape) => {\n        const { id } = vShape;\n        const spid = vShape.getAttribute('o:spid');\n\n        if (typeof id === 'string' && typeof spid === 'string') {\n          vShapesMap[id] = spid;\n        }\n      });\n    } catch {\n      // Cannot parse as XML, we're not interested in this comment\n    }\n\n    return vShapesMap;\n  }, {});\n};\n","import { getVShapes } from './getVShapes';\n\nconst normalizeSpid = (spid: string): string => {\n  const id = spid.split('_')[2];\n\n  return id;\n};\n\nexport const getVShapeSpid = (\n  document: Document,\n  element: Element\n): string | null => {\n  if (element.tagName === 'IMG') {\n    const vShapeId = element.getAttribute('v:shapes');\n    const vShapes = getVShapes(document);\n\n    if (!vShapeId) {\n      return null;\n    }\n\n    const vShapeSpid = vShapes[vShapeId];\n\n    if (vShapeSpid) {\n      return normalizeSpid(vShapeSpid);\n    }\n    if (\n      element.parentElement?.parentElement?.innerHTML.includes('msEquation')\n    ) {\n      return null;\n    }\n\n    return normalizeSpid(vShapeId);\n  }\n  if (!element.parentElement) {\n    return null;\n  }\n\n  const spid = element.parentElement.getAttribute('o:spid');\n\n  if (spid) {\n    return normalizeSpid(spid);\n  }\n\n  return spid;\n};\n","import { traverseHtmlElements } from '@udecode/plate';\n\n/** Clean elements style mso-list to mso-list:Ignore */\nexport const cleanDocxListElements = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    const styleAttribute = element.getAttribute('style');\n\n    if (styleAttribute) {\n      element.setAttribute(\n        'style',\n        styleAttribute.replaceAll(/mso-list:\\s*ignore/gi, 'mso-list:Ignore')\n      );\n    }\n\n    return true;\n  });\n};\n","import { traverseHtmlElements } from '@udecode/plate';\n\nimport { docxListToList } from './docxListToList';\nimport { isDocxList } from './isDocxList';\n\nexport const cleanDocxListElementsToList = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    const styleAttribute = element.getAttribute('style');\n\n    if (styleAttribute) {\n      element.setAttribute(\n        'style',\n        styleAttribute.replaceAll(/mso-list:\\s*ignore/gi, 'mso-list:Ignore')\n      );\n    }\n\n    return true;\n  });\n\n  traverseHtmlElements(rootNode, (element) => {\n    if (!isDocxList(element)) {\n      return true;\n    }\n\n    const { parentElement, previousSibling } = element;\n\n    if (!parentElement) {\n      return true;\n    }\n\n    const { list } = docxListToList(element);\n\n    if (!list) {\n      return true;\n    }\n\n    const beforeElement = previousSibling\n      ? previousSibling.nextSibling\n      : parentElement.firstChild;\n\n    if (beforeElement) {\n      beforeElement.before(list);\n    } else {\n      parentElement.append(list);\n    }\n\n    return false;\n  });\n};\n","import { parseHtmlElement } from '@udecode/plate';\n\nimport { getDocxListContentHtml } from './getDocxListContentHtml';\nimport { getDocxListIndent } from './getDocxListIndent';\nimport { isDocxBookmark } from './isDocxBookmark';\nimport { isDocxList } from './isDocxList';\nimport { isDocxOl } from './isDocxOl';\n\ninterface Result {\n  list: Element | null;\n  nextSibling: Element | null;\n}\n\nexport const docxListToList = (element: Element): Result => {\n  const listLevel = getDocxListIndent(element);\n  let listHtml = '';\n  let nextSibling: Element | null = element;\n\n  while (nextSibling) {\n    if (isDocxBookmark(nextSibling)) {\n      nextSibling = nextSibling.nextElementSibling;\n\n      continue;\n    }\n    if (!isDocxList(nextSibling)) {\n      break;\n    }\n\n    const nextListLevel = getDocxListIndent(nextSibling);\n\n    if (nextListLevel < listLevel) {\n      // Lower level found. Current list is done.\n      break;\n    }\n    if (nextListLevel > listLevel) {\n      const nestedList = docxListToList(nextSibling);\n\n      if (nestedList.list) {\n        listHtml += nestedList.list.outerHTML;\n      }\n\n      nextSibling = nestedList.nextSibling;\n\n      continue;\n    }\n\n    listHtml += `<li>${getDocxListContentHtml(nextSibling)}</li>`;\n    const currentElement = nextSibling;\n    nextSibling = currentElement.nextElementSibling;\n    currentElement.remove();\n  }\n\n  const listTagName = isDocxOl(element) ? 'ol' : 'ul';\n  const list = parseHtmlElement(`<${listTagName}>${listHtml}</${listTagName}>`);\n\n  return { list, nextSibling };\n};\n","import {\n  removeHtmlNodesBetweenComments,\n  traverseHtmlElements,\n} from '@udecode/plate';\n\nexport const getDocxListContentHtml = (rootElement: Element): string => {\n  const clonedElement = rootElement.cloneNode(true) as Element;\n\n  removeHtmlNodesBetweenComments(\n    clonedElement,\n    '[if !supportLists]',\n    '[endif]'\n  );\n\n  traverseHtmlElements(clonedElement, (element) => {\n    const styleAttribute = element.getAttribute('style');\n\n    if (styleAttribute === 'mso-list:Ignore') {\n      element.remove();\n    }\n\n    return true;\n  });\n\n  return clonedElement.innerHTML;\n};\n","export const getDocxListIndent = (element: Element): number => {\n  const styleAttribute = element.getAttribute('style') || '';\n  const matches = /level(\\d+)/i.exec(styleAttribute);\n\n  if (matches && matches.length > 0) {\n    const [, level] = matches;\n\n    return Number.parseInt(level, 10);\n  }\n\n  return 1;\n};\n","export const isDocxBookmark = (element: Element): boolean => {\n  const styleAttribute = element.getAttribute('style');\n\n  return (\n    (styleAttribute || '').startsWith('mso-bookmark') && !element.textContent\n  );\n};\n","export const isDocxList = (element: Element): boolean => {\n  const styleAttribute = element.getAttribute('style');\n\n  if (!styleAttribute) {\n    return false;\n  }\n\n  const hasMsoListInStyle = /mso-list:\\s*l/i.test(styleAttribute);\n\n  if (!hasMsoListInStyle) {\n    return false;\n  }\n\n  const hasMsoListIgnoreChild = Boolean(\n    element.querySelector('[style=\"mso-list:Ignore\"]')\n  );\n\n  if (hasMsoListIgnoreChild) {\n    return true;\n  }\n\n  return element.outerHTML.includes('<!--[if !supportLists]-->');\n};\n","import { isOlSymbol } from '@udecode/plate';\n\nimport { getDocxListNode } from './getDocxListNode';\n\nexport const isDocxOl = (element: Element): boolean => {\n  const listNode = getDocxListNode(element);\n\n  if (!listNode) {\n    return false;\n  }\n\n  return isOlSymbol(listNode.textContent || '');\n};\n","export const getDocxListNode = (element: Element): Node | null => {\n  return (\n    element.querySelector('[style=\"mso-list:Ignore\"]') ||\n    element.querySelector('span[lang]')\n  );\n};\n","import { replaceTagName, traverseHtmlElements } from '@udecode/plate';\n\n/** Replace p.MsoQuote elements with blockquote. */\nexport const cleanDocxQuotes = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (\n      element.parentNode &&\n      element.tagName === 'P' &&\n      element.classList.contains('MsoQuote')\n    ) {\n      replaceTagName(element, 'blockquote');\n    }\n\n    return true;\n  });\n};\n","import { SPACE, TAB } from '@udecode/plate';\n\nexport const generateSpaces = (count: number): string =>\n  Array.from({ length: count }, () => SPACE).join('');\n\nexport const generateTabs = (count: number): string =>\n  Array.from({ length: count }, () => TAB).join('');\n","import { generateSpaces } from './generateSpaces';\n\n/** Replace the element with spaces if its style includes 'mso-spacerun: yes'. */\nexport const cleanDocxSpacerun = (element: Element): void => {\n  const styleAttribute = element.getAttribute('style');\n\n  if (\n    !(\n      styleAttribute &&\n      ['mso-spacerun: yes', 'mso-spacerun:yes'].includes(styleAttribute)\n    )\n  ) {\n    return;\n  }\n\n  const spacesCount = (element.textContent || '').length;\n  const replacementNode = document.createTextNode(generateSpaces(spacesCount));\n\n  if (element.parentNode) {\n    element.parentNode.replaceChild(replacementNode, element);\n  }\n};\n","import { traverseHtmlElements } from '@udecode/plate';\n\nimport { cleanDocxSpacerun } from './cleanDocxSpacerun';\nimport { cleanDocxTabCount } from './cleanDocxTabCount';\n\n/** Clean docx spaceruns and tab counts. */\nexport const cleanDocxSpans = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.nodeName !== 'SPAN') {\n      return true;\n    }\n\n    cleanDocxSpacerun(element);\n    cleanDocxTabCount(element);\n\n    return true;\n  });\n};\n","import { generateTabs } from './generateSpaces';\n\n/** Replace element with tabs if its style starts with 'mso-tab-count'. */\nexport const cleanDocxTabCount = (element: Element): void => {\n  const styleAttribute = element.getAttribute('style') || '';\n\n  if (!styleAttribute.startsWith('mso-tab-count:')) {\n    return;\n  }\n\n  const [, countString] = styleAttribute.split(':');\n  const count = Number.parseInt(countString, 10);\n  const replacementNode = document.createTextNode(generateTabs(count));\n\n  if (element.parentNode) {\n    element.parentNode.replaceChild(replacementNode, element);\n  }\n};\n","const DOCX_INDENT_STEP = 36;\n\n/**\n * Convert a string to floating number. Negative values are ignored. Values\n * starting by \".\" are replaced by \"0.\"\n */\nconst extractNumber = (str: string) => {\n  if (str.startsWith('-')) return 0;\n\n  let number = str.replace(/[^\\d,.]+/, '');\n\n  if (number.startsWith('.')) {\n    number = `0${number}`;\n  }\n\n  return Number.parseFloat(number);\n};\n\nconst styleToIndent = (style: string, indentStep = DOCX_INDENT_STEP) => {\n  const indent = extractNumber(style);\n\n  if (indent) {\n    if (style.includes('in')) {\n      return Math.round((indent * 72) / indentStep);\n    }\n\n    return Math.round(indent / indentStep);\n  }\n\n  return 0;\n};\n\nexport const getDocxSpacing = (element: Element, cssProp: string): number => {\n  const el = element as HTMLElement;\n  const spacing = (el.style as any)[cssProp];\n\n  if (!spacing) return 0;\n\n  return styleToIndent(spacing) || 0;\n};\n\nexport const getDocxIndent = (element: Element) =>\n  getDocxSpacing(element, 'marginLeft');\n\nexport const getDocxTextIndent = (element: Element) =>\n  getDocxSpacing(element, 'textIndent');\n","export const getTextListStyleType = (text: string): string | undefined => {\n  text = text.trimStart();\n\n  if (/^\\d+[.\\\\]/.exec(text)?.[0]) {\n    if (text.startsWith('0')) {\n      return 'decimal-leading-zero';\n    }\n\n    return 'decimal';\n  }\n  if (/^[cdilmvx]+\\./.exec(text)?.[0]) {\n    return 'lower-roman';\n  }\n  if (/^[a-z]+\\./.exec(text)?.[0]) {\n    return 'lower-alpha';\n  }\n  if (/^[CDILMVX]+\\./.exec(text)?.[0]) {\n    return 'upper-roman';\n  }\n  if (/^[A-Z]+\\./.exec(text)?.[0]) {\n    return 'upper-alpha';\n  }\n};\n","import { traverseHtmlElements } from '@udecode/plate';\n\n/**\n * Check if the element contains docx content. True if one element has:\n *\n * - Style including 'mso-'\n * - ClassName including 'Mso'\n */\nexport const isDocxContent = (body: HTMLElement): boolean => {\n  let result = false;\n\n  traverseHtmlElements(body, (element) => {\n    const styleAttribute = element.getAttribute('style') || '';\n    const classList = Array.from(element.classList);\n\n    const isMsoElement =\n      styleAttribute.includes('mso-') ||\n      classList.some((className) => className.startsWith('Mso'));\n\n    result = result || isMsoElement;\n\n    return !result;\n  });\n\n  return result;\n};\n"],"mappings":"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","names":["import_plate","import_plate","import_plate","import_plate","import_plate","import_plate","import_plate","import_plate","document","document","document","validator","import_plate","import_plate","import_plate","import_plate","import_plate","import_plate","import_plate","import_plate","import_plate","document"]}