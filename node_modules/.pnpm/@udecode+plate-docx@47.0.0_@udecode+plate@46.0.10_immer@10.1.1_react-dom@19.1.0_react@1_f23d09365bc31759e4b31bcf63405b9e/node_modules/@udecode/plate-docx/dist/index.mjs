// src/lib/DocxPlugin.ts
import {
  createSlatePlugin,
  HtmlPlugin
} from "@udecode/plate";

// src/lib/docx-cleaner/cleanDocx.ts
import {
  cleanHtmlBrElements,
  cleanHtmlEmptyElements,
  cleanHtmlFontElements,
  cleanHtmlLinkElements,
  cleanHtmlTextNodes,
  copyBlockMarksToSpanChild,
  postCleanHtml,
  preCleanHtml
} from "@udecode/plate";

// src/lib/docx-cleaner/utils/cleanDocxBrComments.ts
import {
  isHtmlComment,
  removeHtmlNodesBetweenComments,
  traverseHtmlElements
} from "@udecode/plate";
var cleanDocxBrComments = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    if (element.tagName !== "BR") {
      return true;
    }
    if (element.nextSibling && isHtmlComment(element.nextSibling) && element.nextSibling.data === "[if !supportLineBreakNewLine]") {
      removeHtmlNodesBetweenComments(
        element.nextSibling,
        "[if !supportLineBreakNewLine]",
        "[endif]"
      );
    }
    return false;
  });
};

// src/lib/docx-cleaner/utils/cleanDocxEmptyParagraphs.ts
import { NO_BREAK_SPACE, traverseHtmlElements as traverseHtmlElements2 } from "@udecode/plate";
var isHtmlOpEmpty = (element) => element.nodeName === "O:P" && element.textContent === NO_BREAK_SPACE;
var isHtmlElementEmpty = (element) => element.children.length === 1 && element.firstElementChild !== null && (isHtmlOpEmpty(element.firstElementChild) || isHtmlElementEmpty(element.firstElementChild));
var cleanDocxEmptyParagraphs = (rootNode) => {
  traverseHtmlElements2(rootNode, (element) => {
    if (element.tagName === "P" && isHtmlElementEmpty(element)) {
      element.innerHTML = "";
    }
    return true;
  });
};

// src/lib/docx-cleaner/utils/cleanDocxFootnotes.ts
import { traverseHtmlElements as traverseHtmlElements3 } from "@udecode/plate";

// src/lib/docx-cleaner/utils/isDocxFootnote.ts
var isDocxFootnote = (element) => {
  return element.tagName === "SPAN" && element.classList.contains("MsoFootnoteReference");
};

// src/lib/docx-cleaner/utils/cleanDocxFootnotes.ts
var extractFootnoteNumber = (footnote) => {
  return (footnote.textContent || "").trim().replaceAll(/[[\]]/g, "");
};
var cleanDocxFootnotes = (rootNode) => {
  traverseHtmlElements3(rootNode, (element) => {
    if (isDocxFootnote(element)) {
      const footnoteReplacement = document.createElement("sup");
      footnoteReplacement.textContent = extractFootnoteNumber(element);
      if (element.parentElement) {
        element.parentElement.replaceChild(footnoteReplacement, element);
      }
      return true;
    }
    return true;
  });
};

// src/lib/docx-cleaner/utils/cleanDocxImageElements.ts
import { hexToBase64, traverseHtmlElements as traverseHtmlElements4 } from "@udecode/plate";
import validator from "validator";

// src/lib/docx-cleaner/utils/getRtfImageHex.ts
import { SPACE } from "@udecode/plate";
var getRtfImageHex = (imageData) => {
  const [, bliptagData = ""] = imageData.split("bliptag");
  const bracketSplit = bliptagData.split("}");
  if (bracketSplit.length < 2) {
    return null;
  }
  const [beforeBracket, afterBracket] = bracketSplit;
  if (bracketSplit.length > 2 && beforeBracket.includes("blipuid")) {
    return afterBracket.split(SPACE).join("");
  }
  const spaceSplit = beforeBracket.split(SPACE);
  if (spaceSplit.length < 2) {
    return null;
  }
  return spaceSplit.slice(1).join("");
};

// src/lib/docx-cleaner/utils/getRtfImageMimeType.ts
var getRtfImageMimeType = (imageData) => {
  const [bliptagMeta] = imageData.split("bliptag");
  if (bliptagMeta.includes("pngblip")) {
    return "image/png";
  }
  if (bliptagMeta.includes("jpegblip")) {
    return "image/jpeg";
  }
  return null;
};

// src/lib/docx-cleaner/utils/getRtfImageSpid.ts
import { CARRIAGE_RETURN, LINE_FEED, SPACE as SPACE2 } from "@udecode/plate";
var END_OF_ID_SEQUENCE_CHARACTERS = [
  "\\",
  "{",
  CARRIAGE_RETURN,
  LINE_FEED,
  SPACE2
];
var getRtfImageSpid = (imageData, spidPrefix) => {
  const indexes = END_OF_ID_SEQUENCE_CHARACTERS.map(
    (character) => imageData.indexOf(character)
  );
  const foundIndexes = indexes.filter((index) => index !== -1);
  const idLength = Math.min(imageData.length, ...foundIndexes);
  const id = imageData.slice(0, Math.max(0, idLength));
  return id ? `${spidPrefix}${id}` : null;
};

// src/lib/docx-cleaner/utils/getRtfImagesByType.ts
var getRtfImagesByType = (rtf, spidPrefix, type) => {
  const [, ...images] = rtf.split(type);
  return images.reduce((rtfImages, image) => {
    const [, imageData = ""] = image.split("shplid");
    const spid = getRtfImageSpid(imageData, spidPrefix);
    const mimeType = getRtfImageMimeType(imageData);
    const hex = getRtfImageHex(imageData);
    if (spid && mimeType && hex) {
      rtfImages.push({ hex, mimeType, spid });
    }
    return rtfImages;
  }, []);
};

// src/lib/docx-cleaner/utils/getRtfImagesMap.ts
var getRtfImagesMap = (rtf) => {
  const rtfImagesMap = {};
  const shppictRtfImages = getRtfImagesByType(rtf, "i", String.raw`\shppict`);
  for (const shppictRtfImage of shppictRtfImages) {
    rtfImagesMap[shppictRtfImage.spid] = shppictRtfImage;
  }
  const shpRtfImages = getRtfImagesByType(rtf, "s", String.raw`\shp`);
  for (const shpRtfImage of shpRtfImages) {
    rtfImagesMap[shpRtfImage.spid] = shpRtfImage;
  }
  return rtfImagesMap;
};

// src/lib/docx-cleaner/utils/getVShapes.ts
import { getHtmlComments } from "@udecode/plate";
var getVShapes = (document2) => {
  const comments = getHtmlComments(document2);
  return comments.reduce((vShapesMap, comment) => {
    try {
      const xmlDocument = new DOMParser().parseFromString(comment, "text/html");
      const vShapes = Array.from(xmlDocument.querySelectorAll("V:SHAPE"));
      vShapes.forEach((vShape) => {
        const { id } = vShape;
        const spid = vShape.getAttribute("o:spid");
        if (typeof id === "string" && typeof spid === "string") {
          vShapesMap[id] = spid;
        }
      });
    } catch {
    }
    return vShapesMap;
  }, {});
};

// src/lib/docx-cleaner/utils/getVShapeSpid.ts
var normalizeSpid = (spid) => {
  const id = spid.split("_")[2];
  return id;
};
var getVShapeSpid = (document2, element) => {
  if (element.tagName === "IMG") {
    const vShapeId = element.getAttribute("v:shapes");
    const vShapes = getVShapes(document2);
    if (!vShapeId) {
      return null;
    }
    const vShapeSpid = vShapes[vShapeId];
    if (vShapeSpid) {
      return normalizeSpid(vShapeSpid);
    }
    if (element.parentElement?.parentElement?.innerHTML.includes("msEquation")) {
      return null;
    }
    return normalizeSpid(vShapeId);
  }
  if (!element.parentElement) {
    return null;
  }
  const spid = element.parentElement.getAttribute("o:spid");
  if (spid) {
    return normalizeSpid(spid);
  }
  return spid;
};

// src/lib/docx-cleaner/utils/cleanDocxImageElements.ts
var cleanDocxImageElements = (document2, rtf, rootNode) => {
  if (!rtf) {
    return;
  }
  traverseHtmlElements4(rootNode, (element) => {
    if (!["IMG", "V:IMAGEDATA"].includes(element.tagName)) {
      return true;
    }
    if (element.tagName === "IMG") {
      const src = element.getAttribute("src");
      if (!src?.startsWith("file://")) {
        return true;
      }
      const alt = element.getAttribute("alt");
      if (typeof alt === "string" && validator.isURL(alt, { require_protocol: true })) {
        element.setAttribute("src", alt);
        return true;
      }
    }
    const vShapeSpid = getVShapeSpid(document2, element);
    if (!vShapeSpid) {
      return true;
    }
    const rtfImagesMap = getRtfImagesMap(rtf);
    const rtfImage = rtfImagesMap[vShapeSpid];
    if (!rtfImage) {
      element.remove();
      return true;
    }
    const dataUri = `data:${rtfImage.mimeType};base64,${hexToBase64(
      rtfImage.hex
    )}`;
    if (element.tagName === "IMG") {
      element.setAttribute("src", dataUri);
    } else if (element.parentNode?.parentNode) {
      const imageElement = document2.createElement("img");
      imageElement.setAttribute("src", dataUri);
      element.parentNode.parentNode.replaceChild(
        imageElement,
        element.parentNode
      );
    }
    return true;
  });
};

// src/lib/docx-cleaner/utils/cleanDocxListElements.ts
import { traverseHtmlElements as traverseHtmlElements5 } from "@udecode/plate";
var cleanDocxListElements = (rootNode) => {
  traverseHtmlElements5(rootNode, (element) => {
    const styleAttribute = element.getAttribute("style");
    if (styleAttribute) {
      element.setAttribute(
        "style",
        styleAttribute.replaceAll(/mso-list:\s*ignore/gi, "mso-list:Ignore")
      );
    }
    return true;
  });
};

// src/lib/docx-cleaner/utils/cleanDocxListElementsToList.ts
import { traverseHtmlElements as traverseHtmlElements7 } from "@udecode/plate";

// src/lib/docx-cleaner/utils/docxListToList.ts
import { parseHtmlElement } from "@udecode/plate";

// src/lib/docx-cleaner/utils/getDocxListContentHtml.ts
import {
  removeHtmlNodesBetweenComments as removeHtmlNodesBetweenComments2,
  traverseHtmlElements as traverseHtmlElements6
} from "@udecode/plate";
var getDocxListContentHtml = (rootElement) => {
  const clonedElement = rootElement.cloneNode(true);
  removeHtmlNodesBetweenComments2(
    clonedElement,
    "[if !supportLists]",
    "[endif]"
  );
  traverseHtmlElements6(clonedElement, (element) => {
    const styleAttribute = element.getAttribute("style");
    if (styleAttribute === "mso-list:Ignore") {
      element.remove();
    }
    return true;
  });
  return clonedElement.innerHTML;
};

// src/lib/docx-cleaner/utils/getDocxListIndent.ts
var getDocxListIndent = (element) => {
  const styleAttribute = element.getAttribute("style") || "";
  const matches = /level(\d+)/i.exec(styleAttribute);
  if (matches && matches.length > 0) {
    const [, level] = matches;
    return Number.parseInt(level, 10);
  }
  return 1;
};

// src/lib/docx-cleaner/utils/isDocxBookmark.ts
var isDocxBookmark = (element) => {
  const styleAttribute = element.getAttribute("style");
  return (styleAttribute || "").startsWith("mso-bookmark") && !element.textContent;
};

// src/lib/docx-cleaner/utils/isDocxList.ts
var isDocxList = (element) => {
  const styleAttribute = element.getAttribute("style");
  if (!styleAttribute) {
    return false;
  }
  const hasMsoListInStyle = /mso-list:\s*l/i.test(styleAttribute);
  if (!hasMsoListInStyle) {
    return false;
  }
  const hasMsoListIgnoreChild = Boolean(
    element.querySelector('[style="mso-list:Ignore"]')
  );
  if (hasMsoListIgnoreChild) {
    return true;
  }
  return element.outerHTML.includes("<!--[if !supportLists]-->");
};

// src/lib/docx-cleaner/utils/isDocxOl.ts
import { isOlSymbol } from "@udecode/plate";

// src/lib/docx-cleaner/utils/getDocxListNode.ts
var getDocxListNode = (element) => {
  return element.querySelector('[style="mso-list:Ignore"]') || element.querySelector("span[lang]");
};

// src/lib/docx-cleaner/utils/isDocxOl.ts
var isDocxOl = (element) => {
  const listNode = getDocxListNode(element);
  if (!listNode) {
    return false;
  }
  return isOlSymbol(listNode.textContent || "");
};

// src/lib/docx-cleaner/utils/docxListToList.ts
var docxListToList = (element) => {
  const listLevel = getDocxListIndent(element);
  let listHtml = "";
  let nextSibling = element;
  while (nextSibling) {
    if (isDocxBookmark(nextSibling)) {
      nextSibling = nextSibling.nextElementSibling;
      continue;
    }
    if (!isDocxList(nextSibling)) {
      break;
    }
    const nextListLevel = getDocxListIndent(nextSibling);
    if (nextListLevel < listLevel) {
      break;
    }
    if (nextListLevel > listLevel) {
      const nestedList = docxListToList(nextSibling);
      if (nestedList.list) {
        listHtml += nestedList.list.outerHTML;
      }
      nextSibling = nestedList.nextSibling;
      continue;
    }
    listHtml += `<li>${getDocxListContentHtml(nextSibling)}</li>`;
    const currentElement = nextSibling;
    nextSibling = currentElement.nextElementSibling;
    currentElement.remove();
  }
  const listTagName = isDocxOl(element) ? "ol" : "ul";
  const list = parseHtmlElement(`<${listTagName}>${listHtml}</${listTagName}>`);
  return { list, nextSibling };
};

// src/lib/docx-cleaner/utils/cleanDocxListElementsToList.ts
var cleanDocxListElementsToList = (rootNode) => {
  traverseHtmlElements7(rootNode, (element) => {
    const styleAttribute = element.getAttribute("style");
    if (styleAttribute) {
      element.setAttribute(
        "style",
        styleAttribute.replaceAll(/mso-list:\s*ignore/gi, "mso-list:Ignore")
      );
    }
    return true;
  });
  traverseHtmlElements7(rootNode, (element) => {
    if (!isDocxList(element)) {
      return true;
    }
    const { parentElement, previousSibling } = element;
    if (!parentElement) {
      return true;
    }
    const { list } = docxListToList(element);
    if (!list) {
      return true;
    }
    const beforeElement = previousSibling ? previousSibling.nextSibling : parentElement.firstChild;
    if (beforeElement) {
      beforeElement.before(list);
    } else {
      parentElement.append(list);
    }
    return false;
  });
};

// src/lib/docx-cleaner/utils/cleanDocxQuotes.ts
import { replaceTagName, traverseHtmlElements as traverseHtmlElements8 } from "@udecode/plate";
var cleanDocxQuotes = (rootNode) => {
  traverseHtmlElements8(rootNode, (element) => {
    if (element.parentNode && element.tagName === "P" && element.classList.contains("MsoQuote")) {
      replaceTagName(element, "blockquote");
    }
    return true;
  });
};

// src/lib/docx-cleaner/utils/generateSpaces.ts
import { SPACE as SPACE3, TAB } from "@udecode/plate";
var generateSpaces = (count) => Array.from({ length: count }, () => SPACE3).join("");
var generateTabs = (count) => Array.from({ length: count }, () => TAB).join("");

// src/lib/docx-cleaner/utils/cleanDocxSpacerun.ts
var cleanDocxSpacerun = (element) => {
  const styleAttribute = element.getAttribute("style");
  if (!(styleAttribute && ["mso-spacerun: yes", "mso-spacerun:yes"].includes(styleAttribute))) {
    return;
  }
  const spacesCount = (element.textContent || "").length;
  const replacementNode = document.createTextNode(generateSpaces(spacesCount));
  if (element.parentNode) {
    element.parentNode.replaceChild(replacementNode, element);
  }
};

// src/lib/docx-cleaner/utils/cleanDocxSpans.ts
import { traverseHtmlElements as traverseHtmlElements9 } from "@udecode/plate";

// src/lib/docx-cleaner/utils/cleanDocxTabCount.ts
var cleanDocxTabCount = (element) => {
  const styleAttribute = element.getAttribute("style") || "";
  if (!styleAttribute.startsWith("mso-tab-count:")) {
    return;
  }
  const [, countString] = styleAttribute.split(":");
  const count = Number.parseInt(countString, 10);
  const replacementNode = document.createTextNode(generateTabs(count));
  if (element.parentNode) {
    element.parentNode.replaceChild(replacementNode, element);
  }
};

// src/lib/docx-cleaner/utils/cleanDocxSpans.ts
var cleanDocxSpans = (rootNode) => {
  traverseHtmlElements9(rootNode, (element) => {
    if (element.nodeName !== "SPAN") {
      return true;
    }
    cleanDocxSpacerun(element);
    cleanDocxTabCount(element);
    return true;
  });
};

// src/lib/docx-cleaner/utils/getDocxIndent.ts
var DOCX_INDENT_STEP = 36;
var extractNumber = (str) => {
  if (str.startsWith("-")) return 0;
  let number = str.replace(/[^\d,.]+/, "");
  if (number.startsWith(".")) {
    number = `0${number}`;
  }
  return Number.parseFloat(number);
};
var styleToIndent = (style, indentStep = DOCX_INDENT_STEP) => {
  const indent = extractNumber(style);
  if (indent) {
    if (style.includes("in")) {
      return Math.round(indent * 72 / indentStep);
    }
    return Math.round(indent / indentStep);
  }
  return 0;
};
var getDocxSpacing = (element, cssProp) => {
  const el = element;
  const spacing = el.style[cssProp];
  if (!spacing) return 0;
  return styleToIndent(spacing) || 0;
};
var getDocxIndent = (element) => getDocxSpacing(element, "marginLeft");
var getDocxTextIndent = (element) => getDocxSpacing(element, "textIndent");

// src/lib/docx-cleaner/utils/getTextListStyleType.ts
var getTextListStyleType = (text) => {
  text = text.trimStart();
  if (/^\d+[.\\]/.exec(text)?.[0]) {
    if (text.startsWith("0")) {
      return "decimal-leading-zero";
    }
    return "decimal";
  }
  if (/^[cdilmvx]+\./.exec(text)?.[0]) {
    return "lower-roman";
  }
  if (/^[a-z]+\./.exec(text)?.[0]) {
    return "lower-alpha";
  }
  if (/^[CDILMVX]+\./.exec(text)?.[0]) {
    return "upper-roman";
  }
  if (/^[A-Z]+\./.exec(text)?.[0]) {
    return "upper-alpha";
  }
};

// src/lib/docx-cleaner/utils/isDocxContent.ts
import { traverseHtmlElements as traverseHtmlElements10 } from "@udecode/plate";
var isDocxContent = (body) => {
  let result = false;
  traverseHtmlElements10(body, (element) => {
    const styleAttribute = element.getAttribute("style") || "";
    const classList = Array.from(element.classList);
    const isMsoElement = styleAttribute.includes("mso-") || classList.some((className) => className.startsWith("Mso"));
    result = result || isMsoElement;
    return !result;
  });
  return result;
};

// src/lib/docx-cleaner/cleanDocx.ts
var cleanDocx = (html, rtf) => {
  const document2 = new DOMParser().parseFromString(
    preCleanHtml(html),
    "text/html"
  );
  const { body } = document2;
  if (!rtf && !isDocxContent(body)) {
    return html;
  }
  cleanDocxFootnotes(body);
  cleanDocxImageElements(document2, rtf, body);
  cleanHtmlEmptyElements(body);
  cleanDocxEmptyParagraphs(body);
  cleanDocxQuotes(body);
  cleanDocxSpans(body);
  cleanHtmlTextNodes(body);
  cleanDocxBrComments(body);
  cleanHtmlBrElements(body);
  cleanHtmlLinkElements(body);
  cleanHtmlFontElements(body);
  cleanDocxListElements(body);
  copyBlockMarksToSpanChild(body);
  const preformattedWrapper = document2.createElement("div");
  preformattedWrapper.style.whiteSpace = "pre-wrap";
  preformattedWrapper.innerHTML = body.innerHTML;
  return postCleanHtml(preformattedWrapper.outerHTML);
};

// src/lib/DocxPlugin.ts
var parse = ({ element, type }) => {
  const node = { type };
  if (isDocxList(element)) {
    node.indent = getDocxListIndent(element);
    const text = element.textContent ?? "";
    node.listStyleType = getTextListStyleType(text) ?? "disc";
    element.innerHTML = getDocxListContentHtml(element);
  } else {
    const indent = getDocxIndent(element);
    if (indent) {
      node.indent = indent;
    }
    const textIndent = getDocxTextIndent(element);
    if (textIndent) {
      node.textIndent = textIndent;
    }
  }
  return node;
};
var DocxPlugin = createSlatePlugin({
  key: "docx",
  inject: {
    plugins: {
      [HtmlPlugin.key]: {
        parser: {
          transformData: ({ data, dataTransfer }) => {
            const rtf = dataTransfer.getData("text/rtf");
            return cleanDocx(data, rtf);
          }
        }
      }
    }
  },
  override: {
    plugins: {
      ...Object.fromEntries(
        ["p", "h1", "h2", "h3", "h4", "h5", "h6"].map((key) => [
          key,
          {
            parsers: {
              html: {
                deserializer: {
                  parse
                }
              }
            }
          }
        ])
      ),
      img: {
        parser: {
          query: ({ dataTransfer }) => {
            const data = dataTransfer.getData("text/html");
            const { body } = new DOMParser().parseFromString(data, "text/html");
            return !isDocxContent(body);
          }
        }
      }
    }
  }
});
export {
  DocxPlugin,
  cleanDocx,
  cleanDocxBrComments,
  cleanDocxEmptyParagraphs,
  cleanDocxFootnotes,
  cleanDocxImageElements,
  cleanDocxListElements,
  cleanDocxListElementsToList,
  cleanDocxQuotes,
  cleanDocxSpacerun,
  cleanDocxSpans,
  cleanDocxTabCount,
  docxListToList,
  generateSpaces,
  generateTabs,
  getDocxIndent,
  getDocxListContentHtml,
  getDocxListIndent,
  getDocxListNode,
  getDocxSpacing,
  getDocxTextIndent,
  getRtfImageHex,
  getRtfImageMimeType,
  getRtfImageSpid,
  getRtfImagesByType,
  getRtfImagesMap,
  getTextListStyleType,
  getVShapeSpid,
  getVShapes,
  isDocxBookmark,
  isDocxContent,
  isDocxFootnote,
  isDocxList,
  isDocxOl
};
//# sourceMappingURL=index.mjs.map