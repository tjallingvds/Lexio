{"version":3,"sources":["../src/index.ts","../src/createStore.ts","../src/middlewares/devtools.ts","../src/middlewares/immer.ts","../src/middlewares/mutative.ts","../src/middlewares/persist.ts","../src/utils/helpers.ts","../src/utils/extendActions.ts","../src/utils/extendSelectors.ts","../src/utils/storeFactory.ts","../src/useStore.ts"],"sourcesContent":["/**\n * @file Automatically generated by barrelsby.\n */\n\nexport * from './createStore';\nexport * from './useStore';\nexport * from './middlewares/index';\nexport * from './types/index';\nexport * from './utils/index';\n","import { createTrackedSelector } from 'react-tracked';\nimport { subscribeWithSelector } from 'zustand/middleware';\nimport { createWithEqualityFn as createStoreZustand } from 'zustand/traditional';\n\nimport {\n  devToolsMiddleware,\n  immerMiddleware,\n  persistMiddleware,\n} from './middlewares';\nimport { mutativeMiddleware } from './middlewares/mutative';\nimport { DefaultMutators, TBaseStoreOptions, TState } from './types';\nimport { TMiddleware } from './types/middleware';\nimport { getOptions } from './utils/helpers';\nimport { storeFactory } from './utils/storeFactory';\n\nimport type { TStateApiForBuilder } from './types';\nimport type { StateCreator, StoreMutatorIdentifier } from 'zustand';\n\n/**\n * Creates zustand store with additional selectors and actions.\n *\n * @param {StateType | StateCreator<StateType, Mps, Mcs>} initializer - A function or object that initializes the state.\n * @param {TBaseStoreOptions<StateType>} options - store create options.\n */\n\nexport const createStore = <\n  StateType extends TState,\n  Mps extends [StoreMutatorIdentifier, unknown][] = [],\n  Mcs extends [StoreMutatorIdentifier, unknown][] = [],\n  CreateStoreOptions extends\n    TBaseStoreOptions<StateType> = TBaseStoreOptions<StateType>,\n>(\n  initializer: StateType | StateCreator<StateType, Mps, Mcs>,\n  options: CreateStoreOptions\n) => {\n  type Mutators = [...DefaultMutators<StateType, CreateStoreOptions>, ...Mcs];\n  const {\n    name,\n    devtools: devtoolsOptions,\n    immer: immerOptions,\n    mutative: mutativeOptions,\n    persist: persistOptions,\n    isMutativeState,\n  } = options;\n\n  //current middlewares order devTools(persist(immer(initiator)))\n  const middlewares: TMiddleware[] = [];\n\n  //enable devtools\n  const _devtoolsOptionsInternal = getOptions(devtoolsOptions);\n  if (_devtoolsOptionsInternal.enabled) {\n    middlewares.push((config) =>\n      devToolsMiddleware(config, {\n        ..._devtoolsOptionsInternal,\n        name: _devtoolsOptionsInternal?.name ?? name,\n      })\n    );\n  }\n\n  //enable persist\n  const _persistOptionsInternal = getOptions(persistOptions);\n  if (_persistOptionsInternal.enabled) {\n    middlewares.push((config) =>\n      persistMiddleware(config, {\n        ..._persistOptionsInternal,\n        name: _persistOptionsInternal.name ?? name,\n      })\n    );\n  }\n\n  //enable immer\n  const _immerOptionsInternal = getOptions(immerOptions);\n  if (_immerOptionsInternal.enabled) {\n    middlewares.push((config) =>\n      immerMiddleware(config, _immerOptionsInternal)\n    );\n  }\n\n  //enable mutative\n  const _mutativeOptionsInternal = getOptions(mutativeOptions);\n  if (_mutativeOptionsInternal.enabled) {\n    middlewares.push((config) =>\n      mutativeMiddleware(config, _mutativeOptionsInternal)\n    );\n  }\n\n  const stateMutators = middlewares\n    .reverse()\n    .reduce(\n      (y, fn) => fn(y),\n      (typeof initializer === 'function'\n        ? initializer\n        : () => initializer) as StateCreator<StateType>\n    ) as StateCreator<StateType, [], Mutators>;\n\n  const store = createStoreZustand(subscribeWithSelector(stateMutators));\n\n  const useTrackedStore = createTrackedSelector(store);\n\n  const useTracked = (key: string) => {\n    return useTrackedStore()[key as keyof StateType];\n  };\n\n  const getFn = (key: string) => {\n    if (key === 'state') {\n      return store.getState();\n    }\n\n    return store.getState()[key as keyof StateType];\n  };\n\n  const subscribeFn = (\n    key: string,\n    selector: any,\n    listener: any,\n    subscribeOptions: any\n  ) => {\n    if (key === 'state') {\n      // @ts-expect-error -- typescript is unable to infer the 3 args version\n      return store.subscribe(selector, listener, subscribeOptions);\n    }\n\n    let wrappedSelector: any;\n\n    if (listener) {\n      // subscribe(selector, listener, subscribeOptions) variant\n      wrappedSelector = (state: StateType) =>\n        selector(state[key as keyof StateType]);\n    } else {\n      // subscribe(listener) variant\n      listener = selector;\n      wrappedSelector = (state: StateType) => state[key as keyof StateType];\n    }\n\n    // @ts-expect-error -- typescript is unable to infer the 3 args version\n    return store.subscribe(wrappedSelector, listener, subscribeOptions);\n  };\n\n  const isMutative =\n    isMutativeState ||\n    _immerOptionsInternal.enabled ||\n    _mutativeOptionsInternal.enabled;\n\n  const setFn = (key: string, value: any) => {\n    if (key === 'state') {\n      return (store.setState as any)(value);\n    }\n\n    const typedKey = key as keyof StateType;\n    const prevValue = store.getState()[typedKey];\n\n    if (prevValue === value) return;\n\n    const actionKey = key.replace(/^\\S/, (s) => s.toUpperCase());\n    const debugLog = name ? `@@${name}/set${actionKey}` : undefined;\n\n    (store.setState as any)?.(\n      isMutative\n        ? (draft: StateType) => {\n            draft[typedKey] = value;\n          }\n        : { [typedKey]: value },\n      undefined,\n      debugLog\n    );\n  };\n\n  const useValue = (\n    key: string,\n    equalityFn?: (oldValue: any, newValue: any) => boolean\n  ) => {\n    return store((state) => state[key as keyof StateType], equalityFn);\n  };\n\n  const useState = (\n    key: string,\n    equalityFn?: (oldValue: any, newValue: any) => boolean\n  ) => {\n    const value = useValue(key, equalityFn);\n\n    return [value, (val: any) => setFn(key, val)];\n  };\n\n  const apiInternal = {\n    get: getFn,\n    name,\n    set: setFn,\n    subscribe: subscribeFn,\n    store,\n    useStore: store,\n    useValue,\n    useState,\n    useTracked,\n    useTrackedStore,\n    actions: {},\n    selectors: {},\n  } as any as TStateApiForBuilder<StateType, Mutators>;\n\n  return storeFactory(apiInternal);\n};\n\n// Alias {@link createStore}\nexport const createZustandStore = createStore;\n","import { DevtoolsOptions as _DevtoolsOptions } from 'zustand/middleware';\n\nimport { MiddlewareOption } from '../types';\n\nexport { devtools as devToolsMiddleware } from 'zustand/middleware';\n\nexport type DevtoolsOptions = MiddlewareOption<Partial<_DevtoolsOptions>>;\n","import { produce } from 'immer';\n\nimport type { AnyFunction, MiddlewareOption } from '../types';\nimport type { Draft } from 'immer';\nimport type { StateCreator, StoreMutatorIdentifier } from 'zustand';\n\ndeclare module 'zustand' {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, unused-imports/no-unused-vars\n  interface StoreMutators<S, A> {\n    ['zustand/immer-x']: WithImmer<S>;\n  }\n}\n\ntype Write<T, U> = Omit<T, keyof U> & U;\ntype SkipTwo<T> = T extends { length: 0 }\n  ? []\n  : T extends { length: 1 }\n    ? []\n    : T extends { length: 0 | 1 }\n      ? []\n      : T extends [unknown, unknown, ...infer A]\n        ? A\n        : T extends [unknown, unknown?, ...infer A]\n          ? A\n          : T extends [unknown?, unknown?, ...infer A]\n            ? A\n            : never;\n\ntype SetStateType<T extends unknown[]> = Exclude<T[0], AnyFunction>;\n\ntype WithImmer<S> = Write<S, StoreImmer<S>>;\n\ntype StoreImmer<S> = S extends {\n  setState: infer SetState;\n}\n  ? SetState extends {\n      (...a: infer A1): infer Sr1;\n      (...a: infer A2): infer Sr2;\n    }\n    ? {\n        // Ideally, we would want to infer the `nextStateOrUpdater` `T` type from the\n        // `A1` type, but this is infeasible since it is an intersection with\n        // a partial type.\n        setState(\n          nextStateOrUpdater:\n            | SetStateType<A1>\n            | Partial<SetStateType<A1>>\n            | ((state: Draft<Partial<SetStateType<A1>>>) => void),\n          shouldReplace?: true,\n          ...a: SkipTwo<A1>\n        ): Sr1;\n        setState(\n          nextStateOrUpdater:\n            | SetStateType<A2>\n            | ((state: Draft<Partial<SetStateType<A2>>>) => void),\n          shouldReplace: false,\n          ...a: SkipTwo<A2>\n        ): Sr2;\n      }\n    : never\n  : never;\n\ntype Options = {\n  enableMapSet?: boolean;\n  enabledAutoFreeze?: boolean;\n};\ntype ImmerImpl = <T>(\n  storeInitializer: StateCreator<T, [], []>,\n  options?: Options\n) => StateCreator<T, [], []>;\n\nconst immerImpl: ImmerImpl = (initializer) => (set, get, store) => {\n  type T = ReturnType<typeof initializer>;\n\n  store.setState = (updater, replace, ...a) => {\n    const nextState = (\n      typeof updater === 'function' ? produce(updater as any) : updater\n    ) as ((s: T) => T) | T | Partial<T>;\n\n    return set(\n      nextState,\n      typeof replace === 'boolean' ? (replace as any) : true,\n      ...a\n    );\n  };\n\n  return initializer(store.setState, get, store);\n};\n\ntype Immer = <\n  T,\n  Mps extends [StoreMutatorIdentifier, unknown][] = [],\n  Mcs extends [StoreMutatorIdentifier, unknown][] = [],\n>(\n  initializer: StateCreator<T, [...Mps, ['zustand/immer-x', never]], Mcs>,\n  options?: Options\n) => StateCreator<T, Mps, [['zustand/immer-x', never], ...Mcs]>;\nexport const immerMiddleware = immerImpl as unknown as Immer;\n\nexport type ImmerOptions = MiddlewareOption<Options>;\n","import { create, PatchesOptions } from 'mutative';\n\nimport type { AnyFunction, MiddlewareOption } from '../types';\nimport type { Options as _MutativeOptions, Draft } from 'mutative';\nimport type { StateCreator, StoreMutatorIdentifier } from 'zustand';\n\ndeclare module 'zustand/vanilla' {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, unused-imports/no-unused-vars\n  interface StoreMutators<S, A> {\n    ['zustand/mutative-x']: WithMutative<S>;\n  }\n}\n\ntype SetStateType<T extends unknown[]> = Exclude<T[0], AnyFunction>;\ntype WithMutative<S> = Write<S, StoreMutative<S>>;\n\ntype Write<T, U> = Omit<T, keyof U> & U;\ntype SkipTwo<T> = T extends { length: 0 }\n  ? []\n  : T extends { length: 1 }\n    ? []\n    : T extends { length: 0 | 1 }\n      ? []\n      : T extends [unknown, unknown, ...infer A]\n        ? A\n        : T extends [unknown, unknown?, ...infer A]\n          ? A\n          : T extends [unknown?, unknown?, ...infer A]\n            ? A\n            : never;\ntype StoreMutative<S> = S extends {\n  setState: infer SetState;\n}\n  ? SetState extends {\n      (...a: infer A1): infer Sr1;\n      (...a: infer A2): infer Sr2;\n    }\n    ? {\n        // Ideally, we would want to infer the `nextStateOrUpdater` `T` type from the\n        // `A1` type, but this is infeasible since it is an intersection with\n        // a partial type.\n        setState(\n          nextStateOrUpdater:\n            | SetStateType<A1>\n            | Partial<SetStateType<A1>>\n            | ((state: Draft<Partial<SetStateType<A1>>>) => void),\n          shouldReplace?: true,\n          ...a: SkipTwo<A1>\n        ): Sr1;\n        setState(\n          nextStateOrUpdater:\n            | SetStateType<A2>\n            | ((state: Draft<Partial<SetStateType<A2>>>) => void),\n          shouldReplace: false,\n          ...a: SkipTwo<A2>\n        ): Sr2;\n      }\n    : never\n  : never;\n\ntype Options<O extends PatchesOptions, F extends boolean> = Omit<\n  _MutativeOptions<O, F>,\n  'enablePatches'\n>;\ntype MutativeImpl = <T, F extends boolean = false>(\n  storeInitializer: StateCreator<T, [], []>,\n  options?: Options<false, F>\n) => StateCreator<T, [], []>;\n\nconst mutativeImpl: MutativeImpl =\n  (initializer, options) => (set, get, store) => {\n    type T = ReturnType<typeof initializer>;\n\n    store.setState = (updater, replace, ...a) => {\n      const nextState = (\n        typeof updater === 'function'\n          ? create(\n              updater as any,\n              options ? { ...options, enablePatches: false } : options\n            )\n          : updater\n      ) as ((s: T) => T) | T | Partial<T>;\n\n      return set(\n        nextState as any,\n        typeof replace === 'boolean' ? (replace as any) : true,\n        ...a\n      );\n    };\n\n    return initializer(store.setState, get, store);\n  };\n\ntype Mutative = <\n  T,\n  Mps extends [StoreMutatorIdentifier, unknown][] = [],\n  Mcs extends [StoreMutatorIdentifier, unknown][] = [],\n  F extends boolean = false,\n>(\n  initializer: StateCreator<T, [...Mps, ['zustand/mutative-x', never]], Mcs>,\n  options?: Options<false, F>\n) => StateCreator<T, Mps, [['zustand/mutative-x', never], ...Mcs]>;\n\nexport const mutativeMiddleware = mutativeImpl as unknown as Mutative;\nexport type MutativeOptions<F extends boolean = false> = MiddlewareOption<\n  Options<false, F>\n>;\n","import { PersistOptions as _PersistOptions } from 'zustand/middleware';\n\nimport { MiddlewareOption } from '../types';\n\nexport { persist as persistMiddleware } from 'zustand/middleware';\nexport type PersistOptions<StateType> = MiddlewareOption<\n  Partial<_PersistOptions<StateType, Partial<StateType>>>\n>;\n","import { MiddlewareOption } from '../types';\n\nexport const getOptions = <T extends MiddlewareOption<object> | undefined>(\n  option: T,\n  fallbackEnabled: boolean = false\n) => {\n  const isBooleanValue = typeof option === 'boolean';\n  const { enabled, ...config } = (\n    isBooleanValue ? {} : option || {}\n  ) as Exclude<T, boolean | undefined>;\n  const isValueProvided = isBooleanValue ? option : enabled;\n  return {\n    enabled: isValueProvided ?? fallbackEnabled,\n    ...config,\n  };\n};\n","import { StoreMutatorIdentifier } from 'zustand';\n\nimport { TActionBuilder, TState, TStateApiForBuilder } from '../types';\n\nimport type { AnyFunction } from '../types';\n\nexport const extendActions = <\n  StateType extends TState,\n  Mutators extends [StoreMutatorIdentifier, unknown][],\n  TActions extends Record<string, AnyFunction>,\n  TSelectors extends Record<string, AnyFunction>,\n  Builder extends TActionBuilder<StateType, Mutators, TActions, TSelectors>,\n>(\n  builder: Builder,\n  api: TStateApiForBuilder<StateType, Mutators, TActions, TSelectors>\n) => {\n  const newActions = builder(api);\n  const actions = {\n    ...api.actions,\n    ...newActions,\n  };\n\n  return {\n    ...api,\n    actions,\n    set: <K extends keyof (StateType | TActions)>(\n      key: K,\n      ...args: K extends keyof TActions\n        ? Parameters<TActions[K]>\n        : K extends keyof StateType\n          ? [StateType[K]]\n          : never\n    ) => {\n      if (key in actions) {\n        const action = actions[key as keyof typeof actions];\n        return action(...args);\n      }\n      return api.set(key as any, args[0]);\n    },\n  };\n};\n","import { StoreMutatorIdentifier } from 'zustand';\n\nimport {\n  AnyFunction,\n  TEqualityChecker,\n  TSelectorBuilder,\n  TState,\n  TStateApiForBuilder,\n} from '../types';\n\nconst identity = <T>(arg: T) => arg;\n\nexport const extendSelectors = <\n  StateType extends TState,\n  Mutators extends [StoreMutatorIdentifier, unknown][],\n  TActions extends Record<string, AnyFunction>,\n  TSelectors extends Record<string, AnyFunction>,\n  Builder extends TSelectorBuilder<StateType, Mutators, TActions, TSelectors>,\n>(\n  builder: Builder,\n  api: TStateApiForBuilder<StateType, Mutators, TActions, TSelectors>\n) => {\n  const newSelectors = builder(api);\n  const selectors = {\n    ...api.selectors,\n    ...newSelectors,\n  };\n\n  return {\n    ...api,\n    get: <K extends keyof (StateType & TSelectors & { state: true })>(\n      key: K,\n      ...args: K extends keyof TSelectors ? Parameters<TSelectors[K]> : []\n    ) => {\n      if (key in selectors) {\n        const selector = selectors[key as keyof typeof selectors];\n        return selector(...args);\n      }\n      return api.get(key as keyof StateType);\n    },\n    subscribe: <K extends keyof (StateType & TSelectors & { state: true })>(\n      key: keyof (StateType & TSelectors & { state: true }),\n      ...args: [\n        ...[K extends keyof TSelectors ? Parameters<TSelectors[K]> : []],\n        selector: AnyFunction,\n        listener: AnyFunction,\n        options?: any,\n      ]\n    ) => {\n      if (key in selectors) {\n        // variants:\n        //                     subscribe(key, ...args,  listener)\n        //           subscribe(key, ...args, selector,  listener)\n        // subscribe(key, ...args, selector, listener,  undefined)\n        // subscribe(key, ...args, selector, listener,  options)\n        let options: any;\n        let selector: any;\n        let listener: any;\n        const lastArg1 = args.at(-1);\n        const lastArg2 = args.at(-2); // May be undefined\n        const lastArg3 = args.at(-3); // May be undefined\n        let argsEndIdx = -1;\n\n        if (typeof lastArg1 === 'function') {\n          listener = lastArg1;\n          selector = typeof lastArg2 === 'function' ? lastArg2 : identity;\n          argsEndIdx = typeof lastArg2 === 'function' ? -2 : -1;\n        } else {\n          options = lastArg1;\n          listener = lastArg2;\n          selector = lastArg3;\n          argsEndIdx = -3;\n        }\n\n        return api.subscribe(\n          // The key `state` does not matter, as selectors are closures over the `api`\n          'state',\n          () =>\n            selector(\n              selectors[key as keyof typeof selectors](\n                ...args.slice(0, argsEndIdx)\n              )\n            ),\n          listener,\n          options\n        );\n      }\n      // @ts-expect-error -- don't know how to type this\n      return api.subscribe(key, ...args);\n    },\n    selectors,\n    useValue: <K extends keyof (StateType & TSelectors)>(\n      key: K,\n      ...args: K extends keyof TSelectors\n        ? [\n            ...Parameters<TSelectors[K]>,\n            TEqualityChecker<ReturnType<TSelectors[K]>> | undefined,\n          ]\n        : [TEqualityChecker<StateType[keyof StateType]> | undefined]\n    ) => {\n      if (key in selectors) {\n        const selector = selectors[key as keyof typeof selectors];\n        const lastArg = args.at(-1);\n        const equalityFn = typeof lastArg === 'function' ? lastArg : undefined;\n        const selectorArgs = equalityFn ? args.slice(0, -1) : args;\n\n        return api.useStore(() => selector(...selectorArgs), equalityFn as any);\n      }\n      return api.useValue(\n        key as keyof StateType,\n        args[0] as TEqualityChecker<StateType[keyof StateType]>\n      );\n    },\n  };\n};\n","import { StoreMutatorIdentifier } from 'zustand';\n\nimport { TState, TStateApi, TStateApiForBuilder } from '../types';\nimport { extendActions } from './extendActions';\nimport { extendSelectors } from './extendSelectors';\n\nimport type { AnyFunction } from '../types';\n\nexport const storeFactory = <\n  StateType extends TState,\n  Mutators extends [StoreMutatorIdentifier, unknown][] = [],\n  TActions extends Record<string, AnyFunction> = {},\n  TSelectors extends Record<string, AnyFunction> = {},\n>(\n  api: TStateApiForBuilder<StateType, Mutators, TActions, TSelectors>\n): TStateApi<StateType, Mutators, TActions, TSelectors> => {\n  return {\n    ...api,\n    actions: api.actions || {},\n    extendSelectors: (builder) =>\n      storeFactory(extendSelectors(builder, api) as any),\n    extendActions: (builder) =>\n      storeFactory(extendActions(builder, api) as any),\n  } as TStateApi<StateType, Mutators, TActions, TSelectors>;\n};\n","import type { AnyFunction, TEqualityChecker, TState, TStateApi } from './types';\nimport type { StoreMutatorIdentifier } from 'zustand';\n\nexport function useStoreValue<\n  StateType extends TState,\n  Mutators extends [StoreMutatorIdentifier, unknown][],\n  TActions extends Record<string, AnyFunction> = {},\n  TSelectors extends Record<string, AnyFunction> = {},\n  K extends keyof StateType = keyof StateType,\n>(\n  store: TStateApi<StateType, Mutators, TActions, TSelectors>,\n  key: K\n): StateType[K];\nexport function useStoreValue<\n  StateType extends TState,\n  Mutators extends [StoreMutatorIdentifier, unknown][],\n  TActions extends Record<string, AnyFunction> = {},\n  TSelectors extends Record<string, AnyFunction> = {},\n  K extends keyof TSelectors = keyof TSelectors,\n>(\n  store: TStateApi<StateType, Mutators, TActions, TSelectors>,\n  key: K,\n  ...args: Parameters<TSelectors[K]>\n): ReturnType<TSelectors[K]>;\nexport function useStoreValue<\n  StateType extends TState,\n  Mutators extends [StoreMutatorIdentifier, unknown][],\n  TActions extends Record<string, AnyFunction> = {},\n  TSelectors extends Record<string, AnyFunction> = {},\n>(\n  store: TStateApi<StateType, Mutators, TActions, TSelectors>,\n  key: 'state'\n): StateType;\nexport function useStoreValue<\n  StateType extends TState,\n  Mutators extends [StoreMutatorIdentifier, unknown][],\n  TActions extends Record<string, AnyFunction> = {},\n  TSelectors extends Record<string, AnyFunction> = {},\n  K extends keyof StateType = keyof StateType,\n>(\n  store: TStateApi<StateType, Mutators, TActions, TSelectors>,\n  key: K,\n  equalityFn?: TEqualityChecker<StateType[K]>\n): StateType[K];\nexport function useStoreValue<\n  StateType extends TState,\n  Mutators extends [StoreMutatorIdentifier, unknown][],\n  TActions extends Record<string, AnyFunction> = {},\n  TSelectors extends Record<string, AnyFunction> = {},\n  K extends keyof TSelectors = keyof TSelectors,\n>(\n  store: TStateApi<StateType, Mutators, TActions, TSelectors>,\n  key: K,\n  ...args: [\n    ...Parameters<TSelectors[K]>,\n    TEqualityChecker<ReturnType<TSelectors[K]>>?,\n  ]\n): ReturnType<TSelectors[K]>;\nexport function useStoreValue<\n  StateType extends TState,\n  Mutators extends [StoreMutatorIdentifier, unknown][],\n  TActions extends Record<string, AnyFunction> = {},\n  TSelectors extends Record<string, AnyFunction> = {},\n  K extends keyof StateType | keyof TSelectors =\n    | keyof StateType\n    | keyof TSelectors,\n>(\n  store: TStateApi<StateType, Mutators, TActions, TSelectors>,\n  key: K,\n  ...args: unknown[]\n) {\n  return store.useValue(key as any, ...(args as any));\n}\n\nexport function useStoreState<\n  StateType extends TState,\n  Mutators extends [StoreMutatorIdentifier, unknown][],\n  TActions extends Record<string, AnyFunction> = {},\n  TSelectors extends Record<string, AnyFunction> = {},\n  K extends keyof StateType = keyof StateType,\n>(\n  store: TStateApi<StateType, Mutators, TActions, TSelectors>,\n  key: K,\n  equalityFn?: TEqualityChecker<StateType[K]>\n): [StateType[K], (value: StateType[K]) => void] {\n  return store.useState(key, equalityFn);\n}\n\nexport function useTrackedStore<\n  StateType extends TState,\n  Mutators extends [StoreMutatorIdentifier, unknown][],\n  TActions extends Record<string, AnyFunction> = {},\n  TSelectors extends Record<string, AnyFunction> = {},\n>(store: TStateApi<StateType, Mutators, TActions, TSelectors>): StateType {\n  return store.useTrackedStore();\n}\n\nexport function useTracked<\n  StateType extends TState,\n  Mutators extends [StoreMutatorIdentifier, unknown][],\n  TActions extends Record<string, AnyFunction> = {},\n  TSelectors extends Record<string, AnyFunction> = {},\n  K extends keyof StateType = keyof StateType,\n>(\n  store: TStateApi<StateType, Mutators, TActions, TSelectors>,\n  key: K\n): StateType[K] {\n  return store.useTracked(key);\n}\n\n/**\n * Use zustand store selector with optional equality function.\n * @example\n * const name = useStoreSelect(store, (state) => state.name, equalityFn)\n */\nexport const useStoreSelect = <\n  StateType extends TState,\n  Mutators extends [StoreMutatorIdentifier, unknown][],\n  TActions extends Record<string, AnyFunction> = {},\n  TSelectors extends Record<string, AnyFunction> = {},\n  U = StateType,\n>(\n  store: TStateApi<StateType, Mutators, TActions, TSelectors>,\n  selector: (state: StateType) => U,\n  equalityFn?: (a: U, b: U) => boolean\n): U => {\n  return store.useStore(selector, equalityFn);\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,2BAAsC;AACtC,IAAAA,qBAAsC;AACtC,yBAA2D;;;ACE3D,wBAA+C;;;ACJ/C,mBAAwB;AAuExB,IAAM,YAAuB,CAAC,gBAAgB,CAAC,KAAK,KAAK,UAAU;AAGjE,QAAM,WAAW,CAAC,SAAS,YAAY,MAAM;AAC3C,UAAM,YACJ,OAAO,YAAY,iBAAa,sBAAQ,OAAc,IAAI;AAG5D,WAAO;AAAA,MACL;AAAA,MACA,OAAO,YAAY,YAAa,UAAkB;AAAA,MAClD,GAAG;AAAA,IACL;AAAA,EACF;AAEA,SAAO,YAAY,MAAM,UAAU,KAAK,KAAK;AAC/C;AAUO,IAAM,kBAAkB;;;ACjG/B,sBAAuC;AAqEvC,IAAM,eACJ,CAAC,aAAa,YAAY,CAAC,KAAK,KAAK,UAAU;AAG7C,QAAM,WAAW,CAAC,SAAS,YAAY,MAAM;AAC3C,UAAM,YACJ,OAAO,YAAY,iBACf;AAAA,MACE;AAAA,MACA,UAAU,iCAAK,UAAL,EAAc,eAAe,MAAM,KAAI;AAAA,IACnD,IACA;AAGN,WAAO;AAAA,MACL;AAAA,MACA,OAAO,YAAY,YAAa,UAAkB;AAAA,MAClD,GAAG;AAAA,IACL;AAAA,EACF;AAEA,SAAO,YAAY,MAAM,UAAU,KAAK,KAAK;AAC/C;AAYK,IAAM,qBAAqB;;;ACnGlC,IAAAC,qBAA6C;;;ACFtC,IAAM,aAAa,CACxB,QACA,kBAA2B,UACxB;AACH,QAAM,iBAAiB,OAAO,WAAW;AACzC,QACE,sBAAiB,CAAC,IAAI,UAAU,CAAC,GAD3B,UAPV,IAQI,IADkB,mBAClB,IADkB,CAAZ;AAGR,QAAM,kBAAkB,iBAAiB,SAAS;AAClD,SAAO;AAAA,IACL,SAAS,4CAAmB;AAAA,KACzB;AAEP;;;ACTO,IAAM,gBAAgB,CAO3B,SACA,QACG;AACH,QAAM,aAAa,QAAQ,GAAG;AAC9B,QAAM,UAAU,kCACX,IAAI,UACJ;AAGL,SAAO,iCACF,MADE;AAAA,IAEL;AAAA,IACA,KAAK,CACH,QACG,SAKA;AACH,UAAI,OAAO,SAAS;AAClB,cAAM,SAAS,QAAQ,GAA2B;AAClD,eAAO,OAAO,GAAG,IAAI;AAAA,MACvB;AACA,aAAO,IAAI,IAAI,KAAY,KAAK,CAAC,CAAC;AAAA,IACpC;AAAA,EACF;AACF;;;AC9BA,IAAM,WAAW,CAAI,QAAW;AAEzB,IAAM,kBAAkB,CAO7B,SACA,QACG;AACH,QAAM,eAAe,QAAQ,GAAG;AAChC,QAAM,YAAY,kCACb,IAAI,YACJ;AAGL,SAAO,iCACF,MADE;AAAA,IAEL,KAAK,CACH,QACG,SACA;AACH,UAAI,OAAO,WAAW;AACpB,cAAM,WAAW,UAAU,GAA6B;AACxD,eAAO,SAAS,GAAG,IAAI;AAAA,MACzB;AACA,aAAO,IAAI,IAAI,GAAsB;AAAA,IACvC;AAAA,IACA,WAAW,CACT,QACG,SAMA;AACH,UAAI,OAAO,WAAW;AAMpB,YAAI;AACJ,YAAI;AACJ,YAAI;AACJ,cAAM,WAAW,KAAK,GAAG,EAAE;AAC3B,cAAM,WAAW,KAAK,GAAG,EAAE;AAC3B,cAAM,WAAW,KAAK,GAAG,EAAE;AAC3B,YAAI,aAAa;AAEjB,YAAI,OAAO,aAAa,YAAY;AAClC,qBAAW;AACX,qBAAW,OAAO,aAAa,aAAa,WAAW;AACvD,uBAAa,OAAO,aAAa,aAAa,KAAK;AAAA,QACrD,OAAO;AACL,oBAAU;AACV,qBAAW;AACX,qBAAW;AACX,uBAAa;AAAA,QACf;AAEA,eAAO,IAAI;AAAA;AAAA,UAET;AAAA,UACA,MACE;AAAA,YACE,UAAU,GAA6B;AAAA,cACrC,GAAG,KAAK,MAAM,GAAG,UAAU;AAAA,YAC7B;AAAA,UACF;AAAA,UACF;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAEA,aAAO,IAAI,UAAU,KAAK,GAAG,IAAI;AAAA,IACnC;AAAA,IACA;AAAA,IACA,UAAU,CACR,QACG,SAMA;AACH,UAAI,OAAO,WAAW;AACpB,cAAM,WAAW,UAAU,GAA6B;AACxD,cAAM,UAAU,KAAK,GAAG,EAAE;AAC1B,cAAM,aAAa,OAAO,YAAY,aAAa,UAAU;AAC7D,cAAM,eAAe,aAAa,KAAK,MAAM,GAAG,EAAE,IAAI;AAEtD,eAAO,IAAI,SAAS,MAAM,SAAS,GAAG,YAAY,GAAG,UAAiB;AAAA,MACxE;AACA,aAAO,IAAI;AAAA,QACT;AAAA,QACA,KAAK,CAAC;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACF;;;AC1GO,IAAM,eAAe,CAM1B,QACyD;AACzD,SAAO,iCACF,MADE;AAAA,IAEL,SAAS,IAAI,WAAW,CAAC;AAAA,IACzB,iBAAiB,CAAC,YAChB,aAAa,gBAAgB,SAAS,GAAG,CAAQ;AAAA,IACnD,eAAe,CAAC,YACd,aAAa,cAAc,SAAS,GAAG,CAAQ;AAAA,EACnD;AACF;;;ARCO,IAAM,cAAc,CAOzB,aACA,YACG;AAEH,QAAM;AAAA,IACJ;AAAA,IACA,UAAU;AAAA,IACV,OAAO;AAAA,IACP,UAAU;AAAA,IACV,SAAS;AAAA,IACT;AAAA,EACF,IAAI;AAGJ,QAAM,cAA6B,CAAC;AAGpC,QAAM,2BAA2B,WAAW,eAAe;AAC3D,MAAI,yBAAyB,SAAS;AACpC,gBAAY;AAAA,MAAK,CAAC,WAAQ;AAnD9B;AAoDM,+CAAmB,QAAQ,iCACtB,2BADsB;AAAA,UAEzB,OAAM,0EAA0B,SAA1B,YAAkC;AAAA,QAC1C,EAAC;AAAA;AAAA,IACH;AAAA,EACF;AAGA,QAAM,0BAA0B,WAAW,cAAc;AACzD,MAAI,wBAAwB,SAAS;AACnC,gBAAY;AAAA,MAAK,CAAC,WAAQ;AA9D9B;AA+DM,+CAAkB,QAAQ,iCACrB,0BADqB;AAAA,UAExB,OAAM,6BAAwB,SAAxB,YAAgC;AAAA,QACxC,EAAC;AAAA;AAAA,IACH;AAAA,EACF;AAGA,QAAM,wBAAwB,WAAW,YAAY;AACrD,MAAI,sBAAsB,SAAS;AACjC,gBAAY;AAAA,MAAK,CAAC,WAChB,gBAAgB,QAAQ,qBAAqB;AAAA,IAC/C;AAAA,EACF;AAGA,QAAM,2BAA2B,WAAW,eAAe;AAC3D,MAAI,yBAAyB,SAAS;AACpC,gBAAY;AAAA,MAAK,CAAC,WAChB,mBAAmB,QAAQ,wBAAwB;AAAA,IACrD;AAAA,EACF;AAEA,QAAM,gBAAgB,YACnB,QAAQ,EACR;AAAA,IACC,CAAC,GAAG,OAAO,GAAG,CAAC;AAAA,IACd,OAAO,gBAAgB,aACpB,cACA,MAAM;AAAA,EACZ;AAEF,QAAM,YAAQ,mBAAAC,0BAAmB,0CAAsB,aAAa,CAAC;AAErE,QAAMC,uBAAkB,4CAAsB,KAAK;AAEnD,QAAMC,cAAa,CAAC,QAAgB;AAClC,WAAOD,iBAAgB,EAAE,GAAsB;AAAA,EACjD;AAEA,QAAM,QAAQ,CAAC,QAAgB;AAC7B,QAAI,QAAQ,SAAS;AACnB,aAAO,MAAM,SAAS;AAAA,IACxB;AAEA,WAAO,MAAM,SAAS,EAAE,GAAsB;AAAA,EAChD;AAEA,QAAM,cAAc,CAClB,KACA,UACA,UACA,qBACG;AACH,QAAI,QAAQ,SAAS;AAEnB,aAAO,MAAM,UAAU,UAAU,UAAU,gBAAgB;AAAA,IAC7D;AAEA,QAAI;AAEJ,QAAI,UAAU;AAEZ,wBAAkB,CAAC,UACjB,SAAS,MAAM,GAAsB,CAAC;AAAA,IAC1C,OAAO;AAEL,iBAAW;AACX,wBAAkB,CAAC,UAAqB,MAAM,GAAsB;AAAA,IACtE;AAGA,WAAO,MAAM,UAAU,iBAAiB,UAAU,gBAAgB;AAAA,EACpE;AAEA,QAAM,aACJ,mBACA,sBAAsB,WACtB,yBAAyB;AAE3B,QAAM,QAAQ,CAAC,KAAa,UAAe;AA/I7C;AAgJI,QAAI,QAAQ,SAAS;AACnB,aAAQ,MAAM,SAAiB,KAAK;AAAA,IACtC;AAEA,UAAM,WAAW;AACjB,UAAM,YAAY,MAAM,SAAS,EAAE,QAAQ;AAE3C,QAAI,cAAc;AAAO;AAEzB,UAAM,YAAY,IAAI,QAAQ,OAAO,CAAC,MAAM,EAAE,YAAY,CAAC;AAC3D,UAAM,WAAW,OAAO,KAAK,IAAI,OAAO,SAAS,KAAK;AAEtD,KAAC,WAAM,aAAN;AAAA;AAAA,MACC,aACI,CAAC,UAAqB;AACpB,cAAM,QAAQ,IAAI;AAAA,MACpB,IACA,EAAE,CAAC,QAAQ,GAAG,MAAM;AAAA,MACxB;AAAA,MACA;AAAA;AAAA,EAEJ;AAEA,QAAM,WAAW,CACf,KACA,eACG;AACH,WAAO,MAAM,CAAC,UAAU,MAAM,GAAsB,GAAG,UAAU;AAAA,EACnE;AAEA,QAAM,WAAW,CACf,KACA,eACG;AACH,UAAM,QAAQ,SAAS,KAAK,UAAU;AAEtC,WAAO,CAAC,OAAO,CAAC,QAAa,MAAM,KAAK,GAAG,CAAC;AAAA,EAC9C;AAEA,QAAM,cAAc;AAAA,IAClB,KAAK;AAAA,IACL;AAAA,IACA,KAAK;AAAA,IACL,WAAW;AAAA,IACX;AAAA,IACA,UAAU;AAAA,IACV;AAAA,IACA;AAAA,IACA,YAAAC;AAAA,IACA,iBAAAD;AAAA,IACA,SAAS,CAAC;AAAA,IACV,WAAW,CAAC;AAAA,EACd;AAEA,SAAO,aAAa,WAAW;AACjC;AAGO,IAAM,qBAAqB;;;AShJ3B,SAAS,cASd,OACA,QACG,MACH;AACA,SAAO,MAAM,SAAS,KAAY,GAAI,IAAY;AACpD;AAEO,SAAS,cAOd,OACA,KACA,YAC+C;AAC/C,SAAO,MAAM,SAAS,KAAK,UAAU;AACvC;AAEO,SAAS,gBAKd,OAAwE;AACxE,SAAO,MAAM,gBAAgB;AAC/B;AAEO,SAAS,WAOd,OACA,KACc;AACd,SAAO,MAAM,WAAW,GAAG;AAC7B;AAOO,IAAM,iBAAiB,CAO5B,OACA,UACA,eACM;AACN,SAAO,MAAM,SAAS,UAAU,UAAU;AAC5C;","names":["import_middleware","import_middleware","createStoreZustand","useTrackedStore","useTracked"]}